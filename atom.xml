<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CRAYMC</title>
  <subtitle>http://www.craymc.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.craymc.com/"/>
  <updated>2017-01-22T13:52:06.805Z</updated>
  <id>http://www.craymc.com/</id>
  
  <author>
    <name>craymc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>适配器模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/适配器模式详解/</id>
    <published>2017-01-22T13:42:33.000Z</published>
    <updated>2017-01-22T13:52:06.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="适配器模式详解"><a href="#适配器模式详解" class="headerlink" title="适配器模式详解"></a>适配器模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。"><a href="#定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。" class="headerlink" title="定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。"></a>定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>对象适配器模式的结构中包括三种角色：</p>
<ul>
<li>目标： 目标是一个接口，该接口是客户想要使用的接口。</li>
<li>被适配者： 被适配者是一个已经存在的接口或抽象类，这个接口或抽象类需要适配。</li>
<li>适配器：适配器是一个类，该类实现了目标接口并包含有被适配者的引用，既适配器的职责是对被适配者接口（抽象类）与目标接口进行适配。</li>
</ul>
<hr>
<h4 id="适配器的适配程度"><a href="#适配器的适配程度" class="headerlink" title="适配器的适配程度"></a>适配器的适配程度</h4><p>1.完全适配<br>如果目标接口中的方法数目与被适配者接口的方法数目相等，那么适配器可将被适配者接口与目标接口进行完全适配。<br>2.不完全适配<br>如果目标接口中的方法数目少于被适配者接口的方法数目，那么适配器只能将被适配者接口与目标接口进行部分适配。<br>3.剩余适配<br>如果目标接口中的方法数目大于被适配者接口的方法数目，那么适配器可将被适配者接口与目标接口进行完全适配，但必须将目标多余的办法给出用户允许的默认实现。</p>
<h4 id="适配器模式的优点"><a href="#适配器模式的优点" class="headerlink" title="适配器模式的优点"></a>适配器模式的优点</h4><ul>
<li>目标和被适配者是完全解耦的关系。</li>
<li>适配器模式满足“开-闭原则”。当添加一个实现adapter接口的新类时，不必修改adapter，adapter就能对这个新类的实例进行适配。</li>
</ul>
<hr>
<h4 id="适配器模式的使用场景"><a href="#适配器模式的使用场景" class="headerlink" title="适配器模式的使用场景"></a>适配器模式的使用场景</h4><h2 id="一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。"><a href="#一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。" class="headerlink" title=" 一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。"></a> 一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。</h2><h5 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h5><h6 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h6><pre><code>public interface ThreeElectricOutlet {
public abstract void connectElectricCurrent();
}
</code></pre><h6 id="被适配者："><a href="#被适配者：" class="headerlink" title="被适配者："></a>被适配者：</h6><pre><code>public interface TwoElectricOutlet {

public abstract void connectElectricCurrent();

}
</code></pre><h6 id="适配器："><a href="#适配器：" class="headerlink" title="适配器："></a>适配器：</h6><pre><code>public class TreeElectricAdapter implements ThreeElectricOutlet {

TwoElectricOutlet outlet;


public TreeElectricAdapter(TwoElectricOutlet outlet) {
    super();
    this.outlet = outlet;
}


@Override
public void connectElectricCurrent() {
    outlet.connectElectricCurrent();
}

}
</code></pre><h6 id="模式使用："><a href="#模式使用：" class="headerlink" title="模式使用："></a>模式使用：</h6><pre><code>public class Application {
        public static void main(String[] args) {
            ThreeElectricOutlet outlet;
            Wash w=new Wash();
            outlet=w;
            System.out.println(&quot;使用三相插座：&quot;);
            outlet.connectElectricCurrent();
            TV t=new TV();
            TreeElectricAdapter adapter=new TreeElectricAdapter(t);
            outlet=adapter;
            System.out.println(&quot;使用三相插座&quot;);
            outlet.connectElectricCurrent();
        }
}
class Wash implements ThreeElectricOutlet{
String name;
Wash(){
    name=&quot;黄河洗衣机&quot;;
}


public Wash(String s) {
        name=s;
}


@Override
public void connectElectricCurrent() {
        turnOn();
}


public void turnOn() {
    System.out.println(name+&quot;starting.....&quot;);
}
}
class TV implements TwoElectricOutlet{
String name;
TV(){
    name=&quot;长江电视&quot;;

}
public TV(String s) {
    name = s;
}


@Override
public void connectElectricCurrent() {
        turnOn();
}
public void turnOn() {
    System.out.println(name+&quot;开始播放节目&quot;);
}


} 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;适配器模式详解&quot;&gt;&lt;a href=&quot;#适配器模式详解&quot; class=&quot;headerlink&quot; title=&quot;适配器模式详解&quot;&gt;&lt;/a&gt;适配器模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>外观模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/外观模式详解/</id>
    <published>2017-01-22T13:41:27.000Z</published>
    <updated>2017-01-22T13:51:52.999Z</updated>
    
    <content type="html"><![CDATA[<h3 id="外观模式详解"><a href="#外观模式详解" class="headerlink" title="外观模式详解"></a>外观模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。"><a href="#定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。" class="headerlink" title="定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。"></a>定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</h3><hr>
<h3 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h3><p>外观模式的结构中包括两种角色：</p>
<ul>
<li>子系统：子系统是若干个类的集合，这些类的实例协同合作作为用户提供所需要的功能，子系统中任何类都不包括外观类的实例引用。</li>
<li>外观：外观是一个类，该类包含子系统中全部或部分类的实例引用，当用户想要和子系统中的若干类的实例打交道时，可以代替地和子系统的外观类的实例打交道。</li>
</ul>
<hr>
<h3 id="外观模式的优点"><a href="#外观模式的优点" class="headerlink" title="外观模式的优点"></a>外观模式的优点</h3><ul>
<li>使客户和子系统中的类无耦合，并且使子系统使用起来更加方便。</li>
<li>外观只是提供了一个更加简洁的界面，并不影响用户直接使用子系统中的类。</li>
<li>子系统中任何类对其方法的内容进行修改，不影响外观类的代码。</li>
</ul>
<hr>
<h3 id="使用外观模式的情景"><a href="#使用外观模式的情景" class="headerlink" title="使用外观模式的情景"></a>使用外观模式的情景</h3><ul>
<li>对于一个复杂的子系统，需要为用户提供一个单的交互操作。</li>
<li>不希望客户代码和子系统中的类有耦合，以便提高子系统的独立性和可移植性。</li>
<li>当整个系统需要构建一个层次结构的子系统，不希望这些子系统相互直接的交互。</li>
</ul>
<hr>
<h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><h5 id="子系统："><a href="#子系统：" class="headerlink" title="子系统："></a>子系统：</h5><pre><code>import java.io.BufferedReader;
import java.io.FileReader;

public class ReadFile { 
    public  String readFileContent(String fileName){
        StringBuffer str=new StringBuffer();
        try {
            FileReader inOne=new FileReader(fileName);
            BufferedReader inTwo=new BufferedReader(inOne);
            String s=null;
            while((s=inTwo.readLine())!=null){
                str.append(s);
                str.append(&quot;\n&quot;);
            }
            inOne.close();
            inTwo.close();
        } catch (Exception e) {
        }
        return new String(str);

    }
}
import java.util.regex.Matcher;
java.util.regex.Pattern;

public class AnalyzeInformation {
public String getSavedContent(String content,String deleteContent){
    Pattern p;
    Matcher m;
    p=Pattern.compile(deleteContent);
    m=p.matcher(content);
    String savedContent=m.replaceAll(&quot;&quot;);
    return savedContent;

}

}
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.StringReader;

public class WriteFile {

public void writeToFile(String fileName,String content){
    StringBuffer str=new StringBuffer();
    try {
        StringReader inOne=new StringReader(content);
        BufferedReader inTwo=new BufferedReader(inOne);
        FileWriter outOne=new FileWriter(fileName);
        BufferedWriter outTwo=new BufferedWriter(outOne);
        String s=null;
        while((s=inTwo.readLine())!=null){
            outTwo.write(s);
            outTwo.newLine();
            outTwo.flush();
        }
        inOne.close();
        inTwo.close();
        outOne.close();
        outTwo.close();
    } catch (Exception e) {
        // TODO: handle exception
    }


}

}
</code></pre><h5 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h5><pre><code>public class ReadAndWirteFacade {
private ReadFile readFile;
private WriteFile writeFile;
private AnalyzeInformation analyzeInformation;
public ReadAndWirteFacade() {
    readFile=new ReadFile();
    analyzeInformation=new AnalyzeInformation();
    writeFile=new WriteFile();
}
public void doOption(String readFileName,String delContent,String savedFileName){
    String content=readFile.readFileContent(readFileName);
    System.out.println(&quot;读取文件&quot;+readFileName+&quot;的内容&quot;);
    System.out.println(content);
    String savedContent=analyzeInformation.getSavedContent(content, delContent);
    writeFile.writeToFile(savedFileName, savedContent);
    System.out.println(&quot;保存到文件&quot;+savedContent+&quot;中的内容&quot;);
    System.out.println(savedContent);

}

}
</code></pre><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><pre><code>public class Application {
    public static void main(String[] args) {
        ReadAndWirteFacade clientFacade;
        clientFacade=new ReadAndWirteFacade();
        String readFileName=&quot;index.html&quot;;
        String delConten=&quot;&lt;[^&gt;]*&gt;&quot;;
        String savedFileName=&quot;save.txt&quot;;
        clientFacade.doOption(readFileName, delConten, savedFileName);
public class Application {
    public static void main(String[] args) {
        ReadAndWirteFacade clientFacade;
        clientFacade=new ReadAndWirteFacade();
        String readFileName=&quot;index.html&quot;;
        String delConten=&quot;&lt;[^&gt;]*&gt;&quot;;
        String savedFileName=&quot;save.txt&quot;;
        clientFacade.doOption(readFileName, delConten, savedFileName);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;外观模式详解&quot;&gt;&lt;a href=&quot;#外观模式详解&quot; class=&quot;headerlink&quot; title=&quot;外观模式详解&quot;&gt;&lt;/a&gt;外观模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/责任链模式详解/</id>
    <published>2017-01-22T13:39:35.000Z</published>
    <updated>2017-01-22T13:51:41.605Z</updated>
    
    <content type="html"><![CDATA[<h3 id="责任链模式详解"><a href="#责任链模式详解" class="headerlink" title="责任链模式详解"></a>责任链模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><h4 id="定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。"><a href="#定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。" class="headerlink" title="定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。"></a>定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>责任链模式的结构中包括两种角色：</p>
<ul>
<li>处理者：处理者是一个接口，负责规定具体处理者处理用户请求的方法以及具体处理者设置后继对象的方法。</li>
<li><p>具体处理者：具体处理者是实现处理者接口的类的实例。具体处理者通过调用处理者接口规定的方法处理用户的请求，既在接到用户的请求后，处理者将调用接口规定的方法，在执行该方法的过程中，如果发现能处理用户的请求，就处理有关数据，否则就反馈无法处理的信息给用户，然后将用户的请求传递给自己的后继对象。</p>
<h4 id="责任链模式的优点"><a href="#责任链模式的优点" class="headerlink" title="责任链模式的优点"></a>责任链模式的优点</h4></li>
<li><p>责任链中的对象只和自己的后继是低耦合关系，和其他对象毫无关联，这使得编写处理者对象以及创建责任链变得非常容易。</p>
</li>
<li>当在处理者中分配职责时，责任链给应用程序更多的灵活性。</li>
</ul>
<hr>
<h4 id="责任链的适用模式和情景"><a href="#责任链的适用模式和情景" class="headerlink" title="责任链的适用模式和情景"></a>责任链的适用模式和情景</h4><ul>
<li>有许多对象可以处理用户的请求，希望程序在运行期间自动确定处理用户的那个对象。</li>
<li>希望用户不必明确指定接收者的情况下，向多个接收者的一个提交请求。</li>
<li>程序希望动态制定可处理用户请求的对象集合。</li>
</ul>
<hr>
<h5 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h5><h6 id="处理者："><a href="#处理者：" class="headerlink" title="处理者："></a>处理者：</h6><pre><code>public interface Handler {
public abstract void computerMultiply(String number);
public abstract void setNextHandler(Handler handler);
}
</code></pre><h6 id="具体处理者："><a href="#具体处理者：" class="headerlink" title="具体处理者："></a>具体处理者：</h6><pre><code>public class UseInt implements Handler{
private Handler handler;
private int result=1;
@Override
public void computerMultiply(String number) {
        try {
            int n=Integer.parseInt(number);
            int i=1;
            while(i&lt;=n){
                result=result*i;
                if(result&lt;=0){
                    System.out.println(&quot;超出我的能力范围&quot;);
                    handler.computerMultiply(number);
                    return;
                }
                i++;
            }
            System.out.println(number+&quot;的阶乘:&quot;+result);
        } catch (Exception e) {
            // TODO: handle exception
        }
}
@Override
public void setNextHandler(Handler handler) {
        this.handler=handler;
}
}

public class UseLong implements Handler {
private Handler handler;
private long result=1;

@Override
public void computerMultiply(String number) {
        try {
            long n=Long.parseLong(number);
            long i=1;
            while(i&lt;=n){
                result=result*i;
                if(result&lt;=0){
                    System.out.println(&quot;超出能力范围,,,&quot;);
                    handler.computerMultiply(number);
                    return;
                }
                i++;
            }
            System.out.println(number+&quot;的阶乘&quot;+result);
        } catch (Exception e) {
            // TODO: handle exception
        }
}
@Override
public void setNextHandler(Handler handler) {
        this.handler=handler;
}
}

import java.math.BigInteger;

public class UseBigInteger implements Handler{
private Handler handler;
private BigInteger result=new BigInteger(&quot;1&quot;);
@Override
public void computerMultiply(String number) {
        try {
            BigInteger n=new BigInteger(number);
            BigInteger ONE=new BigInteger(&quot;1&quot;);
            BigInteger i=ONE;
            while(i.compareTo(n)&lt;=0){
                result=result.multiply(i);
                i=i.add(ONE);
            }
            System.out.println(number+&quot;的阶乘&quot;+result);
        } catch (Exception e) {
            // TODO: handle exception
        }
}
@Override
public void setNextHandler(Handler handler) {
        this.handler=handler;
}
}
</code></pre><h6 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h6><pre><code>public class Application {

        private Handler useInt, useLong, useBig;
        public void createChain(){
            useInt=new UseInt();
            useLong=new UseLong();
            useBig=new UseBigInteger();
            useInt.setNextHandler(useLong);
            useLong.setNextHandler(useBig);
        }
        public void responseClient(String number){
            useInt.computerMultiply(number);
        }
        public static void main(String[] args) {
            Application application=new Application();
            application.createChain();
            application.responseClient(&quot;32&quot;);
        }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;责任链模式详解&quot;&gt;&lt;a href=&quot;#责任链模式详解&quot; class=&quot;headerlink&quot; title=&quot;责任链模式详解&quot;&gt;&lt;/a&gt;责任链模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单子模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E5%8D%95%E5%AD%90%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/单子模式详解/</id>
    <published>2017-01-22T13:38:44.000Z</published>
    <updated>2017-01-22T13:51:36.239Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单子模式详解"><a href="#单子模式详解" class="headerlink" title="单子模式详解"></a>单子模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h2 id="定义：-保证一个类只有一个实例，并提供一个访问它的全局访问点。"><a href="#定义：-保证一个类只有一个实例，并提供一个访问它的全局访问点。" class="headerlink" title="定义： 保证一个类只有一个实例，并提供一个访问它的全局访问点。"></a>定义： 保证一个类只有一个实例，并提供一个访问它的全局访问点。</h2><h3 id="单子模式的优点"><a href="#单子模式的优点" class="headerlink" title="单子模式的优点"></a>单子模式的优点</h3><h2 id="单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。"><a href="#单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。" class="headerlink" title="单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。"></a>单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。</h2><h3 id="单子模式的使用场景"><a href="#单子模式的使用场景" class="headerlink" title="单子模式的使用场景"></a>单子模式的使用场景</h3><p>当系统需要某个类只能有一个实例。</p>
<h3 id="下面代码实现了两种经典单子模式和线程安全的单子模式"><a href="#下面代码实现了两种经典单子模式和线程安全的单子模式" class="headerlink" title="下面代码实现了两种经典单子模式和线程安全的单子模式"></a>下面代码实现了两种经典单子模式和线程安全的单子模式</h3><hr>
<h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><pre><code>public class Singleton {


private Singleton() {}  
private static Singleton single=null;  
//静态工厂方法   
public static Singleton getInstance() {  
     if (single == null) {    
         single = new Singleton();  
     }    
    return single;  
}  
</code></pre><p>   }</p>
<h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><pre><code>public class Singleton1 {


   private Singleton1() {}  
    private static final Singleton1 single = new Singleton1();  
    //静态工厂方法   
    public static Singleton1 getInstance() {  
        return single;  
    } 
}
</code></pre><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><pre><code>public class TestSingleton {  
String name = null;  

    private TestSingleton() {  
}  

private static volatile TestSingleton instance = null;  

public static TestSingleton getInstance() {  
       if (instance == null) {    
         synchronized (TestSingleton.class) {    
            if (instance == null) {    
               instance = new TestSingleton();   
            }    
         }    
       }   
       return instance;  
}  

public String getName() {  
    return name;  
}  

public void setName(String name) {  
    this.name = name;  
}  

public void printInfo() {  
    System.out.println(&quot;the name is &quot; + name);  
}  

} 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单子模式详解&quot;&gt;&lt;a href=&quot;#单子模式详解&quot; class=&quot;headerlink&quot; title=&quot;单子模式详解&quot;&gt;&lt;/a&gt;单子模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/迭代器详解/</id>
    <published>2017-01-22T13:38:27.000Z</published>
    <updated>2017-01-22T13:51:30.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器模式详解"><a href="#迭代器模式详解" class="headerlink" title="迭代器模式详解"></a>迭代器模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。"><a href="#定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。" class="headerlink" title="定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。"></a>定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</h3><hr>
<h3 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h3><p>迭代器模式的结构中包括四种角色：</p>
<ul>
<li>集合：一个接口，规定了具体集合需要实现的操作。</li>
<li>具有集合：具体集合是实现集合接口的类的实例，具体集合按着一定结构存储对象。具体集合应该当有一个方法，该方法返回一个针对该集合的具体迭代器。</li>
<li>迭代器：一个接口，规定了遍历具体集合的方法。</li>
<li>具体迭代器实现迭代器接口的类的实例。具体迭代器在实现迭代器接口所规定的遍历集合的方法时，要保证方法的首次调用将按着集合的数据结构找到该集合中的一个对象，立刻根据该集合的存储结构得到待遍历的后继对象的引用，并保证依次调用的方法可以遍历集合。</li>
</ul>
<hr>
<h3 id="迭代器模式的优点"><a href="#迭代器模式的优点" class="headerlink" title="迭代器模式的优点"></a>迭代器模式的优点</h3><ul>
<li>用户使用迭代器访问集合中的对象，而不需要知道这些对象在集合中是如何表示及存储的。</li>
<li>用户可以同时使用多个迭代器遍历一个集合。</li>
</ul>
<hr>
<h3 id="适合使用迭代器模式的情景"><a href="#适合使用迭代器模式的情景" class="headerlink" title="适合使用迭代器模式的情景"></a>适合使用迭代器模式的情景</h3><ul>
<li>让用户访问一个集合中是对象，但不想暴露对象在集合中的存储结构。</li>
<li>希望对遍历不同的集合提供一个统一的接口。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><pre><code>import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.TreeSet;

public class UseSet {
LinkedList&lt;Student&gt;list;
Hashtable&lt;String, Student&gt;table;
TreeSet&lt;Student&gt;tree;
UseSet(){
    list=new LinkedList&lt;Student&gt;();
    tree=new TreeSet&lt;Student&gt;();
    table=new Hashtable&lt;String,Student&gt;();
}
public void addStudent(Student stu){
    list.add(stu);
    update();

}
public  void lookStudent(String n) {
        Student stu=table.get(n);
        String number=stu.getNumber();
        String name=stu.getName();
        double score=stu.getSorce();
        System.out.println(&quot;学号：&quot;+number+&quot;姓名:&quot;+name+&quot;分数：&quot;+score);

}
public void printStudentByScore(){
    Iterator&lt;Student&gt;iterator=tree.iterator();
    while(iterator.hasNext()){
        Student stu=iterator.next();
        String number=stu.getNumber();
        String name=stu.getName();
        double sorce=stu.getSorce();
        System.out.println(&quot;学号：&quot;+number+&quot;姓名：&quot;+name+&quot;分数：&quot;+sorce);
    }
}
private void update() {
        tree.clear();
        Iterator&lt;Student&gt;iterator=list.iterator();
        while(iterator.hasNext()){
            Student stu=iterator.next();
            String number=stu.getNumber();
            table.put(number, stu);
            tree.add(stu);
        }
}
</code></pre><p>   }</p>
<p>   public class Student implements Comparable{<br>    String number,name;<br>    double sorce=0;<br>    private int x=10;</p>
<pre><code>public Student() {
    super();
    // TODO Auto-generated constructor stub
}

public Student(String number, String name, double sorce) {
    super();
    this.number = number;
    this.name = name;
    this.sorce = sorce;
}

@Override
public int compareTo(Object o) {
    Student st=(Student)o;
    if(Math.abs(this.sorce-st.sorce)&lt;=1/10000)
         return 1;
    return (int)(1000*(this.sorce-st.sorce));
}

public String getNumber() {
    return number;
}

public String getName() {
    return name;
}

public double getSorce() {
    return sorce;
}
</code></pre><p>   }</p>
<pre><code>public class Application {
public static void main(String[] args) {
UseSet useSet=new UseSet();
useSet.addStudent(new Student(&quot;001&quot;, &quot;cc&quot;, 76.9));
String n=&quot;001&quot;;
System.out.println(&quot;查找学号为：&quot;+n+&quot;的学生：&quot;);
useSet.lookStudent(n);
System.out.println(&quot;将学生按成绩排列:&quot;);
useSet.printStudentByScore();
}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;迭代器模式详解&quot;&gt;&lt;a href=&quot;#迭代器模式详解&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式详解&quot;&gt;&lt;/a&gt;迭代器模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/中介者模式详解/</id>
    <published>2017-01-22T13:38:12.000Z</published>
    <updated>2017-01-22T13:51:24.415Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中介者模式详解"><a href="#中介者模式详解" class="headerlink" title="中介者模式详解"></a>中介者模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。"><a href="#定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。" class="headerlink" title="定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。"></a>定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。</h3><hr>
<h3 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h3><p>中介者模式的结构中包含四种角色：</p>
<ul>
<li>中介者：中介者是一个接口，该接口定义了用于同时对象之间进行通信的方法。</li>
<li>具体中介者：具体中介者是实现中介者接口的类。具体中介者需要包含所有具体同事的引用，并通过实现中介者接口中的方法来满足具体同事之间的通信请求。</li>
<li>同事：一个接口，规定了具体同事需要实现的方法。</li>
<li>具体同事：实现同事接口的类，具体同事需要包含具体中介者的引用，一个具体同事需要和其他同事交互时，只需要将自己的请求通知给它所包含的具体中介者即可</li>
</ul>
<hr>
<h3 id="中介者模式的优点"><a href="#中介者模式的优点" class="headerlink" title="中介者模式的优点"></a>中介者模式的优点</h3><ul>
<li>可以避免许多的对象为了之间的通信而相互先是引用，否则，不仅系统难于维护，而且也使其他系统难以复用这些对象。</li>
<li>可以通过中介者将原本分布于多个对象之间的交互行为集中在一起。当这些对象之间需要改变之间的通信行为时，只需使用一个具体中介者即可，不必修改各个具体同事的代码，既这些同事可被重用。</li>
<li>具体中介者使得各个具体同事之间是如何交互的细节，是系统比较清楚地知道整个系统中的同事是如何交互的。</li>
<li>当一些对象想相互通信，但又无法相互包含对方的引用，那么使用中介者模式就可以使这些对象相互通信。</li>
</ul>
<hr>
<h3 id="中介者模式的适用场景"><a href="#中介者模式的适用场景" class="headerlink" title="中介者模式的适用场景"></a>中介者模式的适用场景</h3><ul>
<li>许多对象以复杂的方式交互，所导致的依赖关系时系统难以理解和维护。</li>
<li>一个对象引用其他很多对象，导致难以复用的情况。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h4 id="同事："><a href="#同事：" class="headerlink" title="同事："></a>同事：</h4><pre><code>public interface Colleage {
public void giveMess(String[] mess);
public void receiverMess(String mess);
public void setName(String name);
public String getName();
}
</code></pre><h4 id="具体中介者："><a href="#具体中介者：" class="headerlink" title="具体中介者："></a>具体中介者：</h4><pre><code>public class ConcreteMediator {
ColleagueA colleageA;
ColleageB colleageB;
ColleageC colleageC;
public void registerColleagueA(ColleagueA colleagueA)
{
    this.colleageA=colleagueA;
}
public void registerColleagueB(ColleageB colleagueB)
{
    this.colleageB=colleagueB;
}
public void registerColleagueC(ColleageC colleagueC)
{
    this.colleageC=colleagueC;
}

public void deliverMess(Colleage colleage,String []mess){
    if(colleage==colleageA){
        if(mess.length&gt;=2){
            colleageB.receiverMess(colleage.getName()+mess[0]);
            colleageC.receiverMess(colleage.getName()+mess[1]);
        }else if(colleage==colleageB){
            if(mess.length&gt;=2){
                colleageA.receiverMess(colleage.getName()+mess[0]);
                colleageC.receiverMess(colleage.getName()+mess[1]);
            }

        }else if(colleage==colleageC){
            if(mess.length&gt;=2){
                colleageA.receiverMess(colleage.getName()+mess[0]);
                colleageB.receiverMess(colleage.getName()+mess[1]);
            }
        }
    }
}


}
</code></pre><h4 id="具体同事："><a href="#具体同事：" class="headerlink" title="具体同事："></a>具体同事：</h4><pre><code>public class ColleagueA implements Colleage{

ConcreteMediator mediator;//中介者
String name;

public ColleagueA(ConcreteMediator mediator) {
    this.mediator = mediator;
    mediator.registerColleagueA(this);
}

@Override
public void giveMess(String[] mess) {
    mediator.deliverMess(this, mess);
}

@Override
public void receiverMess(String mess) {
        System.out.println(name+&quot;收到信息&quot;);
        System.out.println(&quot;\t&quot;+mess);
}

@Override
public void setName(String name) {
    this.name=name;
}

@Override
public String getName() {
    return name;
}

}


public class ColleageB implements Colleage{

    ConcreteMediator mediator;
    String name;


public ColleageB(ConcreteMediator mediator) {
     this.mediator = mediator;
     mediator.registerColleagueB(this);
}


public void receiverMess(String mess) {
        System.out.println(name+&quot;收到信息&quot;);
        System.out.println(&quot;\t&quot;+mess);
}


@Override
public void giveMess(String[] mess) {
    mediator.deliverMess(this, mess);
}


@Override
public void setName(String name) {
    this.name=name;

}


@Override
public String getName() {
    return name;
}

}

public class ColleageC implements Colleage{
ConcreteMediator mediator;
String name;


public ColleageC(ConcreteMediator mediator) {
    this.mediator = mediator;
    mediator.registerColleagueC(this);
}

public void receiverMess(String mess) {
        System.out.println(name+&quot;收到的信息&quot;);
        System.out.println(&quot;\t&quot;+mess);
}

@Override
public void giveMess(String[] mess) {
    mediator.deliverMess(this, mess);
}

@Override
public void setName(String name) {
    this.name=name;
}

@Override
public String getName() {
    // TODO Auto-generated method stub
    return null;
}

}
</code></pre><h4 id="模式的使用："><a href="#模式的使用：" class="headerlink" title="模式的使用："></a>模式的使用：</h4><pre><code>public class Application {


public static void main(String[] args) {

    ConcreteMediator mediator=new ConcreteMediator();

    ColleagueA colleagA=new ColleagueA(mediator);
    ColleageB colleageB=new ColleageB(mediator);
    ColleageC colleageC=new ColleageC(mediator);
    colleagA.setName(&quot;aA&quot;);

    colleageB.setName(&quot;aB&quot;);
    colleageC.setName(&quot;ac&quot;);
    String [] messA={&quot;aa100，aa200&quot;};
    colleagA.giveMess(messA);

    String [] messB={&quot;aa10&quot;,&quot;aa20&quot;};
    colleageB.giveMess(messB);
    String [] messC={&quot;aa1&quot;,&quot;aa2&quot;};
    colleageC.giveMess(messC);
}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;中介者模式详解&quot;&gt;&lt;a href=&quot;#中介者模式详解&quot; class=&quot;headerlink&quot; title=&quot;中介者模式详解&quot;&gt;&lt;/a&gt;中介者模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/工厂方法模式详解/</id>
    <published>2017-01-22T13:37:37.000Z</published>
    <updated>2017-01-22T14:11:16.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工厂方法详解"><a href="#工厂方法详解" class="headerlink" title="工厂方法详解"></a>工厂方法详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。"><a href="#定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。" class="headerlink" title="定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。"></a>定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</h4><hr>
<h4 id="模式的接口和使用"><a href="#模式的接口和使用" class="headerlink" title="模式的接口和使用"></a>模式的接口和使用</h4><p>工厂方法模式的结构中包括四种角色：</p>
<ul>
<li>抽象产品：抽象类或者接口，负责定义具体产品必须实现的方法。</li>
<li>具体产品：具体产品是一个类，如果product是一个抽象类，那么具体产品是product的子类；如果product是一个接口，那么具体产品是实现product接口的类。</li>
<li>构造者：一个接口或抽象类。构造者负责定义一个称作工厂方法的抽象方法，该方法返回具体产品类的实例。</li>
<li>具体构造者：如果构造者是抽象类，具体构造者是构造者的子类如果构造者是接口，具体构造者是实现构造者的类。具体构造者重写工厂方法使该方法返回<br>具体产品的实例。 </li>
</ul>
<hr>
<h4 id="工厂方法模式的优点"><a href="#工厂方法模式的优点" class="headerlink" title="工厂方法模式的优点"></a>工厂方法模式的优点</h4><ul>
<li>使用工厂方法可让用户的代码和某个特定的子类的代码解耦。</li>
<li>工厂方法使用户不必知道它所使用的对象是怎样被创建的，只需知道该对象有哪些方法即可。</li>
</ul>
<h4 id="适合使用工厂方法模式的情景"><a href="#适合使用工厂方法模式的情景" class="headerlink" title="适合使用工厂方法模式的情景"></a>适合使用工厂方法模式的情景</h4><ul>
<li>用户需要一个类的子类的实例，但不希望与该类的子类形成耦合。</li>
<li>用户需要一个类的子类的实例，但用户不知道该类有哪些子类可用。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h5 id="抽象代码"><a href="#抽象代码" class="headerlink" title="抽象代码"></a>抽象代码</h5><pre><code>public abstract class PenCore {
String color;
public abstract void wirteWord(String s);
}
</code></pre><h5 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h5><pre><code>public class RedPencore extends PenCore {
RedPencore(){
    color=&quot;红色&quot;;
}


@Override
public void wirteWord(String s) {
        System.out.println(&quot;写出&quot;+color+&quot;的字:&quot;+s);
}


}

public class BluePenCore extends PenCore {
public BluePenCore() {
    color=&quot;蓝色&quot;;
}

@Override
public void wirteWord(String s) {
    System.out.println(&quot;写出&quot;+color+&quot;的字:&quot;+s);
}

}

public class BlackPenCore  extends PenCore{

public BlackPenCore() {
    color=&quot;黑色&quot;;
}

@Override
public void wirteWord(String s) {
    System.out.println(&quot;写出&quot;+color+&quot;的字：&quot;+s);
}

}
</code></pre><h5 id="构造者"><a href="#构造者" class="headerlink" title="构造者"></a>构造者</h5><pre><code>public abstract class BallPen {
public BallPen() {
    System.out.println(&quot;生产了一只装有&quot;+getPenCore().color+&quot;笔芯的圆珠笔&quot;);
}
public abstract PenCore getPenCore();

}
</code></pre><h5 id="具体构造者"><a href="#具体构造者" class="headerlink" title="具体构造者"></a>具体构造者</h5><pre><code>public class RedBallPen extends BallPen{


@Override
public PenCore getPenCore() {

    return new RedPencore();
}


}

public class BlueBalPen extends BallPen{

@Override
public PenCore getPenCore() {

    return new BluePenCore();
}

}

public class BlackBallPen extends BallPen{

@Override
public PenCore getPenCore() {
    return new BlackPenCore();
}

}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>public class Application {
    public static void main(String[] args) {
        PenCore penCore;
        BallPen ballPen=new BlueBalPen();
        penCore=ballPen.getPenCore();
        penCore.wirteWord(&quot;hello  world&quot;);
        ballPen=new RedBallPen();
        penCore=ballPen.getPenCore();
        penCore.wirteWord(&quot;HOW  ARE  YOU&quot;);
        ballPen=new BlackBallPen();
        penCore=ballPen.getPenCore();
        penCore.wirteWord(&quot;OK&quot;);
    }
 }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工厂方法详解&quot;&gt;&lt;a href=&quot;#工厂方法详解&quot; class=&quot;headerlink&quot; title=&quot;工厂方法详解&quot;&gt;&lt;/a&gt;工厂方法详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰模式详解</title>
    <link href="http://www.craymc.com/2017/01/17/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/17/装饰模式详解/</id>
    <published>2017-01-17T14:19:36.000Z</published>
    <updated>2017-01-22T06:56:59.058Z</updated>
    
    <content type="html"><![CDATA[<h3 id="装饰模式详解"><a href="#装饰模式详解" class="headerlink" title="装饰模式详解"></a>装饰模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><h4 id="定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。"><a href="#定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。" class="headerlink" title="定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。"></a>定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。</h4><h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><ul>
<li>抽象组件：抽象组件是一个抽象类。抽象组件定义了“被装饰者”需要进行“装饰”的方法。</li>
<li>具体组件：具体组件是抽象组件的一个子类，具体组件的实例称作“被装饰者”。</li>
<li>装饰：装饰也是抽象组件的一个子类，但装饰还包含一个抽象组件声明的变量以保存“被装饰者”的引用。装饰可以是抽象类也可以是一个非抽象类，如果是非抽象类，那么该类的实例称作“装饰者”。</li>
<li>具体装饰： 具体装饰是装饰的一个非抽象类，具体装饰的实例称作“装饰者”。</li>
</ul>
<hr>
<a id="more"></a>
<h4 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h4><p>“具体组件”和“装饰”都是“抽象组件”的子类。因此，“抽象组件”声明的对象即可以存放“被装饰者”的引用也可以存放“装饰者”的引用。如果“抽象组件”声明对象存放“被装饰者”的引用，那么该对象就能调用“被装饰者”所实现“抽象组件”中的方法；如果“抽象组件”声明对象存放“装饰者”的引用，那么该对象就能调用“装饰者”所实现“抽象组件”中的方法。</p>
<hr>
<h4 id="装饰模式相对于继承机制的优势"><a href="#装饰模式相对于继承机制的优势" class="headerlink" title="装饰模式相对于继承机制的优势"></a>装饰模式相对于继承机制的优势</h4><p>通过继承可以改进对象的行为，对于某些简单的问题这样无所谓，但是如果考虑到系统扩展性，就应当遵循：<strong>少用继承，多用组合。</strong>就功能来说：<strong>装饰模式相比生产子类更加灵活</strong>。</p>
<h4 id="装饰模式的优点"><a href="#装饰模式的优点" class="headerlink" title="装饰模式的优点"></a>装饰模式的优点</h4><ul>
<li>被装饰者和装饰者是松耦合的关系。由于装饰仅仅依赖于抽象组件，因此具体装饰只知道他要装饰的对象是抽象组件某一个子类的实例，但不需要知道是那一个人具体子类。</li>
<li>装饰者模式满足“开-闭原则”。不必修改具体组件，就可以增加新的针对该具体组件的具体装饰。</li>
<li>可以使用多个装饰来装饰具体组件的实例。</li>
</ul>
<hr>
<h4 id="适合使用装饰模式的情景"><a href="#适合使用装饰模式的情景" class="headerlink" title="适合使用装饰模式的情景"></a>适合使用装饰模式的情景</h4><ul>
<li>程序希望动态地增强类非某个对象的功能，而又不影响到该类的其他对象。</li>
<li>采用继承来增强对象功能不利于系统的扩展和维护。</li>
</ul>
<hr>
<h5 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h5><h6 id="抽象组件："><a href="#抽象组件：" class="headerlink" title="抽象组件："></a>抽象组件：</h6><pre><code>import java.io.File;
import java.util.ArrayList;

public abstract class ReadWord {
public abstract ArrayList&lt;String&gt; readWord(File file);

}
</code></pre><h6 id="具体组件："><a href="#具体组件：" class="headerlink" title="具体组件："></a>具体组件：</h6><pre><code>import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;

public class ReadEnglishWord extends ReadWord{

@Override
public ArrayList&lt;String&gt; readWord(File file) {
    ArrayList&lt;String&gt; wordList=new ArrayList&lt;String&gt;();
    try {
        FileReader inOne=new FileReader(file);
        BufferedReader inTwo=new BufferedReader(inOne);
        String s=null;
        while((s=inTwo.readLine())!=null){
            wordList.add(s);
        }
        inTwo.close();
        inOne.close();
    } catch (Exception e) {
        System.out.println(e);
    }
    return null;
}

}
</code></pre><h6 id="装饰："><a href="#装饰：" class="headerlink" title="装饰："></a>装饰：</h6><pre><code>public abstract class Decorator extends ReadWord {
protected ReadWord reader;

public Decorator() {
    super();
    // TODO Auto-generated constructor stub
}

public Decorator(ReadWord reader) {
    super();
    this.reader = reader;
}
}
</code></pre><h6 id="具体装饰与相关文件："><a href="#具体装饰与相关文件：" class="headerlink" title="具体装饰与相关文件："></a>具体装饰与相关文件：</h6><pre><code>import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;

public class WordDecorator extends Decorator{
File decoratorFile;

public WordDecorator(ReadWord reader,File decoratorFile) {
    super(reader);
    this.decoratorFile = decoratorFile;

}
public ArrayList&lt;String&gt; readWord(File file){
    ArrayList&lt;String&gt; wordList=reader.readWord(file);
    try {
        FileReader inOne=new FileReader(decoratorFile);
        BufferedReader inTwo=new BufferedReader(inOne);
        String s=null;
        int m=0;
        while((s=inTwo.readLine())!=null){
            String word=wordList.get(m);
            word=word.concat(&quot;|&quot;+s);
            wordList.set(m, word);
            m++;
            if(m&gt;wordList.size())break;
        }
        inOne.close();
        inTwo.close();
    } catch (Exception e) {
        // TODO: handle exception
    }
    return wordList;


}


}
</code></pre><h6 id="应用程序："><a href="#应用程序：" class="headerlink" title="应用程序："></a>应用程序：</h6><pre><code>import java.io.File;
import java.util.ArrayList;

public class Application {

public static void main(String[] args) {
    ArrayList&lt;String&gt;wordList=new ArrayList&lt;String&gt;();
    ReadEnglishWord REW=new ReadEnglishWord();
    WordDecorator WD1=new WordDecorator(REW, new File(&quot;chinese.txt&quot;));
    ReadWord reader=WD1;
    wordList=reader.readWord(new File(&quot;word.txt&quot;));
    for (int i = 0; i &lt; wordList.size(); i++) {

        System.out.println(wordList.get(i));
    }
    WordDecorator WD2=new WordDecorator(WD1, new File(&quot;englishSentence.txt&quot;));
    reader=WD2;
    wordList=reader.readWord(new File(&quot;word.txt&quot;));
    for (int i = 0; i &lt; wordList.size(); i++) {
        System.out.println(wordList.get(i));
    }
}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;装饰模式详解&quot;&gt;&lt;a href=&quot;#装饰模式详解&quot; class=&quot;headerlink&quot; title=&quot;装饰模式详解&quot;&gt;&lt;/a&gt;装饰模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;h4 id=&quot;定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。&quot;&gt;&lt;a href=&quot;#定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。&quot; class=&quot;headerlink&quot; title=&quot;定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。&quot;&gt;&lt;/a&gt;定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。&lt;/h4&gt;&lt;h4 id=&quot;模式的结构与使用&quot;&gt;&lt;a href=&quot;#模式的结构与使用&quot; class=&quot;headerlink&quot; title=&quot;模式的结构与使用&quot;&gt;&lt;/a&gt;模式的结构与使用&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;抽象组件：抽象组件是一个抽象类。抽象组件定义了“被装饰者”需要进行“装饰”的方法。&lt;/li&gt;
&lt;li&gt;具体组件：具体组件是抽象组件的一个子类，具体组件的实例称作“被装饰者”。&lt;/li&gt;
&lt;li&gt;装饰：装饰也是抽象组件的一个子类，但装饰还包含一个抽象组件声明的变量以保存“被装饰者”的引用。装饰可以是抽象类也可以是一个非抽象类，如果是非抽象类，那么该类的实例称作“装饰者”。&lt;/li&gt;
&lt;li&gt;具体装饰： 具体装饰是装饰的一个非抽象类，具体装饰的实例称作“装饰者”。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式详解</title>
    <link href="http://www.craymc.com/2017/01/17/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/17/策略模式详解/</id>
    <published>2017-01-17T14:19:03.000Z</published>
    <updated>2017-01-22T06:57:09.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="策略模式详解"><a href="#策略模式详解" class="headerlink" title="策略模式详解"></a>策略模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：定义一系列算法，把他们一个个封装起来，并且使得他们可以相互替换。本模式使得算法可独立使用它的客户而变化。"><a href="#定义：定义一系列算法，把他们一个个封装起来，并且使得他们可以相互替换。本模式使得算法可独立使用它的客户而变化。" class="headerlink" title="定义：定义一系列算法，把他们一个个封装起来，并且使得他们可以相互替换。本模式使得算法可独立使用它的客户而变化。"></a>定义：定义一系列算法，把他们一个个封装起来，并且使得他们可以相互替换。本模式使得算法可独立使用它的客户而变化。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>策略模式的结构包括三种角色：</p>
<ul>
<li>策略：策略是一个接口，该接口定义若干个算法标识，既定义了若干个抽象方法。</li>
<li>具体策略：具体策略是实现策略接口的类。具体策略实现策略接口所定义的抽象方法，既给出算法标识的具体算法。</li>
<li>上下文：上下文是依赖于策略接口的类，既上下文包含有策略声明的变量。上下文中提供一个方法，该方法委托策略变量调用策略所实现的策略接口中的方法。</li>
</ul>
<hr>
<a id="more"></a>
<h4 id="策略模式的优点"><a href="#策略模式的优点" class="headerlink" title="策略模式的优点"></a>策略模式的优点</h4><ul>
<li>上下文和具体策略是松耦关系。</li>
<li>策略模式满足“开-闭原则”。当增加新策略时，不需要修改上下文类的代码，上下文就可以引用新的具体策略的实例。</li>
</ul>
<hr>
<h4 id="策略模式的适用场景"><a href="#策略模式的适用场景" class="headerlink" title="策略模式的适用场景"></a>策略模式的适用场景</h4><ul>
<li>一个类定义了多种行为，并且这些行为在这个类的方法中以多个条件语句的形式出现，那么可以使用策略模式避免在类中使用大量的条件语句。</li>
<li>程序不希望暴露复杂的，与算法相关的数据结构，那么可以使用策略模式封装算法。</li>
<li>需要使用一个算法的不同变体。</li>
</ul>
<hr>
<h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><h5 id="策略："><a href="#策略：" class="headerlink" title="策略："></a>策略：</h5><pre><code>public interface ComputableStrategy {
public abstract double computeSocre(double []a);

}
</code></pre><h5 id="具体策略："><a href="#具体策略：" class="headerlink" title="具体策略："></a>具体策略：</h5><pre><code>public class StrategyOne implements ComputableStrategy {

@Override
public double computeSocre(double[] a) {
        double score=0,sum=0;
        for (int i = 0; i &lt; a.length; i++) {
            sum=sum+a[i];
        }
        score=sum/a.length;
    return score;
}

}

public class StrategyTwo implements ComputableStrategy {

@Override
public double computeSocre(double[] a) {
    double score=0,multi=1;
    int n=a.length;
    for (int i = 0; i &lt; a.length; i++) {
        multi=multi*a[i];
    }
    score=Math.pow(multi, 1.0/n);

    return score;
}

}

import java.util.Arrays;

public class StrategyThree implements ComputableStrategy{

@Override
public double computeSocre(double[] a) {
    if(a.length&lt;=2){
        return 0;
    }
    double score=0,sum=0;
    Arrays.sort(a);
    for (int i = 0; i &lt; a.length-1; i++) {
        sum=sum+a[i];

    }
    score=sum/(a.length-2);
    return score;
}

}
</code></pre><h5 id="上下文："><a href="#上下文：" class="headerlink" title="上下文："></a>上下文：</h5><pre><code>public class GymnasticsGame {
ComputableStrategy strategy;
public void setStrategy(ComputableStrategy strategy){
 this.strategy=strategy;

}
public double getPersonScore(double []a){
if(strategy!=null)
{
    return strategy.computeSocre(a);
}else{
    return 0;
}    

}

}
</code></pre><h5 id="模式使用："><a href="#模式使用：" class="headerlink" title="模式使用："></a>模式使用：</h5><pre><code>public class Application {
    public static void main(String[] args) {
        GymnasticsGame game=new GymnasticsGame();
        game.setStrategy(new StrategyOne());
        Person zhang=new Person();
        zhang.setName(&quot;张三&quot;);
        double []a={9.12,9.25,8.87,9.89};
        Person li=new Person();
        li.setName(&quot;李四&quot;);
        double []b={9.12,9.25,8.87,9.89};
        zhang.setScore(game.getPersonScore(a));
        li.setScore(game.getPersonScore(b));
        System.out.println(&quot;使用算术平均值方案：&quot;);
        System.out.printf(&quot;最后得分：&quot;,zhang.getName(),zhang.getScore());




    }
}
class Person{

String name;
double score;
public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}
public double getScore() {
    return score;
}
public void setScore(double score) {
    this.score = score;
}


} 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;策略模式详解&quot;&gt;&lt;a href=&quot;#策略模式详解&quot; class=&quot;headerlink&quot; title=&quot;策略模式详解&quot;&gt;&lt;/a&gt;策略模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;hr&gt;
&lt;h4 id=&quot;定义：定义一系列算法，把他们一个个封装起来，并且使得他们可以相互替换。本模式使得算法可独立使用它的客户而变化。&quot;&gt;&lt;a href=&quot;#定义：定义一系列算法，把他们一个个封装起来，并且使得他们可以相互替换。本模式使得算法可独立使用它的客户而变化。&quot; class=&quot;headerlink&quot; title=&quot;定义：定义一系列算法，把他们一个个封装起来，并且使得他们可以相互替换。本模式使得算法可独立使用它的客户而变化。&quot;&gt;&lt;/a&gt;定义：定义一系列算法，把他们一个个封装起来，并且使得他们可以相互替换。本模式使得算法可独立使用它的客户而变化。&lt;/h4&gt;&lt;hr&gt;
&lt;h4 id=&quot;模式的结构与使用&quot;&gt;&lt;a href=&quot;#模式的结构与使用&quot; class=&quot;headerlink&quot; title=&quot;模式的结构与使用&quot;&gt;&lt;/a&gt;模式的结构与使用&lt;/h4&gt;&lt;p&gt;策略模式的结构包括三种角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;策略：策略是一个接口，该接口定义若干个算法标识，既定义了若干个抽象方法。&lt;/li&gt;
&lt;li&gt;具体策略：具体策略是实现策略接口的类。具体策略实现策略接口所定义的抽象方法，既给出算法标识的具体算法。&lt;/li&gt;
&lt;li&gt;上下文：上下文是依赖于策略接口的类，既上下文包含有策略声明的变量。上下文中提供一个方法，该方法委托策略变量调用策略所实现的策略接口中的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式详解</title>
    <link href="http://www.craymc.com/2017/01/16/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/16/观察者模式详解/</id>
    <published>2017-01-16T14:44:49.000Z</published>
    <updated>2017-01-22T06:56:39.395Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设计模式——观察者模式"><a href="#设计模式——观察者模式" class="headerlink" title="设计模式——观察者模式"></a>设计模式——观察者模式</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><h2 id="概念：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖他的对象都得到通知并被自动更新。"><a href="#概念：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖他的对象都得到通知并被自动更新。" class="headerlink" title="概念：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖他的对象都得到通知并被自动更新。"></a><strong>概念：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖他的对象都得到通知并被自动更新。</h2><h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>观察者模式的结构中包括四种角色：</p>
<ul>
<li>主题：主题是一个接口，该接口规定了具体主题需要实现的方法，比如，添加，删除观察者以及通知观察者更新数据的方法。</li>
<li>观察者：观察者是一个接口，该接口规定了具体观察者用来更新数据的方法。</li>
<li>具体主题：具体主题是实现主题接口类的一个实例，该实例包含有可以经常发生变化的数据。具体主题需要使用一个集合，存放观察者的引用，以便数据变化时通知具体观察者。</li>
<li>具体观察者：具体观察者是实现观察者接口类的一个实例。具体观察者包含有可以存放具体主题引用的主题接口变量，以便具体观察者让具体主题将自己的引用添加到具体主题的集合中，使自己成为他的观察者，或让这个具体主题将自己从具体主题的集合中删除，使自己不再是它的观察者。</li>
</ul>
<hr>
<a id="more"></a>
<h4 id="观察者模式中的“推”数据与“拉”数据"><a href="#观察者模式中的“推”数据与“拉”数据" class="headerlink" title="观察者模式中的“推”数据与“拉”数据"></a>观察者模式中的“推”数据与“拉”数据</h4><p><strong>1.推数据方式</strong><br>推数据方式是指具体主题将变化后的数据全部交给具体观察者，既将变化后的数据传递给具体观察者用于更新数据方法的参数。当具体主题认为具体观察者需要这些变换后的全部数据时往往采用推数据方式。<br><strong>2.拉数据方式</strong></p>
<h2 id="拉数据的方式是指具体主题不将变化后的数据交给具体观察者，而是提供了获得这些数据的方法，具体观察者在得到通知后，可以调用具体主题提供的方法得到数据（观察者自己把数据“拉”过来），但需要自己判断数据是否发生了变化。当具体主题不知道具体观察者是否需要这些变换后的数据时往往采用拉数据的方式。"><a href="#拉数据的方式是指具体主题不将变化后的数据交给具体观察者，而是提供了获得这些数据的方法，具体观察者在得到通知后，可以调用具体主题提供的方法得到数据（观察者自己把数据“拉”过来），但需要自己判断数据是否发生了变化。当具体主题不知道具体观察者是否需要这些变换后的数据时往往采用拉数据的方式。" class="headerlink" title="拉数据的方式是指具体主题不将变化后的数据交给具体观察者，而是提供了获得这些数据的方法，具体观察者在得到通知后，可以调用具体主题提供的方法得到数据（观察者自己把数据“拉”过来），但需要自己判断数据是否发生了变化。当具体主题不知道具体观察者是否需要这些变换后的数据时往往采用拉数据的方式。"></a>拉数据的方式是指具体主题不将变化后的数据交给具体观察者，而是提供了获得这些数据的方法，具体观察者在得到通知后，可以调用具体主题提供的方法得到数据（观察者自己把数据“拉”过来），但需要自己判断数据是否发生了变化。当具体主题不知道具体观察者是否需要这些变换后的数据时往往采用拉数据的方式。</h2><h4 id="观察者模式的优点"><a href="#观察者模式的优点" class="headerlink" title="观察者模式的优点"></a>观察者模式的优点</h4><ul>
<li>具体主题和具体观察者是松耦合的关系。由于主题接口仅仅依赖于观察者接口，因此具体主题只是知道他的观察者是实现观察者接口的某个实例，但不需要知道具体是哪个类。同样，由于观察者仅仅依赖于主题接口，因此具体观察者只是知道它依赖的主题是实现主题接口的某个类的实例，但不需要知道具体是哪个类。</li>
<li>观察者模式满足“开-闭原则”。主题接口仅仅依赖于观察者接口，这样，就可以让创建具体主题的类仅仅是依赖于观察者接口，因此，如果增加新的实现观察者接口的类，不必修改创建具体主题的类的代码。同样，创建观察者的类仅仅依赖于主题接口，如果增加新的实现主题接口的类，也不必修改创建具体观察者类的代码。</li>
</ul>
<hr>
<h4 id="观察者模式的使用场景"><a href="#观察者模式的使用场景" class="headerlink" title="观察者模式的使用场景"></a>观察者模式的使用场景</h4><ul>
<li>当一个对象的数据更新时需要通知其他对象，但这个对象又不希望和被通知的那些对象形成紧耦合。</li>
<li>当一个对象的数据更新时，这个对象需要让其他对象也各自更新自己的数据，但这个对象不知道具体有多少对象需要更新数据。</li>
</ul>
<hr>
<h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><h6 id="主题："><a href="#主题：" class="headerlink" title="主题："></a>主题：</h6><pre><code>public interface Subject {
public void addObserver(Observer o);
public void deletObserver(Observer o);
public void notifyObserver();
}
</code></pre><h6 id="观察者："><a href="#观察者：" class="headerlink" title="观察者："></a>观察者：</h6><pre><code>public interface Observer {
    public void update(Subject subject);
}
</code></pre><h6 id="具体主题："><a href="#具体主题：" class="headerlink" title="具体主题："></a>具体主题：</h6><pre><code>import java.util.ArrayList;

public class WeatherStation implements Subject {
String foreastTime ,forecastMess;
int maxTemperature,minTemperature;
ArrayList&lt;Observer&gt;personList;
WeatherStation(){
    personList=new ArrayList&lt;Observer&gt;();
}

@Override
public void addObserver(Observer o) {
    if(o==null){
        return;
    }
    if(!(personList.contains(o))){
        personList.add(o);
    }

}

@Override
public void deletObserver(Observer o) {
    if(personList.contains(o))
        personList.remove(o);

}

public void doForecast(String t,String mess,int max,int min){

    forecastMess=mess;
    foreastTime=t;
    maxTemperature=max;
    minTemperature=min;
    notifyObserver();

}

@Override
public void notifyObserver() {
    for (int i = 0; i &lt; personList.size(); i++) {
        Observer ob=personList.get(i);
        ob.update(this);
    }
}

public String getForeastTime() {
    return foreastTime;
}

public String getForecastMess() {
    return forecastMess;
}

public int getMaxTemperature() {
    return maxTemperature;
}

public int getMinTemperature() {
    return minTemperature;
}
}
---
import java.util.ArrayList;

public class TravelAgency implements Subject {

String tourStarTime;
String tourMess;
ArrayList&lt;Observer&gt; personList;



public TravelAgency() {
    personList=new ArrayList&lt;Observer&gt;();
}

@Override
public void addObserver(Observer o) {
        if(o==null){
            return;
        }
        if(!(personList.contains(o)))
            personList.add(o);
}

@Override
public void deletObserver(Observer o) {
    if(personList.contains(o))
        personList.remove(o);

}

@Override
public void notifyObserver() {
        for (int i = 0; i &lt; personList.size(); i++) {
            Observer ob=personList.get(i);
            ob.update(this);
        }
}

public void giveMess(String time,String mess){
    tourMess=mess;
    tourStarTime=time;
    notifyObserver();
}

public String getTourStartTime(){
    return tourStarTime;
}
public String getTourMess(){
    return tourMess;
}
}
</code></pre><h6 id="具体观察者"><a href="#具体观察者" class="headerlink" title="具体观察者"></a>具体观察者</h6><pre><code>public class Person implements Observer{
Subject subjectOne,subjectTwo;
String forecastTime,forecastMess;
String tourStartTime,tourMess;
int maxTemperature,minTemperature;

Person(Subject subjectOne, Subject subjectTwo) {
    this.subjectOne = subjectOne;
    this.subjectTwo = subjectTwo;
    subjectOne.addObserver(this);
    subjectTwo.addObserver(this);
}
public void update(Subject subject){
    if(subject instanceof WeatherStation){
        WeatherStation ws=(WeatherStation)subject;
        forecastTime=ws.getForeastTime();
        forecastMess=ws.getForecastMess();
        maxTemperature=ws.getMaxTemperature();
        minTemperature=ws.getMinTemperature();
        System.out.println(&quot;预报日期：&quot;+forecastTime+&quot;,&quot;);
        System.out.println(&quot;天气状况:&quot;+forecastMess+&quot;,&quot;);
        System.out.println(&quot;最高温度：&quot;+maxTemperature+&quot;,&quot;);
        System.out.println(&quot;最低温度:&quot;+minTemperature+&quot;,&quot;);
    }else if(subject instanceof TravelAgency){
        TravelAgency ta=(TravelAgency)subject;
        tourStartTime = ta.getTourStartTime();
        tourMess=ta.getTourMess();
        System.out.println(&quot;旅游开始日期：&quot;+tourStartTime+&quot;,&quot;);
        System.out.println(&quot;旅游信息：&quot;+tourMess+&quot;,&quot;);

    }
}

}
</code></pre><h6 id="应用程序："><a href="#应用程序：" class="headerlink" title="应用程序："></a>应用程序：</h6><pre><code>public static void main(String[] args) {
WeatherStation wt=new WeatherStation();//具体主题
TravelAgency ta=new TravelAgency();
Person ma=new Person(wt, ta);
wt.doForecast(&quot;10日&quot;, &quot;多云&quot;, 28, 15);
ta.giveMess(&quot;10日&quot;, &quot;北京一日游&quot;);
wt.doForecast(&quot;11日&quot;, &quot;大雪&quot;, 10, 5);
ta.giveMess(&quot;11日&quot;, &quot;香港一日游&quot;);
}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;设计模式——观察者模式&quot;&gt;&lt;a href=&quot;#设计模式——观察者模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式——观察者模式&quot;&gt;&lt;/a&gt;设计模式——观察者模式&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;h2 id=&quot;概念：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖他的对象都得到通知并被自动更新。&quot;&gt;&lt;a href=&quot;#概念：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖他的对象都得到通知并被自动更新。&quot; class=&quot;headerlink&quot; title=&quot;概念：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖他的对象都得到通知并被自动更新。&quot;&gt;&lt;/a&gt;&lt;strong&gt;概念：&lt;/strong&gt;定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖他的对象都得到通知并被自动更新。&lt;/h2&gt;&lt;h4 id=&quot;模式的结构与使用&quot;&gt;&lt;a href=&quot;#模式的结构与使用&quot; class=&quot;headerlink&quot; title=&quot;模式的结构与使用&quot;&gt;&lt;/a&gt;模式的结构与使用&lt;/h4&gt;&lt;p&gt;观察者模式的结构中包括四种角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主题：主题是一个接口，该接口规定了具体主题需要实现的方法，比如，添加，删除观察者以及通知观察者更新数据的方法。&lt;/li&gt;
&lt;li&gt;观察者：观察者是一个接口，该接口规定了具体观察者用来更新数据的方法。&lt;/li&gt;
&lt;li&gt;具体主题：具体主题是实现主题接口类的一个实例，该实例包含有可以经常发生变化的数据。具体主题需要使用一个集合，存放观察者的引用，以便数据变化时通知具体观察者。&lt;/li&gt;
&lt;li&gt;具体观察者：具体观察者是实现观察者接口类的一个实例。具体观察者包含有可以存放具体主题引用的主题接口变量，以便具体观察者让具体主题将自己的引用添加到具体主题的集合中，使自己成为他的观察者，或让这个具体主题将自己从具体主题的集合中删除，使自己不再是它的观察者。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令模式详解</title>
    <link href="http://www.craymc.com/2017/01/16/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/16/命令模式详解/</id>
    <published>2017-01-16T14:44:26.000Z</published>
    <updated>2017-01-22T06:56:23.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式——命令模式"><a href="#设计模式——命令模式" class="headerlink" title="设计模式——命令模式"></a>设计模式——命令模式</h2><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><h3 id="命令模式是关于怎样处理一个对象请求另一个对象调用其方法完成某项任务的一种模式。"><a href="#命令模式是关于怎样处理一个对象请求另一个对象调用其方法完成某项任务的一种模式。" class="headerlink" title="命令模式是关于怎样处理一个对象请求另一个对象调用其方法完成某项任务的一种模式。"></a>命令模式是关于怎样处理一个对象请求另一个对象调用其方法完成某项任务的一种模式。</h3><hr>
<p>在命令模式中，当一个对象请求另一个对象调用其方法时，不和被请求对象直接打交道，而是把这种“请求”封装到一个称作“命令”的对象中，其封装手段是将“请求”封装在“命令”对象的一个方法中。<strong>命令模式的核心：</strong>使用命令对象来封装方法的调用，既将请求者的请求：“接收者调用方法”封装到命令对象的一个方法中，这样一来，当一个对象请求另一个对象调用方法来完成某项任务时，只需和命令对象交互，既让命令对象调用封装了“请求”的那个方法即可。</p>
<h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>命令模式的结构中包括四种角色：</p>
<ul>
<li>接受者：接受者是一个类的实例，该实例负责执行与请求相关的操作。</li>
<li>命令接口：命令是一个接口，规定了用来封装“请求”的若干个方法。</li>
<li>具体命令：具体命令是实现命令接口类的实例。具体命令必须实现命令接口中的方法。</li>
<li>请求者：请求者是一个包含命令接口变量的类的实例。请求者中的命令接口的变量可以存放任何具体的引用。请求者负责调用具体命令，让具体命令执行那些封装了“请求”的方法。</li>
</ul>
<hr>
<a id="more"></a>
<h4 id="命令模式的优点"><a href="#命令模式的优点" class="headerlink" title="命令模式的优点"></a>命令模式的优点</h4><p>  1.在命令模式中，请求者不直接与接收者交互，既请求者不包含接收者的引用，因此彻底消除了彼此之间的耦合。<br>  2.命令模式满足“开-闭原则”。如果增加新的具体命令和该命令的接收者，不必修改调用者的代码，调用者就可以使用新的命令对象；反之，如果增加新的调用者，不必修改现有的具体命令和接收者，新增加的调用者就可以使用已有的具体命令。<br>  3.由于请求者的请求被封装到了具体命令中，那么就可以将具体命令保存到持久化的媒介中，在需要的时候，重新执行这个命令。因此，使用命令模式可以记录日志</p>
<h2 id="4-使用命令模式可以对请求者的“请求”进行排队。每个请求都各自对应一个具体命令，因此可以按一定顺序执行这些具体命令。"><a href="#4-使用命令模式可以对请求者的“请求”进行排队。每个请求都各自对应一个具体命令，因此可以按一定顺序执行这些具体命令。" class="headerlink" title="  4.使用命令模式可以对请求者的“请求”进行排队。每个请求都各自对应一个具体命令，因此可以按一定顺序执行这些具体命令。"></a>  4.使用命令模式可以对请求者的“请求”进行排队。每个请求都各自对应一个具体命令，因此可以按一定顺序执行这些具体命令。</h2><h4 id="适合使用命令模式的场景"><a href="#适合使用命令模式的场景" class="headerlink" title="适合使用命令模式的场景"></a>适合使用命令模式的场景</h4><ul>
<li>程序需要在不同的时刻指定，排列和执行请求</li>
<li>程序需要提供撤销操作</li>
<li>程序需要支持宏操作</li>
</ul>
<hr>
<h5 id="代码描述："><a href="#代码描述：" class="headerlink" title="代码描述："></a>代码描述：</h5><h6 id="接受者："><a href="#接受者：" class="headerlink" title="接受者："></a>接受者：</h6><pre><code>public class ComapanyArmy {
public void sneakAttack(){
   System.out.println(&quot;我们知道如何完成任务&quot;);
  }
  }
</code></pre><h6 id="命令接口："><a href="#命令接口：" class="headerlink" title="命令接口："></a>命令接口：</h6><pre><code>public interface Command {
public abstract void execute();
    }
</code></pre><h6 id="具体命令："><a href="#具体命令：" class="headerlink" title="具体命令："></a>具体命令：</h6><pre><code>public class ConcreteCommand implements Command {

ComapanyArmy army;//含有接收者的引用

ConcreteCommand(ComapanyArmy army) {
    this.army = army;
}

@Override
public void execute() {
    army.sneakAttack();

}

}
</code></pre><h6 id="请求者："><a href="#请求者：" class="headerlink" title="请求者："></a>请求者：</h6><pre><code>public class ArmySuperior {
Command command;//用来存放具体命令的引用
public void setCommand(Command command){
    this.command=command;
}
public void startExecuteCommand(){
    command.execute();
}

}
</code></pre><h6 id="模式使用："><a href="#模式使用：" class="headerlink" title="模式使用："></a>模式使用：</h6><pre><code>public class Application {

public static void main(String[] args) {
    ComapanyArmy tz=new ComapanyArmy();
    Command c=new ConcreteCommand(tz);
    ArmySuperior ld=new ArmySuperior();
    ld.setCommand(c);
    ld.startExecuteCommand();
}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;设计模式——命令模式&quot;&gt;&lt;a href=&quot;#设计模式——命令模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式——命令模式&quot;&gt;&lt;/a&gt;设计模式——命令模式&lt;/h2&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;h3 id=&quot;命令模式是关于怎样处理一个对象请求另一个对象调用其方法完成某项任务的一种模式。&quot;&gt;&lt;a href=&quot;#命令模式是关于怎样处理一个对象请求另一个对象调用其方法完成某项任务的一种模式。&quot; class=&quot;headerlink&quot; title=&quot;命令模式是关于怎样处理一个对象请求另一个对象调用其方法完成某项任务的一种模式。&quot;&gt;&lt;/a&gt;命令模式是关于怎样处理一个对象请求另一个对象调用其方法完成某项任务的一种模式。&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;在命令模式中，当一个对象请求另一个对象调用其方法时，不和被请求对象直接打交道，而是把这种“请求”封装到一个称作“命令”的对象中，其封装手段是将“请求”封装在“命令”对象的一个方法中。&lt;strong&gt;命令模式的核心：&lt;/strong&gt;使用命令对象来封装方法的调用，既将请求者的请求：“接收者调用方法”封装到命令对象的一个方法中，这样一来，当一个对象请求另一个对象调用方法来完成某项任务时，只需和命令对象交互，既让命令对象调用封装了“请求”的那个方法即可。&lt;/p&gt;
&lt;h4 id=&quot;模式的结构和使用&quot;&gt;&lt;a href=&quot;#模式的结构和使用&quot; class=&quot;headerlink&quot; title=&quot;模式的结构和使用&quot;&gt;&lt;/a&gt;模式的结构和使用&lt;/h4&gt;&lt;p&gt;命令模式的结构中包括四种角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接受者：接受者是一个类的实例，该实例负责执行与请求相关的操作。&lt;/li&gt;
&lt;li&gt;命令接口：命令是一个接口，规定了用来封装“请求”的若干个方法。&lt;/li&gt;
&lt;li&gt;具体命令：具体命令是实现命令接口类的实例。具体命令必须实现命令接口中的方法。&lt;/li&gt;
&lt;li&gt;请求者：请求者是一个包含命令接口变量的类的实例。请求者中的命令接口的变量可以存放任何具体的引用。请求者负责调用具体命令，让具体命令执行那些封装了“请求”的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式系列详解</title>
    <link href="http://www.craymc.com/2017/01/16/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/16/Java设计模式系列详解/</id>
    <published>2017-01-16T14:43:39.000Z</published>
    <updated>2017-01-22T06:56:43.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式初体验"><a href="#设计模式初体验" class="headerlink" title="设计模式初体验"></a>设计模式初体验</h2><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><p>  设计模式需要四个要素：<br>                        1.名称<br>                        2.问题<br>                        3.方案<br>                        4.效果<br>设计模式可分为23种，具体可分为以下类型：<br><a id="more"></a><br>设计模式分为：创建型，行为型，结构型，具体分类如下：<br>创建型：工厂，单子，抽象，原型，生成<br>结构型：适配器 ，组合，代理 ，享元，外观，桥接，装饰<br>行为型：责任链，命令，解释器，迭代器，中介，备忘录，观察者，状态，策略，模板，访问者</p>
<h4 id="为什么要提出设计模式的概念？"><a href="#为什么要提出设计模式的概念？" class="headerlink" title="为什么要提出设计模式的概念？"></a>为什么要提出设计模式的概念？</h4><blockquote>
<p>设计模式是从许多优秀的软件系统中总结出成功的可复用的设计方案</p>
</blockquote>
<h4 id="设计模式的目的是什么呢？"><a href="#设计模式的目的是什么呢？" class="headerlink" title="设计模式的目的是什么呢？"></a>设计模式的目的是什么呢？</h4><p>设计模式的目的不是针对软件设计和开发中的每个问题都给出解决方案，而是针对某种特定环境中通常会遇到的某种软件开发给出的可重用的一些解决方案，在学习的过程中重点在于理解设计的思想，从而去解决实际开发问题。</p>
<hr>
<p>在详解每一个设计模式之前，有必要了解和掌握面向对象的几个基本原则，</p>
<ul>
<li>面向抽象原则</li>
<li>开-闭原则</li>
<li>多用组合少用继承原则</li>
<li>高内聚-低耦合原则<br>接下来会为大家详解23种设计模式…!</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;设计模式初体验&quot;&gt;&lt;a href=&quot;#设计模式初体验&quot; class=&quot;headerlink&quot; title=&quot;设计模式初体验&quot;&gt;&lt;/a&gt;设计模式初体验&lt;/h2&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;  设计模式需要四个要素：&lt;br&gt;                        1.名称&lt;br&gt;                        2.问题&lt;br&gt;                        3.方案&lt;br&gt;                        4.效果&lt;br&gt;设计模式可分为23种，具体可分为以下类型：&lt;br&gt;
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java中方法执行顺序</title>
    <link href="http://www.craymc.com/2017/01/12/java%E4%B8%AD%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://www.craymc.com/2017/01/12/java中方法执行顺序/</id>
    <published>2017-01-12T14:31:04.000Z</published>
    <updated>2017-01-12T14:32:35.542Z</updated>
    
    <content type="html"><![CDATA[<p>静态代码块：用staitc声明，jvm加载类时执行，仅执行一次</p>
<p>它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。<br>静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。<br>静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。<br>一个类中可以有多个静态代码块<br><a id="more"></a><br>构造代码块：<br>构造代码块的作用是给对象进行初始化。<br>对象一建立就运行构造代码块了，而且优先于构造函数执行。这里要强调一下，有对象建立，才会运行构造代码块，类不能调用构造代码块的。<br>构造代码块与构造函数的区别是：构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。<br>构造函数：</p>
<p>1.对象一建立，就会调用与之相应的构造函数，也就是说，不建立对象，构造函数时不会运行的。<br>2.构造函数的作用是用于给对象进行初始化。<br>3.一个对象建立，构造函数只运行一次，而一般方法可以被该对象调用多次。</p>
<p>明白以上概念后，总计如下：对于一个类 执行顺序为：1.静态代码2.main（）方法3.构造代码（如果对象建立就会执行）4.构造函数</p>
<p>出现继承时：<br>执行父类的静态代码块，并初始化父类静态成员变量<br>执行子类的静态代码块，并初始化子类静态成员变量<br>执行父类的构造代码块，执行父类的构造函数，并初始化父类普通成员变量<br>执行子类的构造代码块， 执行子类的构造函数，并初始化子类普通成员变量</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态代码块：用staitc声明，jvm加载类时执行，仅执行一次&lt;/p&gt;
&lt;p&gt;它是随着类的加载而执行，只执行一次，并优先于主函数。具体说，静态代码块是由类调用的。类调用时，先执行静态代码块，然后才执行主函数的。&lt;br&gt;静态代码块其实就是给类初始化的，而构造代码块是给对象初始化的。&lt;br&gt;静态代码块中的变量是局部变量，与普通函数中的局部变量性质没有区别。&lt;br&gt;一个类中可以有多个静态代码块&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.craymc.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java常见面试题</title>
    <link href="http://www.craymc.com/2017/01/12/java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://www.craymc.com/2017/01/12/java常见面试题/</id>
    <published>2017-01-12T13:36:50.000Z</published>
    <updated>2017-01-16T15:00:28.756Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="#java">java基础</a><ul>
<li><a href="#接口的意义-百度">接口的意义-百度</a></li>
<li><a href="#抽象类的意义-乐视">抽象类的意义-乐视</a></li>
<li><a href="#内部类的作用-乐视">内部类的作用-乐视</a></li>
<li><a href="#父类的静态方法能否被子类重写-猎豹">父类的静态方法能否被子类重写-猎豹</a></li>
<li><a href="#java排序算法-美团">java排序算法-美团</a></li>
<li><a href="#列举java的集合和继承关系-百度-美团">列举java的集合和继承关系-百度-美团</a></li>
<li><a href="#java虚拟机的特性-百度-乐视">java虚拟机的特性-百度-乐视</a></li>
<li><a href="#哪些情况下的对象会被垃圾回收机制处理掉-美团-小米">哪些情况下的对象会被垃圾回收机制处理掉-美团-小米</a></li>
<li><a href="#进程和线程的区别-猎豹-美团">进程和线程的区别-猎豹-美团</a></li>
<li><a href="#java中==和equals和hashCode的区别-乐视">==和equals和hashCode的区别-乐视</a></li>
<li><a href="#常见的排序算法时间复杂度-小米">常见的排序算法时间复杂度-小米</a></li>
<li><a href="#HashMap的实现原理-美团">HashMap的实现原理-美团</a></li>
<li><a href="#java状态机">java状态机</a></li>
<li><a href="#int-char-long各占多少字节数">int-char-long各占多少字节数</a></li>
<li><a href="#int与integer的区别">int与integer的区别</a></li>
<li><a href="#string-stringbuffer-stringbuilder区别-小米-乐视-百度">string-stringbuffer-stringbuilder区别-小米-乐视-百度</a></li>
<li><a href="#java多态-乐视">java多态-乐视</a></li>
<li><a href="#什么导致线程阻塞-58-美团">什么导致线程阻塞-58-美团</a></li>
<li><a href="#抽象类接口区别-360">抽象类接口区别-360</a></li>
<li><a href="#容器类之间的区别-乐视-美团">容器类之间的区别-乐视-美团</a></li>
<li><a href="#内部类">内部类</a></li>
<li><a href="#hashmap和hashtable的区别-乐视-小米">hashmap和hashtable的区别-乐视-小米</a></li>
<li><a href="#arraymap对比hashmap">ArrayMap对比HashMap</a><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3></li>
</ul>
</li>
</ul>
<h4 id="接口的意义-百度"><a href="#接口的意义-百度" class="headerlink" title="接口的意义-百度"></a>接口的意义-百度</h4><p>规范、扩展、回调<br><a id="more"></a></p>
<h4 id="抽象类的意义-乐视"><a href="#抽象类的意义-乐视" class="headerlink" title="抽象类的意义-乐视"></a>抽象类的意义-乐视</h4><p>为其子类提供一个公共的类型<br>封装子类中得重复内容<br>定义抽象方法，子类虽然有不同的实现 但是定义是一致的</p>
<h4 id="内部类的作用-乐视"><a href="#内部类的作用-乐视" class="headerlink" title="内部类的作用-乐视"></a>内部类的作用-乐视</h4><ol>
<li>内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>
<li>创建内部类对象的时刻并不依赖于外围类对象的创建。</li>
<li>内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>
<li>内部类提供了更好的封装，除了该外围类，其他类都不能访问</li>
</ol>
<p>抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了。<br>  抽象类和普通类的主要有三点区别：</p>
<p>1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</p>
<p>2）抽象类不能用来创建对象；</p>
<p>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</p>
<p>什么时候使用抽象类和接口</p>
<p>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。<br>如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。<br>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</p>
<h4 id="父类的静态方法能否被子类重写-猎豹"><a href="#父类的静态方法能否被子类重写-猎豹" class="headerlink" title="父类的静态方法能否被子类重写-猎豹"></a>父类的静态方法能否被子类重写-猎豹</h4><p>不能</p>
<p>子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，至于方法重载我觉得它其中一要素就是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现</p>
<p>快速失败和安全失败<br>快速失败：对于非并发集合来说，在其进行迭代时，例如iterator迭代时，iterator是另起一个线程，若有其他线程（如 Collection）进行结构修改（修改了增减了集合中的内容），这个迭代会马上感知到，并且立即抛出 ConcurrentModificationException 异常，而不是迭代完成后才告诉你出错了，引起快速失败。若用iterator进行修改则不会出现这个问题，如iterator.move();也就是说涉 及到了多个线程间的同步问题</p>
<h4 id="java排序算法-美团"><a href="#java排序算法-美团" class="headerlink" title="java排序算法-美团"></a>java排序算法-美团</h4><p><a href="http://blog.csdn.net/qy1387/article/details/7752973" target="_blank" rel="external">http://blog.csdn.net/qy1387/article/details/7752973</a></p>
<h4 id="列举java的集合和继承关系-百度-美团"><a href="#列举java的集合和继承关系-百度-美团" class="headerlink" title="列举java的集合和继承关系-百度-美团"></a>列举java的集合和继承关系-百度-美团</h4><p><img src="https://github.com/JackyAndroid/AndroidInterview-Q-A/blob/master/picture/collection.png" alt=""></p>
<h4 id="java虚拟机的特性-百度-乐视"><a href="#java虚拟机的特性-百度-乐视" class="headerlink" title="java虚拟机的特性-百度-乐视"></a>java虚拟机的特性-百度-乐视</h4><p>Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。</p>
<h4 id="哪些情况下的对象会被垃圾回收机制处理掉-美团-小米"><a href="#哪些情况下的对象会被垃圾回收机制处理掉-美团-小米" class="headerlink" title="哪些情况下的对象会被垃圾回收机制处理掉-美团-小米"></a>哪些情况下的对象会被垃圾回收机制处理掉-美团-小米</h4><p>Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。</p>
<h4 id="进程和线程的区别-猎豹-美团"><a href="#进程和线程的区别-猎豹-美团" class="headerlink" title="进程和线程的区别-猎豹-美团"></a>进程和线程的区别-猎豹-美团</h4><p>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。</p>
<p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
<p>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p>
<p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</p>
<p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</p>
<p>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</p>
<p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。</p>
<h4 id="java中-和equals和hashCode的区别-乐视"><a href="#java中-和equals和hashCode的区别-乐视" class="headerlink" title="java中==和equals和hashCode的区别-乐视"></a>java中==和equals和hashCode的区别-乐视</h4><p><a href="http://blog.csdn.net/tiantiandjava/article/details/46988461" target="_blank" rel="external">http://blog.csdn.net/tiantiandjava/article/details/46988461</a></p>
<h4 id="常见的排序算法时间复杂度-小米"><a href="#常见的排序算法时间复杂度-小米" class="headerlink" title="常见的排序算法时间复杂度-小米"></a>常见的排序算法时间复杂度-小米</h4><h4 id="HashMap的实现原理-美团"><a href="#HashMap的实现原理-美团" class="headerlink" title="HashMap的实现原理-美团"></a>HashMap的实现原理-美团</h4><ol>
<li>HashMap概述：<br>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 </li>
<li>HashMap的数据结构：<br> 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</li>
</ol>
<p>从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p><a href="http://www.jdon.com/designpatterns/designpattern_State.htm" target="_blank" rel="external">http://www.jdon.com/designpatterns/designpattern_State.htm</a></p>
<h4 id="int-char-long各占多少字节数"><a href="#int-char-long各占多少字节数" class="headerlink" title="int-char-long各占多少字节数"></a>int-char-long各占多少字节数</h4><p>byte 位数 8 字节数 1</p>
<p>short 16 2</p>
<p>int 32 4</p>
<p>long 64 8</p>
<p>float 32 4</p>
<p>double 64 8</p>
<p>char 16 2</p>
<h4 id="int与integer的区别"><a href="#int与integer的区别" class="headerlink" title="int与integer的区别"></a>int与integer的区别</h4><p><a href="http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html" target="_blank" rel="external">http://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html</a></p>
<h4 id="string-stringbuffer-stringbuilder区别-小米-乐视-百度"><a href="#string-stringbuffer-stringbuilder区别-小米-乐视-百度" class="headerlink" title="string-stringbuffer-stringbuilder区别-小米-乐视-百度"></a>string-stringbuffer-stringbuilder区别-小米-乐视-百度</h4><p>String 字符串常量</p>
<p>StringBuffer 字符串变量（线程安全）</p>
<p>StringBuilder 字符串变量（非线程安全）</p>
<p>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后,JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</p>
<p>而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：</p>
<p>String S1 = “This is only a” + “ simple” + “ test”;</p>
<p>StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);<br>你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个<br> String S1 = “This is only a” + “ simple” + “test”; 其实就是：<br> String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：<br> String S2 = “This is only a”;<br>String S3 = “ simple”;<br>String S4 = “ test”;<br>String S1 = S2 +S3 + S4;<br>这时候 JVM 会规规矩矩的按照原来的方式去做</p>
<p>在大部分情况下 StringBuffer &gt; String</p>
<p>StringBuffer</p>
<p>Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。</p>
<p>可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。</p>
<p>StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。</p>
<p>例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append(“le”) 会使字符串缓冲区包含“startle”，而 z.insert(4, “le”) 将更改字符串缓冲区，使之包含“starlet”。</p>
<p>在大部分情况下 StringBuilder &gt; StringBuffer</p>
<p>java.lang.StringBuilder</p>
<p>java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同</p>
<h4 id="java多态-乐视"><a href="#java多态-乐视" class="headerlink" title="java多态-乐视"></a>java多态-乐视</h4><p>Java多态性理解</p>
<p>Java中多态性的实现</p>
<p>什么是多态</p>
<p>面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。</p>
<p>多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p>
<p>实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实<br>际类型，根据其实际的类型调用其相应的方法。</p>
<p>多态的作用：消除类型之间的耦合关系。</p>
<p>现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。<br>下面是多态存在的三个必要条件，要求大家做梦时都能背出来！</p>
<p>多态存在的三个必要条件<br>一、要有继承；<br>二、要有重写；<br>三、父类引用指向子类对象。</p>
<p> 多态的好处：</p>
<p>1.可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。</p>
<p>2.可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。</p>
<p>3.接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。</p>
<p>4.灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。</p>
<p>5.简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。</p>
<p>Java中多态的实现方式：接口实现，继承父类进行方法重写，同一个类中进行方法重载。</p>
<h4 id="什么导致线程阻塞-58-美团"><a href="#什么导致线程阻塞-58-美团" class="headerlink" title="什么导致线程阻塞-58-美团"></a>什么导致线程阻塞-58-美团</h4><p>线程的阻塞</p>
<p>为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.</p>
<p>阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。Java 提供了大量方法来支持阻塞，下面让我们逐一分析。</p>
<ol>
<li>sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。<br>典型地，sleep() 被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。</li>
<li>suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。</li>
<li>yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.</li>
<li>wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</li>
</ol>
<p>初看起来它们与 suspend() 和 resume() 方法对没有什么分别，但是事实上它们是截然不同的。区别的核心在于，前面叙述的所有方法，阻塞时都不会释放占用的锁（如果占用了的话），而这一对方法则相反。</p>
<p>上述的核心区别导致了一系列的细节上的区别。</p>
<p>首先，前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。</p>
<p>其次，前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。</p>
<p>wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。</p>
<p>关于 wait() 和 notify() 方法最后再说明两点：</p>
<p>第一：调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p>
<p>第二：除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</p>
<p>谈到阻塞，就不能不谈一谈死锁，略一分析就能发现，suspend() 方法和不指定超时期限的 wait() 方法的调用都可能产生死锁。遗憾的是，Java 并不在语言级别上支持死锁的避免，我们在编程中必须小心地避免死锁。</p>
<p>以上我们对 Java 中实现线程阻塞的各种方法作了一番分析，我们重点分析了 wait() 和 notify() 方法，因为它们的功能最强大，使用也最灵活，但是这也导致了它们的效率较低，较容易出错。实际使用中我们应该灵活使用各种方法，以便更好地达到我们的目的。</p>
<h4 id="抽象类接口区别-360"><a href="#抽象类接口区别-360" class="headerlink" title="抽象类接口区别-360"></a>抽象类接口区别-360</h4><ol>
<li><p>默认的方法实现<br>抽象类可以有默认的方法实现完全是抽象的。接口根本不存在方法的实现</p>
</li>
<li><p>实现<br>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。<br>子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现</p>
</li>
<li><p>构造器<br>抽象类可以有构造器<br>接口不能有构造器</p>
</li>
<li><p>与正常Java类的区别<br>除了你不能实例化抽象类之外，它和普通Java类没有任何区<br>接口是完全不同的类型</p>
</li>
<li><p>访问修饰符<br>抽象方法可以有public、protected和default这些修饰符<br>接口方法默认修饰符是public。你不可以使用其它修饰符。</p>
</li>
<li><p>main方法<br>抽象方法可以有main方法并且我们可以运行它<br>接口没有main方法，因此我们不能运行它。</p>
</li>
<li><p>多继承<br>抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。</p>
</li>
<li><p>速度<br>它比接口速度要快<br>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</p>
</li>
<li><p>添加新方法<br>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。<br>如果你往接口中添加方法，那么你必须改变实现该接口的类。</p>
</li>
</ol>
<h4 id="容器类之间的区别-乐视-美团"><a href="#容器类之间的区别-乐视-美团" class="headerlink" title="容器类之间的区别-乐视-美团"></a>容器类之间的区别-乐视-美团</h4><p><a href="http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html" target="_blank" rel="external">http://www.cnblogs.com/yuanermen/archive/2009/08/05/1539917.html</a><br><a href="http://alexyyek.github.io/2015/04/06/Collection/" target="_blank" rel="external">http://alexyyek.github.io/2015/04/06/Collection/</a><br><a href="http://tianmaying.com/tutorial/java_collection" target="_blank" rel="external">http://tianmaying.com/tutorial/java_collection</a></p>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p><a href="http://www.cnblogs.com/chenssy/p/3388487.html" target="_blank" rel="external">http://www.cnblogs.com/chenssy/p/3388487.html</a></p>
<h4 id="hashmap和hashtable的区别-乐视-小米"><a href="#hashmap和hashtable的区别-乐视-小米" class="headerlink" title="hashmap和hashtable的区别-乐视-小米"></a>hashmap和hashtable的区别-乐视-小米</h4><p><a href="http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html" target="_blank" rel="external">http://www.233.com/ncre2/JAVA/jichu/20100717/084230917.html</a></p>
<h4 id="ArrayMap对比HashMap"><a href="#ArrayMap对比HashMap" class="headerlink" title="ArrayMap对比HashMap"></a>ArrayMap对比HashMap</h4><p><a href="http://lvable.com/?p=217" target="_blank" rel="external">http://lvable.com/?p=217</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#java&quot;&gt;java基础&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#接口的意义-百度&quot;&gt;接口的意义-百度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#抽象类的意义-乐视&quot;&gt;抽象类的意义-乐视&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#内部类的作用-乐视&quot;&gt;内部类的作用-乐视&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#父类的静态方法能否被子类重写-猎豹&quot;&gt;父类的静态方法能否被子类重写-猎豹&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#java排序算法-美团&quot;&gt;java排序算法-美团&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#列举java的集合和继承关系-百度-美团&quot;&gt;列举java的集合和继承关系-百度-美团&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#java虚拟机的特性-百度-乐视&quot;&gt;java虚拟机的特性-百度-乐视&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#哪些情况下的对象会被垃圾回收机制处理掉-美团-小米&quot;&gt;哪些情况下的对象会被垃圾回收机制处理掉-美团-小米&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#进程和线程的区别-猎豹-美团&quot;&gt;进程和线程的区别-猎豹-美团&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#java中==和equals和hashCode的区别-乐视&quot;&gt;==和equals和hashCode的区别-乐视&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#常见的排序算法时间复杂度-小米&quot;&gt;常见的排序算法时间复杂度-小米&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#HashMap的实现原理-美团&quot;&gt;HashMap的实现原理-美团&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#java状态机&quot;&gt;java状态机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#int-char-long各占多少字节数&quot;&gt;int-char-long各占多少字节数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#int与integer的区别&quot;&gt;int与integer的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#string-stringbuffer-stringbuilder区别-小米-乐视-百度&quot;&gt;string-stringbuffer-stringbuilder区别-小米-乐视-百度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#java多态-乐视&quot;&gt;java多态-乐视&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#什么导致线程阻塞-58-美团&quot;&gt;什么导致线程阻塞-58-美团&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#抽象类接口区别-360&quot;&gt;抽象类接口区别-360&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#容器类之间的区别-乐视-美团&quot;&gt;容器类之间的区别-乐视-美团&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#内部类&quot;&gt;内部类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#hashmap和hashtable的区别-乐视-小米&quot;&gt;hashmap和hashtable的区别-乐视-小米&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#arraymap对比hashmap&quot;&gt;ArrayMap对比HashMap&lt;/a&gt;&lt;h3 id=&quot;java&quot;&gt;&lt;a href=&quot;#java&quot; class=&quot;headerlink&quot; title=&quot;java&quot;&gt;&lt;/a&gt;java&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;接口的意义-百度&quot;&gt;&lt;a href=&quot;#接口的意义-百度&quot; class=&quot;headerlink&quot; title=&quot;接口的意义-百度&quot;&gt;&lt;/a&gt;接口的意义-百度&lt;/h4&gt;&lt;p&gt;规范、扩展、回调&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://www.craymc.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Kali Linux安装-硬盘安装、虚拟机安装</title>
    <link href="http://www.craymc.com/2016/07/15/Kali-Linux%E5%AE%89%E8%A3%85-%E7%A1%AC%E7%9B%98%E5%AE%89%E8%A3%85%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85/"/>
    <id>http://www.craymc.com/2016/07/15/Kali-Linux安装-硬盘安装、虚拟机安装/</id>
    <published>2016-07-15T11:04:31.000Z</published>
    <updated>2016-07-20T10:47:18.971Z</updated>
    
    <content type="html"><![CDATA[<p>##第二课时<br>软件版本：1.1.0<br>安装方法：光盘，镜像，u盘（工具：unetbootin 要求：u盘至少4个g）<br>安装支持设备：u盘移动，手机，电脑</p>
<p>1.硬盘安装方式<br>进入安装界面<br>      live  体验<br>      live usb persistence  制作u盘无密码移动版<br>      live usb encrypted persistence  制作u盘有密码移动版<br>      install 直接安装<br>      graphical install 图形化安装</p>
<p>2.docker(容器)<br>      <a href="https://www.kali.org/news/official-kali-linux-docker-images/" target="_blank" rel="external">https://www.kali.org/news/official-kali-linux-docker-images/</a> kali docker image(kali官方提供的docker镜像里面不包含任何软件工具)</p>
<pre><code>https://github.com/offensive-secunity/kali-linux-docker kali官方放在docker的脚本（要求自己做的kali镜像）
</code></pre><hr>
<a id="more"></a>
<p>1.虚拟机安装<br>    vmware workstation<br>    virtualbox<br>    官方vm镜像文件：<br>     <a href="https://www.offensive-security.com/kali-linux-vmware-arm-image-download/" target="_blank" rel="external">https://www.offensive-security.com/kali-linux-vmware-arm-image-download/</a><br>     win8系统安装虚拟机注意：要卸载微软的kb3045999补丁 卸载方法：打开命令提示符cd/到c盘再powershell再打入get-hotfix -id KB3045999回车打入wusa /uninstall /kb:3045999成功卸载</p>
<pre><code>安装tools:
</code></pre><p>先在虚拟机上安装附加模块，在打开哪个镜像，选择里面的vboxlinuxadditions.run拷贝出来用终端打开，先列出目录ls,再查询现有的权限ls -l，在赋予执行权限chmod +x 文件（x表示可执行），再看下文件是否是绿色ls -l，再运行./文件<br>，重启reboot</p>
<p>2.持久加密usb安装</p>
<p>模式：<br>1、live(amd64)可以通过启动U盘来运行kali linux。缺点：不可以安装新的软件包或更新修改；<br>2、Live USB P/EP(加密的持久USB启动光盘)。<br>DOCKER?<br>虚拟机安装<br>vmware workstation<br>Virtualbox<br>win8安装virtualbox，需要卸载一个补丁,要用到powershell，cmd下执行powershell，然后<br>poewershell<br>get-hotfix -id KB3045999</p>
<p>wusa /uninstall /kb:3045999  按回车键，卸载</p>
<p>虚拟机安装kali linux设置内存最好是2G，最大可以设置成4G</p>
<hr>
<p>安装kali linux操作系统<br>Graphical install   //选择字母界面安装kali linux操作系统</p>
<p>chinese(Simplified)  中文（简体）</p>
<p>中国</p>
<p>汉语</p>
<p>请输入系统的主机名: Kali</p>
<p>域名：      //如果这里有域名可以在下面填写,如果木有域名则自己按继续</p>
<p>输入root账号密码 </p>
<p>向导-使用整个硬盘</p>
<p>SCSII (0,0,0)(sda)- 85.9GB ATA VBOX HARDDISK</p>
<p>√ 讲所有每个文件放在同一个分区中（推荐新手使用）<br>×将/home、/usr、/var和/tmp都分别放在单独的分区</p>
<p>分区设定结构并将修改写入硬盘</p>
<p>将改动写入硬盘吗？  是</p>
<p>将CRUB 启动引导基安装到主引导记录（MBR）上么？  是</p>
<p>安装完成    继续</p>
<hr>
<p>root@kali:~# apt-get install linux-headers-$(uname -r)    //更新系统并显示linux操作系统内核版本号<br>Reading package lists … Done<br>Building dependency tree<br>Reading state information… Done<br>Linux-headers-3.18.0-kalil-586 is already the newesr version.<br>0 upgrade, 0 newly installed, 0 to remove and 163 not upgraded.</p>
<p>root@kali:~# apt-get update</p>
<p>root@kali:~# uname -r      //uname用来获取电脑和操作系统的相关信息,显示linux操作系统内核版本号<br>3.18.0-kalil-586</p>
<p>root@kali:~/Desktop# ls      //打印出当前目录的清单<br>VBocLinuxAdditions.run</p>
<p>root@kali:~/Desktop# ls -l     //列出文件的详细信息，如创建者，创建时间，文件的读写权限列表等等<br>tottal 6972<br>-rw-r–r 1 root root 7136717 may 13 12:12 VBocLinuxAdditions.run</p>
<p>root@kali:~/Desktop# chmod +x VBocLinuxAdditions.run                 赋予执行权限</p>
<p>root@kali:~/Desktop# ls -l<br>tottal 6972<br>-rwxr-r–r 1 root root 7136717 may 13 12:12 VBocLinuxAdditions.run      赋予权限且”VBocLinuxAdditions.run”变成绿色</p>
<p>root@kali:~/Desktop# ./VBocLinuxAdditions.run       运行VBocLinuxAdditions.run</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##第二课时&lt;br&gt;软件版本：1.1.0&lt;br&gt;安装方法：光盘，镜像，u盘（工具：unetbootin 要求：u盘至少4个g）&lt;br&gt;安装支持设备：u盘移动，手机，电脑&lt;/p&gt;
&lt;p&gt;1.硬盘安装方式&lt;br&gt;进入安装界面&lt;br&gt;      live  体验&lt;br&gt;      live usb persistence  制作u盘无密码移动版&lt;br&gt;      live usb encrypted persistence  制作u盘有密码移动版&lt;br&gt;      install 直接安装&lt;br&gt;      graphical install 图形化安装&lt;/p&gt;
&lt;p&gt;2.docker(容器)&lt;br&gt;      &lt;a href=&quot;https://www.kali.org/news/official-kali-linux-docker-images/&quot;&gt;https://www.kali.org/news/official-kali-linux-docker-images/&lt;/a&gt; kali docker image(kali官方提供的docker镜像里面不包含任何软件工具)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;https://github.com/offensive-secunity/kali-linux-docker kali官方放在docker的脚本（要求自己做的kali镜像）
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="Kali" scheme="http://www.craymc.com/tags/Kali/"/>
    
  </entry>
  
  <entry>
    <title>Kali 使用教程笔记</title>
    <link href="http://www.craymc.com/2016/05/13/Kali%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.craymc.com/2016/05/13/Kali使用教程笔记/</id>
    <published>2016-05-13T01:10:28.000Z</published>
    <updated>2016-07-20T10:47:18.971Z</updated>
    
    <content type="html"><![CDATA[<p>课时1 Kali Linux渗透测试介绍<br>    安全问题的根源<br>        优点：分工明确，工作效率高。<br>        缺点：从业人员对系统没有整体的认识，对安全认识较为片面。<br>        最大威胁是人，人都会犯错，安全问题不能100%绝对根除。<br>   安全目标<br>        先于攻击者发现和防止漏洞出现<br>        攻击型：以攻击者的思维发现漏洞、攻击系统。<br>        防护型:投入巨大，会有遗漏，不够全面，收效不高。<br>    渗透测试<br>        尝试破解系统防御机制，发现系统弱点<br>        从攻击者的角度思考，测量安全防护的有效性<br>        证明问题存在，而不是破坏<br>        道德约束、法律<br>        不局限于一台机器出现的问题，而着眼漏洞对整个系统的影响与危害<br><a id="more"></a><br>    渗透测试标准<br>        PETS (<a href="http://www.pentest-standard.org" target="_blank" rel="external">http://www.pentest-standard.org</a>)<br>        前期交互（客户沟通，确定渗透测试范围，对应用系统渗透任务划分，包括支撑整个系统的各种软件组件）<br>        情报收集（收集目标系统信息，被动收集与主动探测）<br>        威胁建模（根据收集到的信息，确定最有效，最有可能成功的攻击途径）<br>        漏洞分析（通过系统软件版本分析，系统应用漏洞分析写出漏洞利用代码）<br>        渗透攻击阶段（并不像想象中那么顺利，目标系统有防护系统）<br>        后渗透测试阶段（以一台被渗透机器为跳板，进一步渗透整个系统）<br>        渗透测试报告（向客户和其他同事证明系统可以被控制，描述发现、利用过程，以及如何解决）<br>    渗透测试项目<br>        测试范围（整个应用系统）<br>        客户授权（允许攻击还是只是渗透都取决于客户的授权）<br>        渗透测试方法<br>        是否允许社会工程学攻击<br>        是否允许DOS攻击<br>    渗透测试误区<br>        扫描器就是一切（不能忽略业务逻辑的漏洞。自动化技术扫描工具有他的适用范围，对业务逻辑的漏洞也是无能为力。扫描器是辅助工具）<br>    KALI<br>        字面意思“黑色”，音译“咖利”，印度神话中最为黑暗和暴虐的黑色地母。<br>        Kali Linux中的Kali用意估计取自“黑色”的意思。<br>    Kali Linux<br>        基于Debian的发行版本，在其基础上添加了许多信息安全工具，用于渗透测试和安全审计<br>        所有Linux发行版本都遵循的FHS标准目录结构（BT pentest目录中工具分类困难，工具难以更新）<br>        定制内核（主要解决无线渗透测试出现各种错误的问题）<br>        支持ARM、手机平台（NetHunter）<br>        Open Source Free-Offensive Security<br>    Kali Linux策略</p>
<pre><code>Root用户策略（不同于普通Linux系统小心翼翼的使用方式）
网络服务策略（默认关闭所有网络服务，自启动脚本默认关闭）
更新升级策略（Debian + KALI官方）
</code></pre><p>实践是最好的老师，Kali很强大，但不是全部。这只是关于渗透测试的起点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;课时1 Kali Linux渗透测试介绍&lt;br&gt;    安全问题的根源&lt;br&gt;        优点：分工明确，工作效率高。&lt;br&gt;        缺点：从业人员对系统没有整体的认识，对安全认识较为片面。&lt;br&gt;        最大威胁是人，人都会犯错，安全问题不能100%绝对根除。&lt;br&gt;   安全目标&lt;br&gt;        先于攻击者发现和防止漏洞出现&lt;br&gt;        攻击型：以攻击者的思维发现漏洞、攻击系统。&lt;br&gt;        防护型:投入巨大，会有遗漏，不够全面，收效不高。&lt;br&gt;    渗透测试&lt;br&gt;        尝试破解系统防御机制，发现系统弱点&lt;br&gt;        从攻击者的角度思考，测量安全防护的有效性&lt;br&gt;        证明问题存在，而不是破坏&lt;br&gt;        道德约束、法律&lt;br&gt;        不局限于一台机器出现的问题，而着眼漏洞对整个系统的影响与危害&lt;br&gt;
    
    </summary>
    
    
      <category term="Kali" scheme="http://www.craymc.com/tags/Kali/"/>
    
  </entry>
  
  <entry>
    <title>git问题集-git-生成SSH</title>
    <link href="http://www.craymc.com/2016/04/22/git%E9%97%AE%E9%A2%98%E9%9B%86-git-%E7%94%9F%E6%88%90SSH/"/>
    <id>http://www.craymc.com/2016/04/22/git问题集-git-生成SSH/</id>
    <published>2016-04-22T01:06:01.000Z</published>
    <updated>2016-07-20T10:47:18.973Z</updated>
    
    <content type="html"><![CDATA[<p>第一步：</p>
<p>打开gitbash输入：ls -al ~/.ssh</p>
<p>Check the directory listing to see if you already have a public SSH key. By default, the filenames of the public keys are one of the following:</p>
<p>id_dsa.pub</p>
<p>id_ecdsa.pub</p>
<p>id_ed25519.pub</p>
<p>id_rsa.pub</p>
<a id="more"></a>
<p>第二步：ssh-keygen -t rsa -b 4096 -C “your_email@example.com”</p>
<h1 id="Creates-a-new-ssh-key-using-the-provided-email-as-a-label"><a href="#Creates-a-new-ssh-key-using-the-provided-email-as-a-label" class="headerlink" title="Creates a new ssh key, using the provided email as a label"></a>Creates a new ssh key, using the provided email as a label</h1><p>#Generating public/private rsa key pair.</p>
<p>②：接下来一直回车</p>
<p>③出现：# Creates a new ssh key, using the provided email as a label</p>
<p>#Generating public/private rsa key pair.</p>
<p>第三步：添加代理</p>
<h1 id="start-the-ssh-agent-in-the-backgroundssh-agent-s-Agent-pid-59566"><a href="#start-the-ssh-agent-in-the-backgroundssh-agent-s-Agent-pid-59566" class="headerlink" title="start the ssh-agent in the backgroundssh-agent -s#Agent pid 59566"></a>start the ssh-agent in the backgroundssh-agent -s#Agent pid 59566</h1><p>#</p>
<h1 id="start-the-ssh-agent-in-the-backgroundeval-ssh-agent-s-Agent-pid-59566"><a href="#start-the-ssh-agent-in-the-backgroundeval-ssh-agent-s-Agent-pid-59566" class="headerlink" title="start the ssh-agent in the backgroundeval $(ssh-agent -s)#Agent pid 59566"></a>start the ssh-agent in the backgroundeval $(ssh-agent -s)#Agent pid 59566</h1><p>ssh-add ~/.ssh/id_rsa</p>
<p>第四步：把SSHKEY添加到你的账户</p>
<p>用公钥。先在GitHub上注册一个用户，然后进入account-setting ，把id_rsa.pub的内容复制进去就可以了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一步：&lt;/p&gt;
&lt;p&gt;打开gitbash输入：ls -al ~/.ssh&lt;/p&gt;
&lt;p&gt;Check the directory listing to see if you already have a public SSH key. By default, the filenames of the public keys are one of the following:&lt;/p&gt;
&lt;p&gt;id_dsa.pub&lt;/p&gt;
&lt;p&gt;id_ecdsa.pub&lt;/p&gt;
&lt;p&gt;id_ed25519.pub&lt;/p&gt;
&lt;p&gt;id_rsa.pub&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://www.craymc.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>2016第一篇</title>
    <link href="http://www.craymc.com/2016/01/23/2016%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://www.craymc.com/2016/01/23/2016第一篇/</id>
    <published>2016-01-23T06:11:48.000Z</published>
    <updated>2016-07-20T10:47:18.970Z</updated>
    
    <content type="html"><![CDATA[<pre><code>新年伊始，在忙完了考试和实训后，终于有了时间来写下这一篇迟来的新年文章。
</code></pre><a id="more"></a>
<pre><code>回顾一下过去的一年，生活上跟以前没有什么变化，一如既往；在学习上了解了一些知识，拓宽了知识广度，做了一个重大的决定，希望自己能够实现。在12月份的时候参加了“开源中国”的年度盛典，亲眼目睹了“鸟哥”的那猥琐的面容，也因此认识了华为的兰姐姐，在场于那些前辈们，沟通了许多话题，阿里的沈老师给自己提供了很多有用的建议，总之，这次涨姿势了！
新的一年中，想得要增强一下代码的量度，也能学到更多的知识分享的博客，与大家共享！
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;新年伊始，在忙完了考试和实训后，终于有了时间来写下这一篇迟来的新年文章。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://www.craymc.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>3种方式在Linux下配置网卡</title>
    <link href="http://www.craymc.com/2016/01/23/3%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%9C%A8Linux%E4%B8%8B%E9%85%8D%E7%BD%AE%E7%BD%91%E5%8D%A1/"/>
    <id>http://www.craymc.com/2016/01/23/3种方式在Linux下配置网卡/</id>
    <published>2016-01-23T05:59:05.000Z</published>
    <updated>2016-07-20T10:47:18.970Z</updated>
    
    <content type="html"><![CDATA[<pre><code>1.    配置第一块网卡，并设置为静态，要求模式为nat模式

a.图形化：用setup去调用图形化设置
</code></pre><p>PS：eth0(相当于数组)DHCP为（＊）说明未配置，点击空格进行配置<br>    配置思路：192.168.71..0</p>
<a id="more"></a>
<pre><code>b.修改配置文件：

c.临时分配：    IP：192.168.91.1／24
</code></pre><p>2</p>
<pre><code>2.配置完成后
</code></pre><p>   开启服务<br>service network  start<br>b.<br>   vim /etc/sysconfig/network-scripts/ifcfg-eth0</p>
<pre><code>PS:填三行，改两处

none=static;    onboot=yes
        NETMASK;GETWAY;
</code></pre><p>改写完成后，service network restart<br>c.    </p>
]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;1.    配置第一块网卡，并设置为静态，要求模式为nat模式

a.图形化：用setup去调用图形化设置
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PS：eth0(相当于数组)DHCP为（＊）说明未配置，点击空格进行配置&lt;br&gt;    配置思路：192.168.71..0&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://www.craymc.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>python在eclipse下配置编码问题</title>
    <link href="http://www.craymc.com/2015/12/23/python%E5%9C%A8eclipse%E4%B8%8B%E9%85%8D%E7%BD%AE%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://www.craymc.com/2015/12/23/python在eclipse下配置编码问题/</id>
    <published>2015-12-23T10:08:45.000Z</published>
    <updated>2016-07-20T10:47:18.974Z</updated>
    
    <content type="html"><![CDATA[<p>Eclipse的设置</p>
<p>window-&gt;preferences-&gt;general-&gt;editors-&gt;text editors-&gt;spelling-&gt;encoding-&gt;UTF-8，编辑器的编码格式</p>
<p>window-&gt;preferences-&gt;workspace-&gt;text file encoding-&gt;UTF-8</p>
<p>打开eclipse安装目录-&gt;eclipse.ini，末行加上”-Dfile.encoding=UTF-8”<br><a id="more"></a></p>
<p>文件编码</p>
<p>py文件记得保存成UTF-8，文件首行加上”#coding=utf-8”   ，这一句话可控制代码中可输入中文字符</p>
<p>run时设置</p>
<p>run–&gt;run configurations-&gt;python run-&gt;Common-&gt; Encoding -&gt;UTF-8   ，这个应该是运行时的可解决中文乱码问题。更改空白模块默认显示# -<em>- coding: utf-8 -</em>-</p>
<p>如果想每次新建一个空模块时自动添加”# -<em>- coding: utf-8 -</em>-”   这样的一句话，可以通过window–Preferences–Pydev–Editor–Template–Empty，然后点击“Edit”按钮，把我们要添加的语句加进去就可以了，将事先默认的语句去掉，改写为：# -<em>- coding: utf-8 -</em>-  这样的一句话,然后你再新建一个空白模块，再也不需要每次都要复制那个编码语句了</p>
<p>当在建立的python项目时，输入的中文太细，可以通过</p>
<p>Window &gt; Preferences&gt;General&gt;Appearance&gt;Color and Fonts中的第一个来设置，Basic里面的TextFonts设置大小即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Eclipse的设置&lt;/p&gt;
&lt;p&gt;window-&amp;gt;preferences-&amp;gt;general-&amp;gt;editors-&amp;gt;text editors-&amp;gt;spelling-&amp;gt;encoding-&amp;gt;UTF-8，编辑器的编码格式&lt;/p&gt;
&lt;p&gt;window-&amp;gt;preferences-&amp;gt;workspace-&amp;gt;text file encoding-&amp;gt;UTF-8&lt;/p&gt;
&lt;p&gt;打开eclipse安装目录-&amp;gt;eclipse.ini，末行加上”-Dfile.encoding=UTF-8”&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://www.craymc.com/tags/python/"/>
    
  </entry>
  
</feed>
