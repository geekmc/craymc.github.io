<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>craymc</title>
  <subtitle>http://www.craymc.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.craymc.com/"/>
  <updated>2017-01-29T04:12:58.922Z</updated>
  <id>http://www.craymc.com/</id>
  
  <author>
    <name>craymc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解释器模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/解释器模式详解/</id>
    <published>2017-01-29T04:10:57.000Z</published>
    <updated>2017-01-29T04:12:58.922Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解释器模式详解"><a href="#解释器模式详解" class="headerlink" title="解释器模式详解"></a>解释器模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。"><a href="#定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。" class="headerlink" title="定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。"></a>定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</h4><hr>
<h4 id="理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。"><a href="#理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。" class="headerlink" title="理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。"></a>理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。</h4><hr>
<h4 id="解释器模式的结构与使用"><a href="#解释器模式的结构与使用" class="headerlink" title="解释器模式的结构与使用"></a>解释器模式的结构与使用</h4><p>解释器模式包括四种角色：</p>
<ul>
<li>抽象表达式：该角色为一个接口，负责定义抽象的解释操作。</li>
<li>终结符表达式：实现AbstracttExpression接口的类。该类接口中的解释操作实现为与文法中的终结符相关联的操作，既文法中每个终结符号需要一个TerminalExpression类。</li>
<li>非终结者符表达式：实现AbstractExpression接口的类。文法中是每一条规则都需要一个NonterminalExpression类。NonterminalExpression类为文法中的非终结符号实现解释器操作，该解释器操作通常使用递归表示哪些对象的解释操作。</li>
<li>上下文：包含解释器之外的一些全局信息。</li>
</ul>
<hr>
<h4 id="解释器模式的优点"><a href="#解释器模式的优点" class="headerlink" title="解释器模式的优点"></a>解释器模式的优点</h4><ul>
<li>将每一个语法规则表示成一个类，方便与实现简单的语言。</li>
<li>由于使用类表示语法规则，可以较容易改变或扩展语言的行为。</li>
<li>通过在类结构中加入新的方法，可以在解释的同时增加新的行为。</li>
</ul>
<hr>
<h4 id="适合使用解释模式的场景"><a href="#适合使用解释模式的场景" class="headerlink" title="适合使用解释模式的场景"></a>适合使用解释模式的场景</h4><h2 id="当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。"><a href="#当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。" class="headerlink" title="当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。"></a>当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。</h2><h4 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h4><p>使用解释器模式设计程序有三个步骤：</p>
<ul>
<li>解析出语句中的动作标记</li>
<li>将标记归纳为动作</li>
<li>执行动作</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h5 id="抽象表达式"><a href="#抽象表达式" class="headerlink" title="抽象表达式"></a>抽象表达式</h5><pre><code>public interface Node {
public void parse(Context context);
public void execute();
}
</code></pre><h5 id="终结符表达式"><a href="#终结符表达式" class="headerlink" title="终结符表达式"></a>终结符表达式</h5><pre><code>public class SubjectPronounOrNounNode implements Node {
String []word={&quot;you&quot;,&quot;He &quot;,&quot;Teacher&quot;,&quot;Student&quot;};
String token;
boolean boo;
@Override
public void parse(Context context) {
    token=context.nextToken();
    int i = 0;
    for (i = 0; i &lt; word.length; i++) {
        if(token.equalsIgnoreCase(word[i])){
            boo=true;
            break;
        }
    }
    if(i==word.length)
        boo=false;
            }

@Override
public void execute() {
        if(boo){
            if(token.equalsIgnoreCase(word[0]));
                System.out.println(&quot;你&quot;);
            if(token.equalsIgnoreCase(word[1]));
                System.out.println(&quot;它&quot;);
            if(token.equalsIgnoreCase(word[2]));
                System.out.println(&quot;老师&quot;);
            if(token.equalsIgnoreCase(word[3]));
                System.out.println(&quot;学生&quot;);
        }    else{
            System.out.println(token+&quot;(NO)&quot;);
        }

}


}

public class ObjectPronounOrNouNode implements Node {
    String []word={&quot;ME&quot;,&quot;Him&quot;,&quot;Tiger&quot;,&quot;Apple&quot;};
    String token;
    boolean boo;


    @Override
    public void parse(Context context) {
        token=context.nextToken();
        int i=0;
        for (i = 0; i &lt; word.length;i ++) {
            if(token.equalsIgnoreCase(word[i])){
                boo=true;
                break;
            }
        }
        if(i==word.length)
            boo=false;
}

@Override
public void execute() {
        if(boo){
        if(token.equalsIgnoreCase(word[0]));
            System.out.println(&quot;我&quot;);
        if(token.equalsIgnoreCase(word[1]));
            System.out.println(&quot;他&quot;);
        if(token.equalsIgnoreCase(word[2]));
            System.out.println(&quot;老虎&quot;);
        if(token.equalsIgnoreCase(word[3]));
            System.out.println(&quot;苹果&quot;);
    }    else{
        System.out.println(token+&quot;(NO)&quot;);
    }

}            
}

public class VerbNode implements Node {
String []word={&quot;Drink&quot;,&quot;Eat&quot;,&quot;Look&quot;,&quot;beat&quot;};
String token;
boolean boo;


@Override
public void parse(Context context) {
    token=context.nextToken();
    int i=0;
    for ( i = 0; i &lt; word.length; i++) {
        if(token.equalsIgnoreCase(word[i])){
            boo=true;
            break;
        }
    }
    if(i==word.length)
        boo=false;
}

@Override
public void execute() {
    if(boo){
        if(token.equalsIgnoreCase(word[0]));
        System.out.println(&quot;吃&quot;);
    if(token.equalsIgnoreCase(word[1]));
        System.out.println(&quot;喝&quot;);
    if(token.equalsIgnoreCase(word[2]));
        System.out.println(&quot;看&quot;);
    if(token.equalsIgnoreCase(word[3]));
        System.out.println(&quot;打&quot;);
}    else{
    System.out.println(token+&quot;(NO)&quot;);
}


    }


}
</code></pre><h5 id="非终结符表达式"><a href="#非终结符表达式" class="headerlink" title="非终结符表达式"></a>非终结符表达式</h5><pre><code>public class SentenceNode implements Node{

Node subjectNode,predicateNode;


@Override
public void parse(Context context) {
    subjectNode=new SubjectNode();
    predicateNode=new PredicateNode();
    subjectNode.parse(context);
    predicateNode.parse(context);
}

@Override
public void execute() {
    subjectNode.execute();
    predicateNode.execute();
}

}
public class SubjectNode implements Node {

Node node;

@Override
public void parse(Context context) {
    node=new SubjectPronounOrNounNode();
    node.parse(context);
}

@Override
public void execute() {
    node.execute();
}

}
public class PredicateNode implements Node {
Node verbNode,objectNode;

@Override
public void parse(Context context) {
    verbNode=new VerbNode();
    objectNode=new ObjectPronounOrNouNode();
    verbNode.parse(context);
    objectNode.parse(context);
}

@Override
public void execute() {
    verbNode.execute();
    objectNode.execute();
}

}
</code></pre><h5 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h5><pre><code>import java.util.StringTokenizer;

public class Context {
    StringTokenizer tokenizer;
    String token;
    public Context(String text) {
    setContext(text);
    }
    public void setContext(String text){
    tokenizer=new StringTokenizer(text);
    }
    String nextToken(){
        if(tokenizer.hasMoreTokens()){
        token=tokenizer.nextToken();
    }else
        token=&quot;&quot;;

    return token;

}
}
</code></pre><h5 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h5><pre><code>public class Application {
public static void main(String[] args) {
    String text=&quot;Teacher beat tiger&quot;;
    Context context=new Context(text);
    Node node=new SentenceNode();
    node.parse(context);
    node.execute();
    text=&quot;You eat apple&quot;;
    context.setContext(text);
    System.out.println();
    node.parse(context);
    node.execute();
    text=&quot;you look him&quot;;
    context.setContext(text);
    System.out.println();
    node.parse(context);
    node.execute();
}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;解释器模式详解&quot;&gt;&lt;a href=&quot;#解释器模式详解&quot; class=&quot;headerlink&quot; title=&quot;解释器模式详解&quot;&gt;&lt;/a&gt;解释器模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>备忘录模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/备忘录模式详解/</id>
    <published>2017-01-29T04:10:34.000Z</published>
    <updated>2017-01-29T04:13:37.223Z</updated>
    
    <content type="html"><![CDATA[<h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><h2 id="定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。"><a href="#定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。" class="headerlink" title="###　定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。"></a>###　定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。</h2><h4 id="理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。"><a href="#理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。" class="headerlink" title="理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。"></a>理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。</h4><hr>
<h4 id="核心：备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。"><a href="#核心：备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。" class="headerlink" title="核心：备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。"></a><strong>核心：</strong>备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>备忘录模式包括三种角色：</p>
<ul>
<li>原发者：需要在某个时刻保存其状态的对象。原发者负责创建备忘录，然后原发者使用该备忘录记录自己的状态。当原发者需要恢复某个时刻的状态时，它通过获得相应备忘录中的数据来恢复那个时刻的状态。</li>
<li>备忘录：负责存储原发者状态的对象，创建备忘录的类和创建原发者的类在同一个包中的类是实例才可以访问备忘录中的数据。</li>
<li>负责人：负责保管保存备忘录的对象。负责人如果需要将备忘录保存到磁盘，负责人可以使用对象流将备忘录写入文件。</li>
</ul>
<hr>
<h4 id="备忘录的优点"><a href="#备忘录的优点" class="headerlink" title="备忘录的优点"></a>备忘录的优点</h4><ul>
<li>备忘录模式使用备忘录可以把原发者的内部状态保存起来，使只有恨“亲密的”对象可以访问备忘录中的数据。</li>
<li>备忘录模式强调了类设计单一责任原则，既将状态的刻画和保存分开。</li>
</ul>
<hr>
<h4 id="使用备忘录模式的场景"><a href="#使用备忘录模式的场景" class="headerlink" title="使用备忘录模式的场景"></a>使用备忘录模式的场景</h4><ul>
<li>必须保存一个对象在某一时刻的全部或部分状态，以便在需要的时刻恢复该对象先前的状态。</li>
<li>一个对象不想通过提供public权限的，且想让其他对象得到自己的内部状态。</li>
</ul>
<hr>
<h5 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h5><h6 id="原发者"><a href="#原发者" class="headerlink" title="原发者"></a>原发者</h6><pre><code>import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

public class ReaderPhrase {
    long readPosition;
    File file;
    RandomAccessFile in;
    String phrase=null;
    public ReaderPhrase(File file) {
        this.file = file;
        try {
        in=new RandomAccessFile(file, &quot;r&quot;);

    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
}
public Memento createMemento(){
    Memento mem=new Memento();
    mem.setPositionState(readPosition);
    return mem;
}
public void restoreFromMemento(Memento mem){
    readPosition=mem.getPositionState();
}
public String readLine(){
    try {
        in.seek(readPosition);
        if(phrase!=null){
            byte b[]=phrase.getBytes(&quot;iso-8859-1&quot;);
            phrase=new String(b);
        }
        readPosition=in.getFilePointer();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return phrase;
}
public void closeRead(){
    try {
        in.close();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}

}
</code></pre><h6 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h6><pre><code>public class Memento implements java.io.Serializable{
        private long state;
        void setPositionState(long state){
        this.state=state;
        }
        long getPositionState(){
        return state;
        }

}
</code></pre><h6 id="负责人"><a href="#负责人" class="headerlink" title="负责人"></a>负责人</h6><pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class Caretaker {
File file;
private Memento memento=null;
public Caretaker() {
        file=new File(&quot;&quot;);
}
public Memento getMemento(){
    if(file.exists()){
        try {
            FileInputStream in=new FileInputStream(&quot;&quot;);
            ObjectInputStream inObject = null;
            try {
                inObject = new ObjectInputStream(in);
            } catch (IOException e1) {
                // TODO Auto-generated catch block
                e1.printStackTrace();
            }
            try {
                try {
                    memento=(Memento) inObject.readObject();
                } catch (ClassNotFoundException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }
    return memento;
}
public void saveMemento(Memento memento) {
    FileOutputStream out = null;
    try {
        out = new FileOutputStream(&quot;&quot;);
    } catch (FileNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    try {
        ObjectOutputStream outObject=new ObjectOutputStream(out);
        outObject.writeObject(memento);
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}

}
</code></pre><h6 id="模式的使用"><a href="#模式的使用" class="headerlink" title="模式的使用"></a>模式的使用</h6><pre><code>import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.Scanner;


public class Application {
    public static void main(String[] args) {
        Scanner reader=new Scanner(System.in);
        ReaderPhrase readerPhrase=new ReaderPhrase(new File(&quot;&quot;));
        File favorPhrase=new File(&quot;&quot;);
        RandomAccessFile out =null;
        try {
            out= new RandomAccessFile(favorPhrase, &quot;rw&quot;);

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Y or N&quot;);
        String answer=reader.nextLine();
        if(answer.startsWith(&quot;y&quot;)||answer.startsWith(&quot;Y&quot;)){
            Caretaker caretaker=new Caretaker();
            Memento memento=caretaker.getMemento();
            if(memento!=null)
                readerPhrase.restoreFromMemento(memento);
        }
            String phrase=null;
            while((phrase=readerPhrase.readLine())!=null){
                System.out.println(phrase);
                System.out.println();
                answer=reader.nextLine();
                if(answer.startsWith(&quot;y&quot;)||answer.startsWith(&quot;Y&quot;)){
                    try {
                        out.seek(favorPhrase.length());
                        byte []b=phrase.getBytes();
                        out.write(b);
                        out.writeChar(&apos;\n&apos;);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&quot;Y or Y&quot;);
                    answer=reader.nextLine();
                    if(answer.startsWith(&quot;y&quot;)||answer.startsWith(&quot;Y&quot;))
                        continue;
                    else{
                        readerPhrase.closeRead();
                        Caretaker caretaker=new Caretaker();
                        caretaker.saveMemento(readerPhrase.createMemento());

                        try {
                                out.close();

                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        System.exit(0);;
                    }
                }
                System.out.println(&quot;OK&quot;);
            }
}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;h2 id=&quot;定义：在
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>享元模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/享元模式详解/</id>
    <published>2017-01-29T04:10:15.000Z</published>
    <updated>2017-01-29T04:14:09.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：运用共享技术有效地支持大量细粒度的对象。"><a href="#定义：运用共享技术有效地支持大量细粒度的对象。" class="headerlink" title="定义：运用共享技术有效地支持大量细粒度的对象。"></a>定义：运用共享技术有效地支持大量细粒度的对象。</h3><hr>
<h4 id="理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。"><a href="#理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。" class="headerlink" title="理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。"></a>理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。</h4><hr>
<h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>享元模式包括三种角色：</p>
<ul>
<li>享元接口：是一个接口，该接口定义了享元对外公开其内部数据的方法，以及享元接收外部数据的方法。</li>
<li>具体享元：实现享元接口的类，该类的实例称为享元对象，或简称享元。具体享元类的成员变量为享元对象的应用程序无法更改享元的内部状态，只有这样才能使得享元对象在系统中被共享。因为享元对象是用来共享的，所以不能允许用户各自地使用具体享元类来创建的对象显然是不同的，所以，具体享元类的构造方法必须是private的，其目的是不允许用户程序直接使用具体享元类创建享元对象，创建和管理享元对象由享元工厂负责。</li>
<li>享元工厂：享元工厂是一个类，该类的实例负责创建和管理享元对象，用户或其他对象必须请求享元工厂为它得到一个享元对象，当用户程序或其他若干个对象向享元对象，用户或其他对象必须请求享元对象，当用户程序或其他若干个对象向享元对象提供给请求者，否则就创建一个享元对象添加到散列表中，同时将该享元对象提供给请求者。显然，当若干个用户或对象请求享元工厂提供一个享元对象时，第一个用户获得该享元对象的时间可能慢一些，但是后继的用户会较快地获得这个享元对象。可以使用单列模式来设计享元工厂，既让系统中只有一个享元工厂的实例。另外，为了让享元工厂能生成享元对象，需要将具体享元类作为享元工厂的内部类。</li>
</ul>
<hr>
<h4 id="享元模式的优点"><a href="#享元模式的优点" class="headerlink" title="享元模式的优点"></a>享元模式的优点</h4><ul>
<li>使用享元可以节省内存的开销，特别适合处理大量细粒度对象，这些对象的许多属性值是相同的，而且一旦创建则不容许修改。</li>
<li>享元模式中的享元可以使用方法的参数接收外部状态中的数据，但外部状态数据不会干扰到享元中的内部数据，这就使享元可以在不同的环境中被共享。</li>
</ul>
<hr>
<h4 id="适合享元模式的场景"><a href="#适合享元模式的场景" class="headerlink" title="适合享元模式的场景"></a>适合享元模式的场景</h4><ul>
<li>一个应用程序使用大量的对象，这些对象之间部分属性本质上是相同的，这时应使用享元来封装相同的部分。</li>
<li>对象的多数状态都可变为外部状态，就可以考虑将这样对象作为系统中的享元来使用。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h5 id="享元接口"><a href="#享元接口" class="headerlink" title="享元接口"></a>享元接口</h5><pre><code>public interface Flyweight {
    public double getHeight();
    public double getWidth();
    public double getLength();
    public void printMess(String mess);
}
</code></pre><h5 id="享元工厂与具体享元"><a href="#享元工厂与具体享元" class="headerlink" title="享元工厂与具体享元"></a>享元工厂与具体享元</h5><pre><code>import java.util.HashMap;

public class FlyweightFactory {
        private HashMap&lt;String, Flyweight&gt; hashMap;
        static FlyweightFactory factory=new FlyweightFactory();
        private FlyweightFactory(){
            hashMap=new HashMap&lt;String,Flyweight&gt;();
        }
        public static FlyweightFactory getFactory(){
            return factory;
        }
        public synchronized Flyweight getFlyweight(String key){
            if(hashMap.containsKey(key))
                return hashMap.get(key);
            else{
                    double width=0,height=0,length=0;
                    String []str=key.split(&quot;#&quot;);
                    width=Double.parseDouble(str[0]);
                    height=Double.parseDouble(str[1]);
                    length=Double.parseDouble(str[2]);
                    Flyweight ft= new ConcreFlyweight(width, height, length);
                    hashMap.put(key, ft);
                    return ft;
                }
}
class ConcreFlyweight implements Flyweight{

    private double width;
    private double height;
    private double length;


    private ConcreFlyweight(double width, double height, double length) {
    this.width = width;
    this.height = height;
    this.length = length;
    }

    @Override
    public double getHeight() {

        return height;
    }

    @Override
    public double getWidth() {

        return width;
    }

    @Override
    public double getLength() {

    return length;
    }

    @Override
    public void printMess(String mess) {
        System.out.println(mess);
        System.out.println(&quot;宽度：&quot;+width);
        System.out.println(&quot;高度：&quot;+height);
        System.out.println(&quot;长度：&quot;+length);
    }
}
}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>public class Car {
    Flyweight flyweight;
    String name,color;
    int power;
    public Car(Flyweight flyweight, String name, String color, int power) {
    super();
    this.flyweight = flyweight;
    this.name = name;
    this.color = color;
    this.power = power;
    }
    public void print(){
        System.out.println(&quot;名称：&quot;+name);
        System.out.println(&quot;颜色：&quot;+color);
        System.out.println(&quot;功率：&quot;+power);
        System.out.println(&quot;宽度：&quot;+flyweight.getWidth());
        System.out.println(&quot;高度:&quot;+flyweight.getHeight());
        System.out.println(&quot;长度:&quot;+flyweight.getLength());
    }

}

public class Application {

    public static void main(String[] args) {

        FlyweightFactory factory=FlyweightFactory.getFactory();

        double width=1.82,height=1.47,length=5.12;

        String key=&quot;&quot;+width+&quot;#&quot;+height+&quot;#&quot;+length;

        Flyweight flyweight=factory.getFlyweight(key);

        Car audiA6One=new Car(flyweight, &quot;奥迪&quot;, &quot;黑色&quot;, 128);

        Car audiA6Two=new Car(flyweight, &quot;奥迪&quot;, &quot;灰色&quot;, 160);

        audiA6One.print();
        audiA6Two.print();

        width=1.77;
        height=1.45;
        length=4.63;

        key=&quot;&quot;+width+&quot;#&quot;+height+&quot;#&quot;+length;

        flyweight=factory.getFlyweight(key);

        Car audiA4One=new Car(flyweight, &quot;A4&quot;, &quot;蓝色&quot;, 126);
        Car audiA4Two=new Car(flyweight, &quot;A4&quot;, &quot;红色&quot;, 138);

        flyweight.printMess(&quot;名称：奥迪A6：颜色：蓝色 功率：126&quot;);
        flyweight.printMess(&quot;名称：A4 颜色：红色 功率：138&quot;);


    }

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;headerlink&quot; title=&quot;享元模式&quot;&gt;&lt;/a&gt;享元模式&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/访问者模式详解/</id>
    <published>2017-01-29T04:09:46.000Z</published>
    <updated>2017-01-29T04:14:33.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="访问者模式详解"><a href="#访问者模式详解" class="headerlink" title="访问者模式详解"></a>访问者模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：-表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。"><a href="#定义：-表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。" class="headerlink" title="定义： 表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。"></a>定义： 表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。</h4><hr>
<h4 id="理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。"><a href="#理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。" class="headerlink" title="理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。"></a>理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>访问者模式包括五种角色：</p>
<ul>
<li>抽象元素：一个抽象类，该类定义了接收访问者的accept操作。</li>
<li>具体元素：element的子类。</li>
<li>对象结构：一个集合，用于存放element对象，提供遍历它自己的方法。</li>
<li>抽象访问者：一个接口，该接口定义操作对象的方法。</li>
<li>具体访问者：实现visitot接口的类。</li>
</ul>
<hr>
<h4 id="双重分流"><a href="#双重分流" class="headerlink" title="双重分流"></a>双重分流</h4><h2 id="访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。"><a href="#访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。" class="headerlink" title="访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。"></a>访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。</h2><h4 id="访问者模式的优点"><a href="#访问者模式的优点" class="headerlink" title="访问者模式的优点"></a>访问者模式的优点</h4><ul>
<li>可以在不改变一个集合中元素的类的情况下，增加新的施加于该元素上新操作、</li>
<li>可以将集合中各个元素的某些操作集中到访问者中，不仅便于集合的维护，也有利于集合中元素的复用。</li>
</ul>
<hr>
<h4 id="适合访问者的场景"><a href="#适合访问者的场景" class="headerlink" title="适合访问者的场景"></a>适合访问者的场景</h4><ul>
<li>一个对象结构中，比如某个集合中，包含很多对象，想对集合中的对象增加一些新的操作。</li>
<li>需要对集合中的对象进行很多不同的并且不相关的操作，而不仅不想修改对象的类，就可以使用访问者模式。访问者模式可以在visitor类中集中定义了<br>一些关于集合中对象的操作。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;访问者模式详解&quot;&gt;&lt;a href=&quot;#访问者模式详解&quot; class=&quot;headerlink&quot; title=&quot;访问者模式详解&quot;&gt;&lt;/a&gt;访问者模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>桥接模式</title>
    <link href="http://www.craymc.com/2017/01/29/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.craymc.com/2017/01/29/桥接模式/</id>
    <published>2017-01-29T04:09:22.000Z</published>
    <updated>2017-01-29T04:14:55.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="桥接模式详解"><a href="#桥接模式详解" class="headerlink" title="桥接模式详解"></a>桥接模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<p>[author：craymc][anchor-id]</p>
<h3 id="定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。"><a href="#定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。" class="headerlink" title="定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。"></a>定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。</h3><hr>
<h4 id="理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。"><a href="#理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。" class="headerlink" title="理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。"></a>理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。</h4><h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>桥接模式包括四种角色：</p>
<ul>
<li>抽象：是一个抽象类，该抽象类含有implementor声明的变量，既维护一个implemnentor类型对象。</li>
<li>实现者：实现者角色是一个接口，该接口中的方法不一定与abstract类中的方法一致。implementor接口负责定义基本操作，而abstract类负责定义基于这些基本操作的较高层次的操作。</li>
<li>细化抽象：是抽象角色的一个子类，该子类在重写抽象角色中的抽象方法时，在给出一些必要的操作后，将委托所维护implementor类型对象调用相应的方法。</li>
<li>具体实现者：是实现implementor接口的类。</li>
</ul>
<hr>
<h3 id="桥接模式的优点"><a href="#桥接模式的优点" class="headerlink" title="桥接模式的优点"></a>桥接模式的优点</h3><ul>
<li>桥接模式分离实现与抽象，使抽象和实现可以独立的扩展。当修改实现的代码时，不影响抽象的代码，反之也一样。</li>
<li>满足开-闭模式。抽象和实现者处于同层次，使系统可独立地扩展者两个层次。增加新的具体实现者，不需要修改细化抽象，反之增加新的细化抽象也不需要修改具体实现。</li>
</ul>
<hr>
<h3 id="适合桥接模式的情景"><a href="#适合桥接模式的情景" class="headerlink" title="适合桥接模式的情景"></a>适合桥接模式的情景</h3><ul>
<li>不想让抽象和某些重要的实现代码是固定的绑定关系，这部分实现可运行时动态决定。</li>
<li>抽象和实现者都可以继承的方式独立地扩充而互不影响，程序在运行期间可能需要动态的将一个抽象的子类的实例与一个实现者的子类的实例进行组合。</li>
<li>希望对实现者层次代码的修改对抽象层不产生影响，既抽象层的代码不必重新编译，反之亦然。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><hr>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>   public abstract class ArchitectureCore {<br>    BuildingDesign design;<br>    double unitPrice;<br>    public abstract double giveCost();</p>
<pre><code>}
</code></pre><h4 id="实现者"><a href="#实现者" class="headerlink" title="实现者"></a>实现者</h4><pre><code>public interface BuildingDesign {
    public double computerArea();
}
</code></pre><h4 id="细化抽象"><a href="#细化抽象" class="headerlink" title="细化抽象"></a>细化抽象</h4><pre><code>public class BuildingCost extends ArchitectureCore{
public BuildingCost(BuildingDesign design,double unitPrice) {
        this.design=design;
        this.unitPrice=unitPrice;
}



@Override
public double giveCost() {
    double area=design.computerArea();
    return area*unitPrice;
}

}
</code></pre><h4 id="具体实现者"><a href="#具体实现者" class="headerlink" title="具体实现者"></a>具体实现者</h4><pre><code>public class HouseDesign implements BuildingDesign{
double width,length;
int floorNumber;


public HouseDesign(double width, double length, int floorNumber) {
    this.width = width;
    this.length = length;
    this.floorNumber = floorNumber;
}


@Override
public double computerArea() {

    return width*length*floorNumber;
}

}
</code></pre><h4 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h4><pre><code>public class Application {
public static void main(String[] args) {
    double width=63,height=30;
    int floorNumber=8;
    double unitPrice=6867.38;
    BuildingDesign design=new HouseDesign(width, height, floorNumber);
    System.out.println(&quot;宽&quot;+width+&quot;米，高&quot;+height+&quot;米，层数为：&quot;+floorNumber);
    ArchitectureCore cost=new BuildingCost(design, unitPrice);
    double price=cost.giveCost();
    System.out.printf(&quot;每平方米造价为：&quot;+unitPrice+&quot;元的商业楼的建设成本：%.2f\n&quot;,price);
    width=50;
    height=28;
    floorNumber=6;
    unitPrice=2687.88;
    design=new HouseDesign(width, height, floorNumber);
    System.out.printf(&quot;宽&quot;+width+&quot;米，高&quot;+height+&quot;米，层数为&quot;+floorNumber);

    cost=new BuildingCost(design, unitPrice);
    price=cost.giveCost();
    System.out.printf(&quot;每平方米造价&quot;+unitPrice+&quot;元的住宅楼的建设成本%.2f\n&quot;,price);

}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;桥接模式详解&quot;&gt;&lt;a href=&quot;#桥接模式详解&quot; class=&quot;headerlink&quot; title=&quot;桥接模式详解&quot;&gt;&lt;/a&gt;桥接模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/代理模式详解/</id>
    <published>2017-01-29T04:08:58.000Z</published>
    <updated>2017-01-29T04:15:25.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代理模式详解"><a href="#代理模式详解" class="headerlink" title="代理模式详解"></a>代理模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：为其他对象提供一种代理以控制对这个对象的访问。"><a href="#定义：为其他对象提供一种代理以控制对这个对象的访问。" class="headerlink" title="定义：为其他对象提供一种代理以控制对这个对象的访问。"></a>定义：为其他对象提供一种代理以控制对这个对象的访问。</h4><hr>
<h4 id="理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。"><a href="#理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。" class="headerlink" title="理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。"></a>理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。</h4><hr>
<h4 id="代理的特点是：它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。"><a href="#代理的特点是：它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。" class="headerlink" title="代理的特点是：它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。"></a>代理的特点是：<strong>它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。</strong></h4><hr>
<h4 id="代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。"><a href="#代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。" class="headerlink" title="代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。"></a>代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。</h4><hr>
<h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>代理模式包括三种角色</p>
<ul>
<li>抽象主题：是一个接口，该接口是对象和它的代理所共用的接口。</li>
<li>实际主题：实际主题是实现抽象主题接口的类。实际主题的实例是代理角色实例所要代理的对象。</li>
<li>代理：代理是实现抽象主题接口的类。代理含有主题接口声明的变量，该变量用来存放realSubject角色的实例引用，这样一来，代理的实例就可以控制对它所包含的realSubject角色的实例访问，既可以控制对它所代理对象的访问。</li>
</ul>
<hr>
<p>####　代理模式的优点</p>
<ul>
<li>代理模式可以屏蔽用户真正请求的对象，使用户程序和真正的对象之间解耦。</li>
<li><p>使用代理来担当哪些创建耗时的对象的替身。</p>
<h4 id="适合代理模式的场景"><a href="#适合代理模式的场景" class="headerlink" title="适合代理模式的场景"></a>适合代理模式的场景</h4></li>
<li><p>程序可能不希望用户直接访问该对象，而是提供一个特殊的对象以控制当前对象的访问</p>
</li>
<li>如果一个对象需要很长时间才能加载完成。</li>
<li>如果对象位于远程主机上，需要为用户提供访问该远程对象的能力。</li>
</ul>
<hr>
<h5 id="代码模式"><a href="#代码模式" class="headerlink" title="代码模式"></a>代码模式</h5><h6 id="抽象主题"><a href="#抽象主题" class="headerlink" title="抽象主题"></a>抽象主题</h6><pre><code>public interface Geometry {
    public double getArea();

}
</code></pre><h6 id="具体模板"><a href="#具体模板" class="headerlink" title="具体模板"></a>具体模板</h6><pre><code>public class Triangle implements Geometry{
 double sideA,sideB,sideC,area;


public Triangle(double sideA, double sideB, double sideC) {
    this.sideA = sideA;
    this.sideB = sideB;
    this.sideC = sideC;
}


@Override
public double getArea() {
    double p=(sideA+sideB+sideC)/2.0;
    area=Math.sqrt(p*(p-sideA)*(p-sideB)*(p-sideC));
    return area;
}

}
</code></pre><h6 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h6><pre><code>public class TriangleProxy implements Geometry{
double sideA,sideB,sideC;
Triangle Triangle;
public void setABC(double a,double b,double c){
    sideA=a;
    sideB=b;
    sideC=c;
}
@Override
public double getArea() {
    if(sideA+sideB&gt;sideC&amp;&amp;sideA+sideC&gt;sideB&amp;&amp;sideB+sideC&gt;sideA){
        Triangle=new Triangle(sideA, sideB, sideC);
        double area=Triangle.getArea();
        return area;
    }else{
        return -1;
    }
}

}
</code></pre><h6 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h6><pre><code>import java.util.Scanner;

public class Application {
    public static void main(String[] args) {
        Scanner reader=new Scanner(System.in);
        System.out.println(&quot;请输入按个数&quot;);
        double a=-1,b=-1,c=-1;
        a=reader.nextDouble();
        b=reader.nextDouble();
        c=reader.nextDouble();
        TriangleProxy proxy=new TriangleProxy();
        proxy.setABC(a, b, c);
        double area=proxy.getArea();
        System.out.println(&quot;面积是：&quot;+area);
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代理模式详解&quot;&gt;&lt;a href=&quot;#代理模式详解&quot; class=&quot;headerlink&quot; title=&quot;代理模式详解&quot;&gt;&lt;/a&gt;代理模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>状态模式详解</title>
    <link href="http://www.craymc.com/2017/01/26/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/26/状态模式详解/</id>
    <published>2017-01-26T14:05:31.000Z</published>
    <updated>2017-01-26T14:07:09.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="状态模式详解"><a href="#状态模式详解" class="headerlink" title="状态模式详解"></a>状态模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。"><a href="#定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。" class="headerlink" title="定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。"></a>定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</h3><hr>
<h4 id="理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。核心：状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。"><a href="#理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。核心：状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。" class="headerlink" title="理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。核心：状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。"></a>理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。<strong>核心：</strong>状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。</h4><hr>
<h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>状态模式包括三种角色：</p>
<ul>
<li>环境：环境是一个类，该类含有抽象状态声明的变量，可以引用任何具体状态类的实例。用户对该环境类的实例在某种状态下的行为感兴趣。</li>
<li>抽象状态：抽象状态是一个接口或抽象类。抽象状态中定义了与环境的一个特定状态相关的若干个方法。</li>
<li>具体状态：具体状态是实现抽象状态的类。</li>
</ul>
<hr>
<h4 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h4><h2 id="环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。"><a href="#环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。" class="headerlink" title="环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。"></a>环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。</h2><h4 id="状态模式的优点"><a href="#状态模式的优点" class="headerlink" title="状态模式的优点"></a>状态模式的优点</h4><ul>
<li>使用一个类封装对象的一种状态，很容易增加 新的状态。</li>
<li>在状态模式中，环境中不必出现大量的条件判断语句。环境实例所呈现的状态变得更加清晰，容易理解。</li>
<li>使用状态模式可以让用户程序很方便地切换环境实例状态。</li>
<li>使用状态模式不会让环境的实例中出现内部状态不一致的情况。</li>
<li>当前对象没有实例变量时，环境的各个实例可以共享一个状态对象。</li>
</ul>
<hr>
<h4 id="适合使用状态模式的情景"><a href="#适合使用状态模式的情景" class="headerlink" title="适合使用状态模式的情景"></a>适合使用状态模式的情景</h4><ul>
<li>一个对象的行为依赖于它的状态，并且它必须在运行时根据状态改变它的行为。</li>
<li>需要编写大量的条件分支语句来决定一个操作的行为，而且这些条件恰好表示对象的一种状态。</li>
</ul>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><pre><code>public class Thermometer {
  TempreatureState state;
   public void showMessage(){
    System.out.println(&quot;****&quot;);
    state.showTemperature();
    System.out.println(&quot;*****&quot;);
}
public void setState(TempreatureState state){
    this.state=state;
}

}
</code></pre><h5 id="抽象状态"><a href="#抽象状态" class="headerlink" title="抽象状态"></a>抽象状态</h5><pre><code>public interface TempreatureState {
public void showTemperature();

 }
</code></pre><h5 id="具体状态"><a href="#具体状态" class="headerlink" title="具体状态"></a>具体状态</h5><pre><code>public class LowState implements TempreatureState {
  double n=0;


  public LowState(double n) {
    if(n&lt;=0)
    this.n = n;
   }


@Override
public void showTemperature() {
        System.out.println(&quot;现在的温度是&quot;+n+&quot;属于低温度&quot;);
}

}

public class MiddleState implements TempreatureState{
double n=15;



public MiddleState(int n) {
    if(n&gt;0&amp;&amp;n&lt;26)
    this.n = n;
}



@Override
public void showTemperature() {
    System.out.println(&quot;现在是温度是&quot;+n+&quot;属于正常温度&quot;);
}

}


public class HeightState implements TempreatureState{
   double n=39;


   public HeightState(double n) {
    if(n&gt;39)
    this.n = n;
    }


    @Override
    public void showTemperature() {
    System.out.println(&quot;现在温度是&quot;+n+&quot;属于高温&quot;);
     }

}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>public class Application {
    public static void main(String[] args) {

            TempreatureState state=new LowState(-12);
            Thermometer thermometer=new Thermometer();

            thermometer.setState(state);
            thermometer.showMessage();

            state=new MiddleState(20);
            thermometer.setState(state);
            thermometer.showMessage();

            state=new HeightState(39);
            thermometer.setState(state);
            thermometer.showMessage();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;状态模式详解&quot;&gt;&lt;a href=&quot;#状态模式详解&quot; class=&quot;headerlink&quot; title=&quot;状态模式详解&quot;&gt;&lt;/a&gt;状态模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法详解</title>
    <link href="http://www.craymc.com/2017/01/26/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/26/模板方法详解/</id>
    <published>2017-01-26T14:04:55.000Z</published>
    <updated>2017-01-26T14:06:42.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模板方法详解"><a href="#模板方法详解" class="headerlink" title="模板方法详解"></a>模板方法详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h2 id="定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。"><a href="#定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。" class="headerlink" title="###　定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。"></a>###　定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。</h2><h4 id="理解：-类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。"><a href="#理解：-类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。" class="headerlink" title="理解： 类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。"></a>理解： 类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。</h4><h4 id="核心：模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象-类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。"><a href="#核心：模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象-类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。" class="headerlink" title="核心：模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象 类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。"></a><strong>核心：</strong>模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象 类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。</h4><h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>模板方法模式包括两种角色：</p>
<ul>
<li>抽象模板：抽象模板是一个抽象类。抽象模板定义了若干个方法来表示一个算法的各个步骤，这些方法中有抽象方法也有非抽象方法，其中的抽象方法称作<br>原语操作。更重要的一点是，抽象模板中还定义了一个称作模板方法的方法，该方法不仅包含有抽象模板中表示算法步骤的方法调用，而且也可以包含有定义在抽象模板中的其他对象方法调用，既模板方法定义了算法骨架。</li>
<li>具体模板：具体模板是抽象模板的子类，实现抽象模板中的原语操作。</li>
</ul>
<hr>
<h4 id="模板方法模式的优点："><a href="#模板方法模式的优点：" class="headerlink" title="模板方法模式的优点："></a>模板方法模式的优点：</h4><ul>
<li>可以通过在抽象模板定义模板方法给出成熟的算法步骤，同时又不限制步骤的细节，具体模板实现算法细节不会改变整个算法的骨架。</li>
<li>在抽象模板模式中，可以通过钩子方法对 某些步骤进行挂钩，具体模板通过钩子可以选择算法骨架中的某些步骤。</li>
</ul>
<hr>
<h4 id="适合模板方法模式的场景："><a href="#适合模板方法模式的场景：" class="headerlink" title="适合模板方法模式的场景："></a>适合模板方法模式的场景：</h4><ul>
<li>设计者需要给出一个算法的固定步骤，并将某些步骤的具体实现留给子类来实现。</li>
<li>需要对代码进行重构，将各个子类公共行为提取出来集中到一个共同的父类中以避免代码重复。</li>
</ul>
<hr>
<h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><h5 id="抽象模板"><a href="#抽象模板" class="headerlink" title="抽象模板"></a>抽象模板</h5><pre><code> import java.io.File;

public abstract class AbstractTemplate {  
   File[]allFile;
   File dir;
   public AbstractTemplate(File dir) {
    this.dir = dir;
    }
   public final void showFileName(){
    allFile=dir.listFiles();
    sort();
    printFiles();
    }
   public abstract void printFiles();
   public abstract void sort();

}
</code></pre><h5 id="具体模板"><a href="#具体模板" class="headerlink" title="具体模板"></a>具体模板</h5><pre><code>import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ConcreteTemplatel extends AbstractTemplate {


   public ConcreteTemplatel(File dir) {
    super(dir);
    }

    @Override
    public void printFiles() {
        for (int i = 0; i &lt; allFile.length; i++) {
            long time=allFile[i].lastModified();
            Date date=new Date();
            SimpleDateFormat matter=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            String name=allFile[i].getName();
            int k=i+1;
            System.out.println(k+&quot; &quot;+name+&quot;(&quot;+name+&quot;)&quot;);
    }

}

    @Override
    public void sort() {
        for (int i = 0; i &lt; allFile.length; i++) {
            for (int j = i+1; j &lt; allFile.length; j++) {
                if(allFile[j].lastModified()&lt;allFile[i].lastModified()){
                    File file=allFile[j];
                    allFile[j]=allFile[i];
                    allFile[i]=file;
            }
        }
    }

}
}

import java.io.File;

public class ConcreteTemplate2  extends AbstractTemplate{

    public ConcreteTemplate2(File dir) {
    super(dir);
    }

    @Override
    public void printFiles() {
        for (int i = 0; i &lt; allFile.length; i++) {
            long fileSize=allFile[i].length();
            String name=allFile[i].getName();
            int k=i+1;
            System.out.println(k+&quot; &quot;+name+&quot;(&quot;+fileSize+&quot;字节&quot;);
        }
}

    @Override
    public void sort() {
        for (int i = 0; i &lt; allFile.length; i++) {
            for (int j = i+1; j &lt; allFile.length; j++) {
                if(allFile[j].length()&lt;allFile[i].length()){
                    File file=allFile[j];
                    allFile[j]=allFile[i];
                    allFile[i]=file;
            }
        }
    }
}

}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>import java.io.File;

public class Application {
    public static void main(String[] args) {
            File dir=new File(&quot;路径&quot;);
            AbstractTemplate template=new ConcreteTemplatel(dir);
            System.out.println(dir.getPath()+&quot;目录下的文件：&quot;);
            template.showFileName();
            template=new ConcreteTemplate2(dir);
            System.out.println(dir.getPath()+&quot;目录下的文件：&quot;);
            template.showFileName();


    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模板方法详解&quot;&gt;&lt;a href=&quot;#模板方法详解&quot; class=&quot;headerlink&quot; title=&quot;模板方法详解&quot;&gt;&lt;/a&gt;模板方法详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>桥接模式详解</title>
    <link href="http://www.craymc.com/2017/01/25/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/25/桥接模式详解/</id>
    <published>2017-01-25T12:11:29.000Z</published>
    <updated>2017-01-25T13:50:32.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="桥接模式详解"><a href="#桥接模式详解" class="headerlink" title="桥接模式详解"></a>桥接模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。"><a href="#定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。" class="headerlink" title="定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。"></a>定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。</h3><hr>
<h4 id="理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。"><a href="#理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。" class="headerlink" title="理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。"></a>理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。</h4><h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>桥接模式包括四种角色：</p>
<ul>
<li>抽象：是一个抽象类，该抽象类含有implementor声明的变量，既维护一个implemnentor类型对象。</li>
<li>实现者：实现者角色是一个接口，该接口中的方法不一定与abstract类中的方法一致。implementor接口负责定义基本操作，而abstract类负责定义基于这些基本操作的较高层次的操作。</li>
<li>细化抽象：是抽象角色的一个子类，该子类在重写抽象角色中的抽象方法时，在给出一些必要的操作后，将委托所维护implementor类型对象调用相应的方法。</li>
<li>具体实现者：是实现implementor接口的类。</li>
</ul>
<hr>
<h3 id="桥接模式的优点"><a href="#桥接模式的优点" class="headerlink" title="桥接模式的优点"></a>桥接模式的优点</h3><ul>
<li>桥接模式分离实现与抽象，使抽象和实现可以独立的扩展。当修改实现的代码时，不影响抽象的代码，反之也一样。</li>
<li>满足开-闭模式。抽象和实现者处于同层次，使系统可独立地扩展者两个层次。增加新的具体实现者，不需要修改细化抽象，反之增加新的细化抽象也不需要修改具体实现。</li>
</ul>
<hr>
<h3 id="适合桥接模式的情景"><a href="#适合桥接模式的情景" class="headerlink" title="适合桥接模式的情景"></a>适合桥接模式的情景</h3><ul>
<li>不想让抽象和某些重要的实现代码是固定的绑定关系，这部分实现可运行时动态决定。</li>
<li>抽象和实现者都可以继承的方式独立地扩充而互不影响，程序在运行期间可能需要动态的将一个抽象的子类的实例与一个实现者的子类的实例进行组合。</li>
<li>希望对实现者层次代码的修改对抽象层不产生影响，既抽象层的代码不必重新编译，反之亦然。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><hr>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>   public abstract class ArchitectureCore {<br>    BuildingDesign design;<br>    double unitPrice;<br>    public abstract double giveCost();</p>
<pre><code>}
</code></pre><h4 id="实现者"><a href="#实现者" class="headerlink" title="实现者"></a>实现者</h4><pre><code>public interface BuildingDesign {
    public double computerArea();
}
</code></pre><h4 id="细化抽象"><a href="#细化抽象" class="headerlink" title="细化抽象"></a>细化抽象</h4><pre><code>public class BuildingCost extends ArchitectureCore{
public BuildingCost(BuildingDesign design,double unitPrice) {
        this.design=design;
        this.unitPrice=unitPrice;
}



@Override
public double giveCost() {
    double area=design.computerArea();
    return area*unitPrice;
}

}
</code></pre><h4 id="具体实现者"><a href="#具体实现者" class="headerlink" title="具体实现者"></a>具体实现者</h4><pre><code>public class HouseDesign implements BuildingDesign{
double width,length;
int floorNumber;


public HouseDesign(double width, double length, int floorNumber) {
    this.width = width;
    this.length = length;
    this.floorNumber = floorNumber;
}


@Override
public double computerArea() {

    return width*length*floorNumber;
}

}
</code></pre><h4 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h4><pre><code>public class Application {
public static void main(String[] args) {
    double width=63,height=30;
    int floorNumber=8;
    double unitPrice=6867.38;
    BuildingDesign design=new HouseDesign(width, height, floorNumber);
    System.out.println(&quot;宽&quot;+width+&quot;米，高&quot;+height+&quot;米，层数为：&quot;+floorNumber);
    ArchitectureCore cost=new BuildingCost(design, unitPrice);
    double price=cost.giveCost();
    System.out.printf(&quot;每平方米造价为：&quot;+unitPrice+&quot;元的商业楼的建设成本：%.2f\n&quot;,price);
    width=50;
    height=28;
    floorNumber=6;
    unitPrice=2687.88;
    design=new HouseDesign(width, height, floorNumber);
    System.out.printf(&quot;宽&quot;+width+&quot;米，高&quot;+height+&quot;米，层数为&quot;+floorNumber);

    cost=new BuildingCost(design, unitPrice);
    price=cost.giveCost();
    System.out.printf(&quot;每平方米造价&quot;+unitPrice+&quot;元的住宅楼的建设成本%.2f\n&quot;,price);

}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;桥接模式详解&quot;&gt;&lt;a href=&quot;#桥接模式详解&quot; class=&quot;headerlink&quot; title=&quot;桥接模式详解&quot;&gt;&lt;/a&gt;桥接模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>组合模式详解</title>
    <link href="http://www.craymc.com/2017/01/25/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/25/组合模式详解/</id>
    <published>2017-01-25T12:08:18.000Z</published>
    <updated>2017-01-25T14:12:30.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组合模式详解"><a href="#组合模式详解" class="headerlink" title="组合模式详解"></a>组合模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使用户对单个对象和组合对象的使用具有一致性。"><a href="#定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使用户对单个对象和组合对象的使用具有一致性。" class="headerlink" title="定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使用户对单个对象和组合对象的使用具有一致性。"></a>定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使用户对单个对象和组合对象的使用具有一致性。</h3><hr>
<h3 id="理解：如果一个对象包含另一个对象的引用，称这样的对象为组合对象。如果将当前组合对象作为一个整体的话，那么它所包含的对象就是整体的一部分。如果一个对象不含有其他对象的引用，称这样的对象为个体对象。"><a href="#理解：如果一个对象包含另一个对象的引用，称这样的对象为组合对象。如果将当前组合对象作为一个整体的话，那么它所包含的对象就是整体的一部分。如果一个对象不含有其他对象的引用，称这样的对象为个体对象。" class="headerlink" title="理解：如果一个对象包含另一个对象的引用，称这样的对象为组合对象。如果将当前组合对象作为一个整体的话，那么它所包含的对象就是整体的一部分。如果一个对象不含有其他对象的引用，称这样的对象为个体对象。"></a>理解：如果一个对象包含另一个对象的引用，称这样的对象为组合对象。如果将当前组合对象作为一个整体的话，那么它所包含的对象就是整体的一部分。如果一个对象不含有其他对象的引用，称这样的对象为个体对象。</h3><hr>
<h3 id="组合模式包括三种角色："><a href="#组合模式包括三种角色：" class="headerlink" title="组合模式包括三种角色："></a>组合模式包括三种角色：</h3><ul>
<li>抽象组件：是一个接口（抽象类），该接口（抽象类）定义了个体对象和组合对象需要实现的关于操作其子节点的方法，比如add(),remove(),以及getChild()等方法。抽象组件也可以定义个体对象和组合对象用于操作其自身的方法，比如isLeaf（）方法等。</li>
<li>Composite节点：实现component接口类的实例，composite节点不仅实现component接口，而且可以含有其他composite节点或leaf节点的引用。</li>
<li>Leaf节点：实现component接口类的实例，leaf节点实现component接口，不可以含有其他composite节点或leaf节点的引用，因此，叶节点在实现component接口有关操作子节点的方法时，可以让方法抛出一个异常，也可以实现为空操作。</li>
</ul>
<hr>
<h3 id="组合模式的优点"><a href="#组合模式的优点" class="headerlink" title="组合模式的优点"></a>组合模式的优点</h3><ul>
<li>组合模式中包含个体对象和组合对象，并形成树形结构，使用户可以方便地处理个体对象和组合对象。</li>
<li>组合对象和个体对象实现了相同的接口，用户一般无须区分个体对象和组合对象。</li>
<li>当增加新的composite节点和Leaf节点时，用户的重要代码不需要作出修改。</li>
</ul>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><hr>
<h4 id="抽象组件"><a href="#抽象组件" class="headerlink" title="抽象组件"></a>抽象组件</h4><pre><code>import java.util.Iterator;

public interface MilitaryPerson {
    public void add(MilitaryPerson person);
    public void remove(MilitaryPerson person);
    public MilitaryPerson getChild(int index);
    public Iterator&lt;MilitaryPerson&gt; getAllChildren();
    public boolean isleaf();
    public double getSalary();
    public void setSalary(double salary);
}
</code></pre><h4 id="composite节点"><a href="#composite节点" class="headerlink" title="composite节点"></a>composite节点</h4><pre><code>import java.util.Iterator;
import java.util.LinkedList;

public class MilitaryOfficer implements MilitaryPerson {
            LinkedList&lt;MilitaryPerson&gt; list;
            String name;
            double salary;


public MilitaryOfficer( String name,
        double salary) {
    list=new LinkedList&lt;MilitaryPerson&gt;();
    this.name = name;
    this.salary = salary;
}

@Override
public void add(MilitaryPerson person) {
    list.add(person);

}

@Override
public void remove(MilitaryPerson person) {
        list.remove(person);
}

@Override
public MilitaryPerson getChild(int index) {
    return list.get(index);
}

@Override
public Iterator&lt;MilitaryPerson&gt; getAllChildren() {
    return list.iterator();
}

@Override
public boolean isleaf() {
    return false;
}

@Override
public double getSalary() {
    return salary;
}

@Override
public void setSalary(double salary) {
    this.salary=salary;
}


}
</code></pre><h4 id="Leaf节点"><a href="#Leaf节点" class="headerlink" title="Leaf节点"></a>Leaf节点</h4><pre><code>import java.util.Iterator;

public class MilitarySoldier implements MilitaryPerson {
       double salary;
       String name;

public MilitarySoldier(double salary, String name) {
    this.salary = salary;
    this.name = name;
}

@Override
public void add(MilitaryPerson person) {

}

@Override
public void remove(MilitaryPerson person) {

}

@Override
public MilitaryPerson getChild(int index) {
    return null;
}

@Override
public Iterator&lt;MilitaryPerson&gt; getAllChildren() {
    return null;
}

@Override
public boolean isleaf() {
    return true;
}

@Override
public double getSalary() {
    return salary;
}

@Override
public void setSalary(double salary) {
    this.salary=salary;
}

}
</code></pre><h4 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h4><pre><code>import java.util.Iterator;

public class ComputerSalary {
    public static double computerSalary(MilitaryPerson person){
         double sum=0;
         if(person.isleaf()==true){
        sum=sum+person.getSalary();
    }
    if(person.isleaf()==false){
        sum=sum+person.getSalary();
        Iterator&lt;MilitaryPerson&gt;iterator=person.getAllChildren();
        while(iterator.hasNext()){
            MilitaryPerson p=iterator.next();
            sum=sum+computerSalary(p);
        }

    }


    return sum;




}
}

public class Application {
public static void main(String[] args) {
    MilitaryPerson 连长=new MilitaryOfficer( &quot;连长&quot;, 5000);
    MilitaryPerson 排长1=new MilitaryOfficer(&quot;一排长&quot;, 4000);
    MilitaryPerson 排长2=new MilitaryOfficer(&quot;二排长&quot;, 4000);

    MilitaryPerson 班长11=new MilitaryOfficer(&quot;一班长&quot;, 2000);
    MilitaryPerson 班长12=new MilitaryOfficer(&quot;二班长&quot;, 2000);
    MilitaryPerson 班长13=new MilitaryOfficer(&quot;三班长&quot;, 2000);

    MilitaryPerson 班长21=new MilitaryOfficer(&quot;一班长&quot;, 2000);
    MilitaryPerson 班长22=new MilitaryOfficer(&quot;二班长&quot;, 2000);
    MilitaryPerson 班长23=new MilitaryOfficer(&quot;三班长&quot;, 2000);

    MilitaryPerson 班长31=new MilitaryOfficer(&quot;一班长&quot;, 2000);
    MilitaryPerson 班长32=new MilitaryOfficer(&quot;二班长&quot;, 2000);
    MilitaryPerson 班长33=new MilitaryOfficer(&quot;三班长&quot;, 2000);

    MilitaryPerson [] 士兵=new MilitarySoldier[600];
    for (int i = 0; i &lt; 士兵.length; i++) {
        士兵[i]=new MilitarySoldier(1000, &quot;小兵&quot;);

    }
    连长.add(排长1);
    连长.add(排长2);
    排长1.add(班长11);
    排长1.add(班长12);
    排长1.add(班长13);

    排长2.add(班长21);
    排长2.add(班长22);
    排长2.add(班长23);

    for (int i = 0; i &lt;=9; i++) {
        班长11.add(士兵[i]);
        班长12.add(士兵[i+10]);
        班长13.add(士兵[i+20]);

        班长21.add(士兵[i+30]);
        班长22.add(士兵[i+40]);
        班长23.add(士兵[i+50]);

        班长31.add(士兵[i+60]);
        班长32.add(士兵[i+70]);
        班长33.add(士兵[i+80]);
    }
    System.out.println(&quot;一班的军饷：&quot;+ComputerSalary.computerSalary(班长11));
    System.out.println(&quot;一排的军饷:&quot;+ComputerSalary.computerSalary(排长1));
    System.out.println(&quot;全连的军饷:&quot;+ComputerSalary.computerSalary(连长));




}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;组合模式详解&quot;&gt;&lt;a href=&quot;#组合模式详解&quot; class=&quot;headerlink&quot; title=&quot;组合模式详解&quot;&gt;&lt;/a&gt;组合模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式详解</title>
    <link href="http://www.craymc.com/2017/01/23/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/23/原型模式详解/</id>
    <published>2017-01-23T15:14:43.000Z</published>
    <updated>2017-01-23T15:21:38.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型模式详解"><a href="#原型模式详解" class="headerlink" title="原型模式详解"></a>原型模式详解</h2><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。"><a href="#定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。" class="headerlink" title="定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。"></a>定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</h3><hr>
<h3 id="原型模式的优点"><a href="#原型模式的优点" class="headerlink" title="原型模式的优点"></a>原型模式的优点</h3><ul>
<li>当创建类的新实例的代价更大时，使用原型模式复制一个已有的实例可以提高创建新实例的效率。</li>
<li>可以动态地保存当前对象的动态。在运行时，可以随时使用对象流保存当前对象的一个复制品。</li>
<li>可以在运行时创建新的对象，而无须创建一系列类和继承结构。</li>
<li>可以动态地添加，删除原型复制品。</li>
</ul>
<hr>
<h3 id="原型模式的适用场景"><a href="#原型模式的适用场景" class="headerlink" title="原型模式的适用场景"></a>原型模式的适用场景</h3><ul>
<li>程序需要从一个对象出发，得到若干个和其状态相同，并可独立变化其状态的对象时。</li>
<li>当对象的创建需要独立于它的构造过程和表示时。</li>
</ul>
<hr>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在某些情况下，可能不希望反复使用类的构造方法创建许多对象，而是希望用该类创建一个对象后，以该对象为原型得到该对象的若干个复制品。也就是说，将一个对象定义为原型对象，要求该原型对象提供一个方法，使该原型对象调用此方法可以复制一个和自己有完全相同状态的同类型对象，既该方法“克隆”原型对象得到一个新对象。<strong>核心：</strong>原型模式是从一个对象出发得到一个和自己有相同状态的新对象的成熟模式，该模式的关键是将一个对象定义为原型，并为其提供复制自己方法。</p>
<hr>
<h3 id="在Java-lang-Object的clone-方法以及在Serializable接口和对象流复制对象。"><a href="#在Java-lang-Object的clone-方法以及在Serializable接口和对象流复制对象。" class="headerlink" title="在Java.lang.Object的clone()方法以及在Serializable接口和对象流复制对象。"></a><strong>在Java.lang.Object的clone()方法以及在Serializable接口和对象流复制对象。</strong></h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型模式详解&quot;&gt;&lt;a href=&quot;#原型模式详解&quot; class=&quot;headerlink&quot; title=&quot;原型模式详解&quot;&gt;&lt;/a&gt;原型模式详解&lt;/h2&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>生成器模式详解</title>
    <link href="http://www.craymc.com/2017/01/23/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/23/生成器模式详解/</id>
    <published>2017-01-23T15:14:16.000Z</published>
    <updated>2017-01-23T15:20:30.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型模式详解"><a href="#原型模式详解" class="headerlink" title="原型模式详解"></a>原型模式详解</h2><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。"><a href="#定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。" class="headerlink" title="定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。"></a>定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</h3><hr>
<h3 id="原型模式的优点"><a href="#原型模式的优点" class="headerlink" title="原型模式的优点"></a>原型模式的优点</h3><ul>
<li>当创建类的新实例的代价更大时，使用原型模式复制一个已有的实例可以提高创建新实例的效率。</li>
<li>可以动态地保存当前对象的动态。在运行时，可以随时使用对象流保存当前对象的一个复制品。</li>
<li>可以在运行时创建新的对象，而无须创建一系列类和继承结构。</li>
<li>可以动态地添加，删除原型复制品。</li>
</ul>
<hr>
<h3 id="原型模式的适用场景"><a href="#原型模式的适用场景" class="headerlink" title="原型模式的适用场景"></a>原型模式的适用场景</h3><ul>
<li>程序需要从一个对象出发，得到若干个和其状态相同，并可独立变化其状态的对象时。</li>
<li>当对象的创建需要独立于它的构造过程和表示时。</li>
</ul>
<hr>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在某些情况下，可能不希望反复使用类的构造方法创建许多对象，而是希望用该类创建一个对象后，以该对象为原型得到该对象的若干个复制品。也就是说，将一个对象定义为原型对象，要求该原型对象提供一个方法，使该原型对象调用此方法可以复制一个和自己有完全相同状态的同类型对象，既该方法“克隆”原型对象得到一个新对象。<strong>核心：</strong>原型模式是从一个对象出发得到一个和自己有相同状态的新对象的成熟模式，该模式的关键是将一个对象定义为原型，并为其提供复制自己方法。</p>
<hr>
<h3 id="在Java-lang-Object的clone-方法以及在Serializable接口和对象流复制对象。"><a href="#在Java-lang-Object的clone-方法以及在Serializable接口和对象流复制对象。" class="headerlink" title="在Java.lang.Object的clone()方法以及在Serializable接口和对象流复制对象。"></a><strong>在Java.lang.Object的clone()方法以及在Serializable接口和对象流复制对象。</strong></h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型模式详解&quot;&gt;&lt;a href=&quot;#原型模式详解&quot; class=&quot;headerlink&quot; title=&quot;原型模式详解&quot;&gt;&lt;/a&gt;原型模式详解&lt;/h2&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/适配器模式详解/</id>
    <published>2017-01-22T13:42:33.000Z</published>
    <updated>2017-01-22T13:52:06.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="适配器模式详解"><a href="#适配器模式详解" class="headerlink" title="适配器模式详解"></a>适配器模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。"><a href="#定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。" class="headerlink" title="定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。"></a>定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>对象适配器模式的结构中包括三种角色：</p>
<ul>
<li>目标： 目标是一个接口，该接口是客户想要使用的接口。</li>
<li>被适配者： 被适配者是一个已经存在的接口或抽象类，这个接口或抽象类需要适配。</li>
<li>适配器：适配器是一个类，该类实现了目标接口并包含有被适配者的引用，既适配器的职责是对被适配者接口（抽象类）与目标接口进行适配。</li>
</ul>
<hr>
<h4 id="适配器的适配程度"><a href="#适配器的适配程度" class="headerlink" title="适配器的适配程度"></a>适配器的适配程度</h4><p>1.完全适配<br>如果目标接口中的方法数目与被适配者接口的方法数目相等，那么适配器可将被适配者接口与目标接口进行完全适配。<br>2.不完全适配<br>如果目标接口中的方法数目少于被适配者接口的方法数目，那么适配器只能将被适配者接口与目标接口进行部分适配。<br>3.剩余适配<br>如果目标接口中的方法数目大于被适配者接口的方法数目，那么适配器可将被适配者接口与目标接口进行完全适配，但必须将目标多余的办法给出用户允许的默认实现。</p>
<h4 id="适配器模式的优点"><a href="#适配器模式的优点" class="headerlink" title="适配器模式的优点"></a>适配器模式的优点</h4><ul>
<li>目标和被适配者是完全解耦的关系。</li>
<li>适配器模式满足“开-闭原则”。当添加一个实现adapter接口的新类时，不必修改adapter，adapter就能对这个新类的实例进行适配。</li>
</ul>
<hr>
<h4 id="适配器模式的使用场景"><a href="#适配器模式的使用场景" class="headerlink" title="适配器模式的使用场景"></a>适配器模式的使用场景</h4><h2 id="一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。"><a href="#一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。" class="headerlink" title=" 一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。"></a> 一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。</h2><h5 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h5><h6 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h6><pre><code>public interface ThreeElectricOutlet {
public abstract void connectElectricCurrent();
}
</code></pre><h6 id="被适配者："><a href="#被适配者：" class="headerlink" title="被适配者："></a>被适配者：</h6><pre><code>public interface TwoElectricOutlet {

public abstract void connectElectricCurrent();

}
</code></pre><h6 id="适配器："><a href="#适配器：" class="headerlink" title="适配器："></a>适配器：</h6><pre><code>public class TreeElectricAdapter implements ThreeElectricOutlet {

TwoElectricOutlet outlet;


public TreeElectricAdapter(TwoElectricOutlet outlet) {
    super();
    this.outlet = outlet;
}


@Override
public void connectElectricCurrent() {
    outlet.connectElectricCurrent();
}

}
</code></pre><h6 id="模式使用："><a href="#模式使用：" class="headerlink" title="模式使用："></a>模式使用：</h6><pre><code>public class Application {
        public static void main(String[] args) {
            ThreeElectricOutlet outlet;
            Wash w=new Wash();
            outlet=w;
            System.out.println(&quot;使用三相插座：&quot;);
            outlet.connectElectricCurrent();
            TV t=new TV();
            TreeElectricAdapter adapter=new TreeElectricAdapter(t);
            outlet=adapter;
            System.out.println(&quot;使用三相插座&quot;);
            outlet.connectElectricCurrent();
        }
}
class Wash implements ThreeElectricOutlet{
String name;
Wash(){
    name=&quot;黄河洗衣机&quot;;
}


public Wash(String s) {
        name=s;
}


@Override
public void connectElectricCurrent() {
        turnOn();
}


public void turnOn() {
    System.out.println(name+&quot;starting.....&quot;);
}
}
class TV implements TwoElectricOutlet{
String name;
TV(){
    name=&quot;长江电视&quot;;

}
public TV(String s) {
    name = s;
}


@Override
public void connectElectricCurrent() {
        turnOn();
}
public void turnOn() {
    System.out.println(name+&quot;开始播放节目&quot;);
}


} 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;适配器模式详解&quot;&gt;&lt;a href=&quot;#适配器模式详解&quot; class=&quot;headerlink&quot; title=&quot;适配器模式详解&quot;&gt;&lt;/a&gt;适配器模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>外观模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/外观模式详解/</id>
    <published>2017-01-22T13:41:27.000Z</published>
    <updated>2017-01-22T13:51:52.999Z</updated>
    
    <content type="html"><![CDATA[<h3 id="外观模式详解"><a href="#外观模式详解" class="headerlink" title="外观模式详解"></a>外观模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。"><a href="#定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。" class="headerlink" title="定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。"></a>定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</h3><hr>
<h3 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h3><p>外观模式的结构中包括两种角色：</p>
<ul>
<li>子系统：子系统是若干个类的集合，这些类的实例协同合作作为用户提供所需要的功能，子系统中任何类都不包括外观类的实例引用。</li>
<li>外观：外观是一个类，该类包含子系统中全部或部分类的实例引用，当用户想要和子系统中的若干类的实例打交道时，可以代替地和子系统的外观类的实例打交道。</li>
</ul>
<hr>
<h3 id="外观模式的优点"><a href="#外观模式的优点" class="headerlink" title="外观模式的优点"></a>外观模式的优点</h3><ul>
<li>使客户和子系统中的类无耦合，并且使子系统使用起来更加方便。</li>
<li>外观只是提供了一个更加简洁的界面，并不影响用户直接使用子系统中的类。</li>
<li>子系统中任何类对其方法的内容进行修改，不影响外观类的代码。</li>
</ul>
<hr>
<h3 id="使用外观模式的情景"><a href="#使用外观模式的情景" class="headerlink" title="使用外观模式的情景"></a>使用外观模式的情景</h3><ul>
<li>对于一个复杂的子系统，需要为用户提供一个单的交互操作。</li>
<li>不希望客户代码和子系统中的类有耦合，以便提高子系统的独立性和可移植性。</li>
<li>当整个系统需要构建一个层次结构的子系统，不希望这些子系统相互直接的交互。</li>
</ul>
<hr>
<h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><h5 id="子系统："><a href="#子系统：" class="headerlink" title="子系统："></a>子系统：</h5><pre><code>import java.io.BufferedReader;
import java.io.FileReader;

public class ReadFile { 
    public  String readFileContent(String fileName){
        StringBuffer str=new StringBuffer();
        try {
            FileReader inOne=new FileReader(fileName);
            BufferedReader inTwo=new BufferedReader(inOne);
            String s=null;
            while((s=inTwo.readLine())!=null){
                str.append(s);
                str.append(&quot;\n&quot;);
            }
            inOne.close();
            inTwo.close();
        } catch (Exception e) {
        }
        return new String(str);

    }
}
import java.util.regex.Matcher;
java.util.regex.Pattern;

public class AnalyzeInformation {
public String getSavedContent(String content,String deleteContent){
    Pattern p;
    Matcher m;
    p=Pattern.compile(deleteContent);
    m=p.matcher(content);
    String savedContent=m.replaceAll(&quot;&quot;);
    return savedContent;

}

}
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.StringReader;

public class WriteFile {

public void writeToFile(String fileName,String content){
    StringBuffer str=new StringBuffer();
    try {
        StringReader inOne=new StringReader(content);
        BufferedReader inTwo=new BufferedReader(inOne);
        FileWriter outOne=new FileWriter(fileName);
        BufferedWriter outTwo=new BufferedWriter(outOne);
        String s=null;
        while((s=inTwo.readLine())!=null){
            outTwo.write(s);
            outTwo.newLine();
            outTwo.flush();
        }
        inOne.close();
        inTwo.close();
        outOne.close();
        outTwo.close();
    } catch (Exception e) {
        // TODO: handle exception
    }


}

}
</code></pre><h5 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h5><pre><code>public class ReadAndWirteFacade {
private ReadFile readFile;
private WriteFile writeFile;
private AnalyzeInformation analyzeInformation;
public ReadAndWirteFacade() {
    readFile=new ReadFile();
    analyzeInformation=new AnalyzeInformation();
    writeFile=new WriteFile();
}
public void doOption(String readFileName,String delContent,String savedFileName){
    String content=readFile.readFileContent(readFileName);
    System.out.println(&quot;读取文件&quot;+readFileName+&quot;的内容&quot;);
    System.out.println(content);
    String savedContent=analyzeInformation.getSavedContent(content, delContent);
    writeFile.writeToFile(savedFileName, savedContent);
    System.out.println(&quot;保存到文件&quot;+savedContent+&quot;中的内容&quot;);
    System.out.println(savedContent);

}

}
</code></pre><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><pre><code>public class Application {
    public static void main(String[] args) {
        ReadAndWirteFacade clientFacade;
        clientFacade=new ReadAndWirteFacade();
        String readFileName=&quot;index.html&quot;;
        String delConten=&quot;&lt;[^&gt;]*&gt;&quot;;
        String savedFileName=&quot;save.txt&quot;;
        clientFacade.doOption(readFileName, delConten, savedFileName);
public class Application {
    public static void main(String[] args) {
        ReadAndWirteFacade clientFacade;
        clientFacade=new ReadAndWirteFacade();
        String readFileName=&quot;index.html&quot;;
        String delConten=&quot;&lt;[^&gt;]*&gt;&quot;;
        String savedFileName=&quot;save.txt&quot;;
        clientFacade.doOption(readFileName, delConten, savedFileName);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;外观模式详解&quot;&gt;&lt;a href=&quot;#外观模式详解&quot; class=&quot;headerlink&quot; title=&quot;外观模式详解&quot;&gt;&lt;/a&gt;外观模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/责任链模式详解/</id>
    <published>2017-01-22T13:39:35.000Z</published>
    <updated>2017-01-22T13:51:41.605Z</updated>
    
    <content type="html"><![CDATA[<h3 id="责任链模式详解"><a href="#责任链模式详解" class="headerlink" title="责任链模式详解"></a>责任链模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><h4 id="定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。"><a href="#定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。" class="headerlink" title="定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。"></a>定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>责任链模式的结构中包括两种角色：</p>
<ul>
<li>处理者：处理者是一个接口，负责规定具体处理者处理用户请求的方法以及具体处理者设置后继对象的方法。</li>
<li><p>具体处理者：具体处理者是实现处理者接口的类的实例。具体处理者通过调用处理者接口规定的方法处理用户的请求，既在接到用户的请求后，处理者将调用接口规定的方法，在执行该方法的过程中，如果发现能处理用户的请求，就处理有关数据，否则就反馈无法处理的信息给用户，然后将用户的请求传递给自己的后继对象。</p>
<h4 id="责任链模式的优点"><a href="#责任链模式的优点" class="headerlink" title="责任链模式的优点"></a>责任链模式的优点</h4></li>
<li><p>责任链中的对象只和自己的后继是低耦合关系，和其他对象毫无关联，这使得编写处理者对象以及创建责任链变得非常容易。</p>
</li>
<li>当在处理者中分配职责时，责任链给应用程序更多的灵活性。</li>
</ul>
<hr>
<h4 id="责任链的适用模式和情景"><a href="#责任链的适用模式和情景" class="headerlink" title="责任链的适用模式和情景"></a>责任链的适用模式和情景</h4><ul>
<li>有许多对象可以处理用户的请求，希望程序在运行期间自动确定处理用户的那个对象。</li>
<li>希望用户不必明确指定接收者的情况下，向多个接收者的一个提交请求。</li>
<li>程序希望动态制定可处理用户请求的对象集合。</li>
</ul>
<hr>
<h5 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h5><h6 id="处理者："><a href="#处理者：" class="headerlink" title="处理者："></a>处理者：</h6><pre><code>public interface Handler {
public abstract void computerMultiply(String number);
public abstract void setNextHandler(Handler handler);
}
</code></pre><h6 id="具体处理者："><a href="#具体处理者：" class="headerlink" title="具体处理者："></a>具体处理者：</h6><pre><code>public class UseInt implements Handler{
private Handler handler;
private int result=1;
@Override
public void computerMultiply(String number) {
        try {
            int n=Integer.parseInt(number);
            int i=1;
            while(i&lt;=n){
                result=result*i;
                if(result&lt;=0){
                    System.out.println(&quot;超出我的能力范围&quot;);
                    handler.computerMultiply(number);
                    return;
                }
                i++;
            }
            System.out.println(number+&quot;的阶乘:&quot;+result);
        } catch (Exception e) {
            // TODO: handle exception
        }
}
@Override
public void setNextHandler(Handler handler) {
        this.handler=handler;
}
}

public class UseLong implements Handler {
private Handler handler;
private long result=1;

@Override
public void computerMultiply(String number) {
        try {
            long n=Long.parseLong(number);
            long i=1;
            while(i&lt;=n){
                result=result*i;
                if(result&lt;=0){
                    System.out.println(&quot;超出能力范围,,,&quot;);
                    handler.computerMultiply(number);
                    return;
                }
                i++;
            }
            System.out.println(number+&quot;的阶乘&quot;+result);
        } catch (Exception e) {
            // TODO: handle exception
        }
}
@Override
public void setNextHandler(Handler handler) {
        this.handler=handler;
}
}

import java.math.BigInteger;

public class UseBigInteger implements Handler{
private Handler handler;
private BigInteger result=new BigInteger(&quot;1&quot;);
@Override
public void computerMultiply(String number) {
        try {
            BigInteger n=new BigInteger(number);
            BigInteger ONE=new BigInteger(&quot;1&quot;);
            BigInteger i=ONE;
            while(i.compareTo(n)&lt;=0){
                result=result.multiply(i);
                i=i.add(ONE);
            }
            System.out.println(number+&quot;的阶乘&quot;+result);
        } catch (Exception e) {
            // TODO: handle exception
        }
}
@Override
public void setNextHandler(Handler handler) {
        this.handler=handler;
}
}
</code></pre><h6 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h6><pre><code>public class Application {

        private Handler useInt, useLong, useBig;
        public void createChain(){
            useInt=new UseInt();
            useLong=new UseLong();
            useBig=new UseBigInteger();
            useInt.setNextHandler(useLong);
            useLong.setNextHandler(useBig);
        }
        public void responseClient(String number){
            useInt.computerMultiply(number);
        }
        public static void main(String[] args) {
            Application application=new Application();
            application.createChain();
            application.responseClient(&quot;32&quot;);
        }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;责任链模式详解&quot;&gt;&lt;a href=&quot;#责任链模式详解&quot; class=&quot;headerlink&quot; title=&quot;责任链模式详解&quot;&gt;&lt;/a&gt;责任链模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单子模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E5%8D%95%E5%AD%90%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/单子模式详解/</id>
    <published>2017-01-22T13:38:44.000Z</published>
    <updated>2017-01-22T13:51:36.239Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单子模式详解"><a href="#单子模式详解" class="headerlink" title="单子模式详解"></a>单子模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h2 id="定义：-保证一个类只有一个实例，并提供一个访问它的全局访问点。"><a href="#定义：-保证一个类只有一个实例，并提供一个访问它的全局访问点。" class="headerlink" title="定义： 保证一个类只有一个实例，并提供一个访问它的全局访问点。"></a>定义： 保证一个类只有一个实例，并提供一个访问它的全局访问点。</h2><h3 id="单子模式的优点"><a href="#单子模式的优点" class="headerlink" title="单子模式的优点"></a>单子模式的优点</h3><h2 id="单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。"><a href="#单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。" class="headerlink" title="单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。"></a>单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。</h2><h3 id="单子模式的使用场景"><a href="#单子模式的使用场景" class="headerlink" title="单子模式的使用场景"></a>单子模式的使用场景</h3><p>当系统需要某个类只能有一个实例。</p>
<h3 id="下面代码实现了两种经典单子模式和线程安全的单子模式"><a href="#下面代码实现了两种经典单子模式和线程安全的单子模式" class="headerlink" title="下面代码实现了两种经典单子模式和线程安全的单子模式"></a>下面代码实现了两种经典单子模式和线程安全的单子模式</h3><hr>
<h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><pre><code>public class Singleton {


private Singleton() {}  
private static Singleton single=null;  
//静态工厂方法   
public static Singleton getInstance() {  
     if (single == null) {    
         single = new Singleton();  
     }    
    return single;  
}  
</code></pre><p>   }</p>
<h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><pre><code>public class Singleton1 {


   private Singleton1() {}  
    private static final Singleton1 single = new Singleton1();  
    //静态工厂方法   
    public static Singleton1 getInstance() {  
        return single;  
    } 
}
</code></pre><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><pre><code>public class TestSingleton {  
String name = null;  

    private TestSingleton() {  
}  

private static volatile TestSingleton instance = null;  

public static TestSingleton getInstance() {  
       if (instance == null) {    
         synchronized (TestSingleton.class) {    
            if (instance == null) {    
               instance = new TestSingleton();   
            }    
         }    
       }   
       return instance;  
}  

public String getName() {  
    return name;  
}  

public void setName(String name) {  
    this.name = name;  
}  

public void printInfo() {  
    System.out.println(&quot;the name is &quot; + name);  
}  

} 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单子模式详解&quot;&gt;&lt;a href=&quot;#单子模式详解&quot; class=&quot;headerlink&quot; title=&quot;单子模式详解&quot;&gt;&lt;/a&gt;单子模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/迭代器详解/</id>
    <published>2017-01-22T13:38:27.000Z</published>
    <updated>2017-01-22T13:51:30.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器模式详解"><a href="#迭代器模式详解" class="headerlink" title="迭代器模式详解"></a>迭代器模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。"><a href="#定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。" class="headerlink" title="定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。"></a>定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</h3><hr>
<h3 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h3><p>迭代器模式的结构中包括四种角色：</p>
<ul>
<li>集合：一个接口，规定了具体集合需要实现的操作。</li>
<li>具有集合：具体集合是实现集合接口的类的实例，具体集合按着一定结构存储对象。具体集合应该当有一个方法，该方法返回一个针对该集合的具体迭代器。</li>
<li>迭代器：一个接口，规定了遍历具体集合的方法。</li>
<li>具体迭代器实现迭代器接口的类的实例。具体迭代器在实现迭代器接口所规定的遍历集合的方法时，要保证方法的首次调用将按着集合的数据结构找到该集合中的一个对象，立刻根据该集合的存储结构得到待遍历的后继对象的引用，并保证依次调用的方法可以遍历集合。</li>
</ul>
<hr>
<h3 id="迭代器模式的优点"><a href="#迭代器模式的优点" class="headerlink" title="迭代器模式的优点"></a>迭代器模式的优点</h3><ul>
<li>用户使用迭代器访问集合中的对象，而不需要知道这些对象在集合中是如何表示及存储的。</li>
<li>用户可以同时使用多个迭代器遍历一个集合。</li>
</ul>
<hr>
<h3 id="适合使用迭代器模式的情景"><a href="#适合使用迭代器模式的情景" class="headerlink" title="适合使用迭代器模式的情景"></a>适合使用迭代器模式的情景</h3><ul>
<li>让用户访问一个集合中是对象，但不想暴露对象在集合中的存储结构。</li>
<li>希望对遍历不同的集合提供一个统一的接口。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><pre><code>import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.TreeSet;

public class UseSet {
LinkedList&lt;Student&gt;list;
Hashtable&lt;String, Student&gt;table;
TreeSet&lt;Student&gt;tree;
UseSet(){
    list=new LinkedList&lt;Student&gt;();
    tree=new TreeSet&lt;Student&gt;();
    table=new Hashtable&lt;String,Student&gt;();
}
public void addStudent(Student stu){
    list.add(stu);
    update();

}
public  void lookStudent(String n) {
        Student stu=table.get(n);
        String number=stu.getNumber();
        String name=stu.getName();
        double score=stu.getSorce();
        System.out.println(&quot;学号：&quot;+number+&quot;姓名:&quot;+name+&quot;分数：&quot;+score);

}
public void printStudentByScore(){
    Iterator&lt;Student&gt;iterator=tree.iterator();
    while(iterator.hasNext()){
        Student stu=iterator.next();
        String number=stu.getNumber();
        String name=stu.getName();
        double sorce=stu.getSorce();
        System.out.println(&quot;学号：&quot;+number+&quot;姓名：&quot;+name+&quot;分数：&quot;+sorce);
    }
}
private void update() {
        tree.clear();
        Iterator&lt;Student&gt;iterator=list.iterator();
        while(iterator.hasNext()){
            Student stu=iterator.next();
            String number=stu.getNumber();
            table.put(number, stu);
            tree.add(stu);
        }
}
</code></pre><p>   }</p>
<p>   public class Student implements Comparable{<br>    String number,name;<br>    double sorce=0;<br>    private int x=10;</p>
<pre><code>public Student() {
    super();
    // TODO Auto-generated constructor stub
}

public Student(String number, String name, double sorce) {
    super();
    this.number = number;
    this.name = name;
    this.sorce = sorce;
}

@Override
public int compareTo(Object o) {
    Student st=(Student)o;
    if(Math.abs(this.sorce-st.sorce)&lt;=1/10000)
         return 1;
    return (int)(1000*(this.sorce-st.sorce));
}

public String getNumber() {
    return number;
}

public String getName() {
    return name;
}

public double getSorce() {
    return sorce;
}
</code></pre><p>   }</p>
<pre><code>public class Application {
public static void main(String[] args) {
UseSet useSet=new UseSet();
useSet.addStudent(new Student(&quot;001&quot;, &quot;cc&quot;, 76.9));
String n=&quot;001&quot;;
System.out.println(&quot;查找学号为：&quot;+n+&quot;的学生：&quot;);
useSet.lookStudent(n);
System.out.println(&quot;将学生按成绩排列:&quot;);
useSet.printStudentByScore();
}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;迭代器模式详解&quot;&gt;&lt;a href=&quot;#迭代器模式详解&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式详解&quot;&gt;&lt;/a&gt;迭代器模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/中介者模式详解/</id>
    <published>2017-01-22T13:38:12.000Z</published>
    <updated>2017-01-22T13:51:24.415Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中介者模式详解"><a href="#中介者模式详解" class="headerlink" title="中介者模式详解"></a>中介者模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。"><a href="#定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。" class="headerlink" title="定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。"></a>定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。</h3><hr>
<h3 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h3><p>中介者模式的结构中包含四种角色：</p>
<ul>
<li>中介者：中介者是一个接口，该接口定义了用于同时对象之间进行通信的方法。</li>
<li>具体中介者：具体中介者是实现中介者接口的类。具体中介者需要包含所有具体同事的引用，并通过实现中介者接口中的方法来满足具体同事之间的通信请求。</li>
<li>同事：一个接口，规定了具体同事需要实现的方法。</li>
<li>具体同事：实现同事接口的类，具体同事需要包含具体中介者的引用，一个具体同事需要和其他同事交互时，只需要将自己的请求通知给它所包含的具体中介者即可</li>
</ul>
<hr>
<h3 id="中介者模式的优点"><a href="#中介者模式的优点" class="headerlink" title="中介者模式的优点"></a>中介者模式的优点</h3><ul>
<li>可以避免许多的对象为了之间的通信而相互先是引用，否则，不仅系统难于维护，而且也使其他系统难以复用这些对象。</li>
<li>可以通过中介者将原本分布于多个对象之间的交互行为集中在一起。当这些对象之间需要改变之间的通信行为时，只需使用一个具体中介者即可，不必修改各个具体同事的代码，既这些同事可被重用。</li>
<li>具体中介者使得各个具体同事之间是如何交互的细节，是系统比较清楚地知道整个系统中的同事是如何交互的。</li>
<li>当一些对象想相互通信，但又无法相互包含对方的引用，那么使用中介者模式就可以使这些对象相互通信。</li>
</ul>
<hr>
<h3 id="中介者模式的适用场景"><a href="#中介者模式的适用场景" class="headerlink" title="中介者模式的适用场景"></a>中介者模式的适用场景</h3><ul>
<li>许多对象以复杂的方式交互，所导致的依赖关系时系统难以理解和维护。</li>
<li>一个对象引用其他很多对象，导致难以复用的情况。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h4 id="同事："><a href="#同事：" class="headerlink" title="同事："></a>同事：</h4><pre><code>public interface Colleage {
public void giveMess(String[] mess);
public void receiverMess(String mess);
public void setName(String name);
public String getName();
}
</code></pre><h4 id="具体中介者："><a href="#具体中介者：" class="headerlink" title="具体中介者："></a>具体中介者：</h4><pre><code>public class ConcreteMediator {
ColleagueA colleageA;
ColleageB colleageB;
ColleageC colleageC;
public void registerColleagueA(ColleagueA colleagueA)
{
    this.colleageA=colleagueA;
}
public void registerColleagueB(ColleageB colleagueB)
{
    this.colleageB=colleagueB;
}
public void registerColleagueC(ColleageC colleagueC)
{
    this.colleageC=colleagueC;
}

public void deliverMess(Colleage colleage,String []mess){
    if(colleage==colleageA){
        if(mess.length&gt;=2){
            colleageB.receiverMess(colleage.getName()+mess[0]);
            colleageC.receiverMess(colleage.getName()+mess[1]);
        }else if(colleage==colleageB){
            if(mess.length&gt;=2){
                colleageA.receiverMess(colleage.getName()+mess[0]);
                colleageC.receiverMess(colleage.getName()+mess[1]);
            }

        }else if(colleage==colleageC){
            if(mess.length&gt;=2){
                colleageA.receiverMess(colleage.getName()+mess[0]);
                colleageB.receiverMess(colleage.getName()+mess[1]);
            }
        }
    }
}


}
</code></pre><h4 id="具体同事："><a href="#具体同事：" class="headerlink" title="具体同事："></a>具体同事：</h4><pre><code>public class ColleagueA implements Colleage{

ConcreteMediator mediator;//中介者
String name;

public ColleagueA(ConcreteMediator mediator) {
    this.mediator = mediator;
    mediator.registerColleagueA(this);
}

@Override
public void giveMess(String[] mess) {
    mediator.deliverMess(this, mess);
}

@Override
public void receiverMess(String mess) {
        System.out.println(name+&quot;收到信息&quot;);
        System.out.println(&quot;\t&quot;+mess);
}

@Override
public void setName(String name) {
    this.name=name;
}

@Override
public String getName() {
    return name;
}

}


public class ColleageB implements Colleage{

    ConcreteMediator mediator;
    String name;


public ColleageB(ConcreteMediator mediator) {
     this.mediator = mediator;
     mediator.registerColleagueB(this);
}


public void receiverMess(String mess) {
        System.out.println(name+&quot;收到信息&quot;);
        System.out.println(&quot;\t&quot;+mess);
}


@Override
public void giveMess(String[] mess) {
    mediator.deliverMess(this, mess);
}


@Override
public void setName(String name) {
    this.name=name;

}


@Override
public String getName() {
    return name;
}

}

public class ColleageC implements Colleage{
ConcreteMediator mediator;
String name;


public ColleageC(ConcreteMediator mediator) {
    this.mediator = mediator;
    mediator.registerColleagueC(this);
}

public void receiverMess(String mess) {
        System.out.println(name+&quot;收到的信息&quot;);
        System.out.println(&quot;\t&quot;+mess);
}

@Override
public void giveMess(String[] mess) {
    mediator.deliverMess(this, mess);
}

@Override
public void setName(String name) {
    this.name=name;
}

@Override
public String getName() {
    // TODO Auto-generated method stub
    return null;
}

}
</code></pre><h4 id="模式的使用："><a href="#模式的使用：" class="headerlink" title="模式的使用："></a>模式的使用：</h4><pre><code>public class Application {


public static void main(String[] args) {

    ConcreteMediator mediator=new ConcreteMediator();

    ColleagueA colleagA=new ColleagueA(mediator);
    ColleageB colleageB=new ColleageB(mediator);
    ColleageC colleageC=new ColleageC(mediator);
    colleagA.setName(&quot;aA&quot;);

    colleageB.setName(&quot;aB&quot;);
    colleageC.setName(&quot;ac&quot;);
    String [] messA={&quot;aa100，aa200&quot;};
    colleagA.giveMess(messA);

    String [] messB={&quot;aa10&quot;,&quot;aa20&quot;};
    colleageB.giveMess(messB);
    String [] messC={&quot;aa1&quot;,&quot;aa2&quot;};
    colleageC.giveMess(messC);
}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;中介者模式详解&quot;&gt;&lt;a href=&quot;#中介者模式详解&quot; class=&quot;headerlink&quot; title=&quot;中介者模式详解&quot;&gt;&lt;/a&gt;中介者模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/工厂方法模式详解/</id>
    <published>2017-01-22T13:37:37.000Z</published>
    <updated>2017-01-22T14:11:16.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工厂方法详解"><a href="#工厂方法详解" class="headerlink" title="工厂方法详解"></a>工厂方法详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。"><a href="#定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。" class="headerlink" title="定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。"></a>定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</h4><hr>
<h4 id="模式的接口和使用"><a href="#模式的接口和使用" class="headerlink" title="模式的接口和使用"></a>模式的接口和使用</h4><p>工厂方法模式的结构中包括四种角色：</p>
<ul>
<li>抽象产品：抽象类或者接口，负责定义具体产品必须实现的方法。</li>
<li>具体产品：具体产品是一个类，如果product是一个抽象类，那么具体产品是product的子类；如果product是一个接口，那么具体产品是实现product接口的类。</li>
<li>构造者：一个接口或抽象类。构造者负责定义一个称作工厂方法的抽象方法，该方法返回具体产品类的实例。</li>
<li>具体构造者：如果构造者是抽象类，具体构造者是构造者的子类如果构造者是接口，具体构造者是实现构造者的类。具体构造者重写工厂方法使该方法返回<br>具体产品的实例。 </li>
</ul>
<hr>
<h4 id="工厂方法模式的优点"><a href="#工厂方法模式的优点" class="headerlink" title="工厂方法模式的优点"></a>工厂方法模式的优点</h4><ul>
<li>使用工厂方法可让用户的代码和某个特定的子类的代码解耦。</li>
<li>工厂方法使用户不必知道它所使用的对象是怎样被创建的，只需知道该对象有哪些方法即可。</li>
</ul>
<h4 id="适合使用工厂方法模式的情景"><a href="#适合使用工厂方法模式的情景" class="headerlink" title="适合使用工厂方法模式的情景"></a>适合使用工厂方法模式的情景</h4><ul>
<li>用户需要一个类的子类的实例，但不希望与该类的子类形成耦合。</li>
<li>用户需要一个类的子类的实例，但用户不知道该类有哪些子类可用。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h5 id="抽象代码"><a href="#抽象代码" class="headerlink" title="抽象代码"></a>抽象代码</h5><pre><code>public abstract class PenCore {
String color;
public abstract void wirteWord(String s);
}
</code></pre><h5 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h5><pre><code>public class RedPencore extends PenCore {
RedPencore(){
    color=&quot;红色&quot;;
}


@Override
public void wirteWord(String s) {
        System.out.println(&quot;写出&quot;+color+&quot;的字:&quot;+s);
}


}

public class BluePenCore extends PenCore {
public BluePenCore() {
    color=&quot;蓝色&quot;;
}

@Override
public void wirteWord(String s) {
    System.out.println(&quot;写出&quot;+color+&quot;的字:&quot;+s);
}

}

public class BlackPenCore  extends PenCore{

public BlackPenCore() {
    color=&quot;黑色&quot;;
}

@Override
public void wirteWord(String s) {
    System.out.println(&quot;写出&quot;+color+&quot;的字：&quot;+s);
}

}
</code></pre><h5 id="构造者"><a href="#构造者" class="headerlink" title="构造者"></a>构造者</h5><pre><code>public abstract class BallPen {
public BallPen() {
    System.out.println(&quot;生产了一只装有&quot;+getPenCore().color+&quot;笔芯的圆珠笔&quot;);
}
public abstract PenCore getPenCore();

}
</code></pre><h5 id="具体构造者"><a href="#具体构造者" class="headerlink" title="具体构造者"></a>具体构造者</h5><pre><code>public class RedBallPen extends BallPen{


@Override
public PenCore getPenCore() {

    return new RedPencore();
}


}

public class BlueBalPen extends BallPen{

@Override
public PenCore getPenCore() {

    return new BluePenCore();
}

}

public class BlackBallPen extends BallPen{

@Override
public PenCore getPenCore() {
    return new BlackPenCore();
}

}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>public class Application {
    public static void main(String[] args) {
        PenCore penCore;
        BallPen ballPen=new BlueBalPen();
        penCore=ballPen.getPenCore();
        penCore.wirteWord(&quot;hello  world&quot;);
        ballPen=new RedBallPen();
        penCore=ballPen.getPenCore();
        penCore.wirteWord(&quot;HOW  ARE  YOU&quot;);
        ballPen=new BlackBallPen();
        penCore=ballPen.getPenCore();
        penCore.wirteWord(&quot;OK&quot;);
    }
 }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工厂方法详解&quot;&gt;&lt;a href=&quot;#工厂方法详解&quot; class=&quot;headerlink&quot; title=&quot;工厂方法详解&quot;&gt;&lt;/a&gt;工厂方法详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰模式详解</title>
    <link href="http://www.craymc.com/2017/01/17/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/17/装饰模式详解/</id>
    <published>2017-01-17T14:19:36.000Z</published>
    <updated>2017-01-22T06:56:59.058Z</updated>
    
    <content type="html"><![CDATA[<h3 id="装饰模式详解"><a href="#装饰模式详解" class="headerlink" title="装饰模式详解"></a>装饰模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><h4 id="定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。"><a href="#定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。" class="headerlink" title="定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。"></a>定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。</h4><h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><ul>
<li>抽象组件：抽象组件是一个抽象类。抽象组件定义了“被装饰者”需要进行“装饰”的方法。</li>
<li>具体组件：具体组件是抽象组件的一个子类，具体组件的实例称作“被装饰者”。</li>
<li>装饰：装饰也是抽象组件的一个子类，但装饰还包含一个抽象组件声明的变量以保存“被装饰者”的引用。装饰可以是抽象类也可以是一个非抽象类，如果是非抽象类，那么该类的实例称作“装饰者”。</li>
<li>具体装饰： 具体装饰是装饰的一个非抽象类，具体装饰的实例称作“装饰者”。</li>
</ul>
<hr>
<a id="more"></a>
<h4 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h4><p>“具体组件”和“装饰”都是“抽象组件”的子类。因此，“抽象组件”声明的对象即可以存放“被装饰者”的引用也可以存放“装饰者”的引用。如果“抽象组件”声明对象存放“被装饰者”的引用，那么该对象就能调用“被装饰者”所实现“抽象组件”中的方法；如果“抽象组件”声明对象存放“装饰者”的引用，那么该对象就能调用“装饰者”所实现“抽象组件”中的方法。</p>
<hr>
<h4 id="装饰模式相对于继承机制的优势"><a href="#装饰模式相对于继承机制的优势" class="headerlink" title="装饰模式相对于继承机制的优势"></a>装饰模式相对于继承机制的优势</h4><p>通过继承可以改进对象的行为，对于某些简单的问题这样无所谓，但是如果考虑到系统扩展性，就应当遵循：<strong>少用继承，多用组合。</strong>就功能来说：<strong>装饰模式相比生产子类更加灵活</strong>。</p>
<h4 id="装饰模式的优点"><a href="#装饰模式的优点" class="headerlink" title="装饰模式的优点"></a>装饰模式的优点</h4><ul>
<li>被装饰者和装饰者是松耦合的关系。由于装饰仅仅依赖于抽象组件，因此具体装饰只知道他要装饰的对象是抽象组件某一个子类的实例，但不需要知道是那一个人具体子类。</li>
<li>装饰者模式满足“开-闭原则”。不必修改具体组件，就可以增加新的针对该具体组件的具体装饰。</li>
<li>可以使用多个装饰来装饰具体组件的实例。</li>
</ul>
<hr>
<h4 id="适合使用装饰模式的情景"><a href="#适合使用装饰模式的情景" class="headerlink" title="适合使用装饰模式的情景"></a>适合使用装饰模式的情景</h4><ul>
<li>程序希望动态地增强类非某个对象的功能，而又不影响到该类的其他对象。</li>
<li>采用继承来增强对象功能不利于系统的扩展和维护。</li>
</ul>
<hr>
<h5 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h5><h6 id="抽象组件："><a href="#抽象组件：" class="headerlink" title="抽象组件："></a>抽象组件：</h6><pre><code>import java.io.File;
import java.util.ArrayList;

public abstract class ReadWord {
public abstract ArrayList&lt;String&gt; readWord(File file);

}
</code></pre><h6 id="具体组件："><a href="#具体组件：" class="headerlink" title="具体组件："></a>具体组件：</h6><pre><code>import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;

public class ReadEnglishWord extends ReadWord{

@Override
public ArrayList&lt;String&gt; readWord(File file) {
    ArrayList&lt;String&gt; wordList=new ArrayList&lt;String&gt;();
    try {
        FileReader inOne=new FileReader(file);
        BufferedReader inTwo=new BufferedReader(inOne);
        String s=null;
        while((s=inTwo.readLine())!=null){
            wordList.add(s);
        }
        inTwo.close();
        inOne.close();
    } catch (Exception e) {
        System.out.println(e);
    }
    return null;
}

}
</code></pre><h6 id="装饰："><a href="#装饰：" class="headerlink" title="装饰："></a>装饰：</h6><pre><code>public abstract class Decorator extends ReadWord {
protected ReadWord reader;

public Decorator() {
    super();
    // TODO Auto-generated constructor stub
}

public Decorator(ReadWord reader) {
    super();
    this.reader = reader;
}
}
</code></pre><h6 id="具体装饰与相关文件："><a href="#具体装饰与相关文件：" class="headerlink" title="具体装饰与相关文件："></a>具体装饰与相关文件：</h6><pre><code>import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;

public class WordDecorator extends Decorator{
File decoratorFile;

public WordDecorator(ReadWord reader,File decoratorFile) {
    super(reader);
    this.decoratorFile = decoratorFile;

}
public ArrayList&lt;String&gt; readWord(File file){
    ArrayList&lt;String&gt; wordList=reader.readWord(file);
    try {
        FileReader inOne=new FileReader(decoratorFile);
        BufferedReader inTwo=new BufferedReader(inOne);
        String s=null;
        int m=0;
        while((s=inTwo.readLine())!=null){
            String word=wordList.get(m);
            word=word.concat(&quot;|&quot;+s);
            wordList.set(m, word);
            m++;
            if(m&gt;wordList.size())break;
        }
        inOne.close();
        inTwo.close();
    } catch (Exception e) {
        // TODO: handle exception
    }
    return wordList;


}


}
</code></pre><h6 id="应用程序："><a href="#应用程序：" class="headerlink" title="应用程序："></a>应用程序：</h6><pre><code>import java.io.File;
import java.util.ArrayList;

public class Application {

public static void main(String[] args) {
    ArrayList&lt;String&gt;wordList=new ArrayList&lt;String&gt;();
    ReadEnglishWord REW=new ReadEnglishWord();
    WordDecorator WD1=new WordDecorator(REW, new File(&quot;chinese.txt&quot;));
    ReadWord reader=WD1;
    wordList=reader.readWord(new File(&quot;word.txt&quot;));
    for (int i = 0; i &lt; wordList.size(); i++) {

        System.out.println(wordList.get(i));
    }
    WordDecorator WD2=new WordDecorator(WD1, new File(&quot;englishSentence.txt&quot;));
    reader=WD2;
    wordList=reader.readWord(new File(&quot;word.txt&quot;));
    for (int i = 0; i &lt; wordList.size(); i++) {
        System.out.println(wordList.get(i));
    }
}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;装饰模式详解&quot;&gt;&lt;a href=&quot;#装饰模式详解&quot; class=&quot;headerlink&quot; title=&quot;装饰模式详解&quot;&gt;&lt;/a&gt;装饰模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;h4 id=&quot;定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。&quot;&gt;&lt;a href=&quot;#定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。&quot; class=&quot;headerlink&quot; title=&quot;定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。&quot;&gt;&lt;/a&gt;定义：动态地给对象添加一些额外的职责。就功能来说装饰模式相比生产子类更为灵活。&lt;/h4&gt;&lt;h4 id=&quot;模式的结构与使用&quot;&gt;&lt;a href=&quot;#模式的结构与使用&quot; class=&quot;headerlink&quot; title=&quot;模式的结构与使用&quot;&gt;&lt;/a&gt;模式的结构与使用&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;抽象组件：抽象组件是一个抽象类。抽象组件定义了“被装饰者”需要进行“装饰”的方法。&lt;/li&gt;
&lt;li&gt;具体组件：具体组件是抽象组件的一个子类，具体组件的实例称作“被装饰者”。&lt;/li&gt;
&lt;li&gt;装饰：装饰也是抽象组件的一个子类，但装饰还包含一个抽象组件声明的变量以保存“被装饰者”的引用。装饰可以是抽象类也可以是一个非抽象类，如果是非抽象类，那么该类的实例称作“装饰者”。&lt;/li&gt;
&lt;li&gt;具体装饰： 具体装饰是装饰的一个非抽象类，具体装饰的实例称作“装饰者”。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
