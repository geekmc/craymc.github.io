<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>craymc</title>
  <subtitle>http://www.craymc.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.craymc.com/"/>
  <updated>2017-09-02T14:29:45.851Z</updated>
  <id>http://www.craymc.com/</id>
  
  <author>
    <name>craymc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web安全-客户端安全</title>
    <link href="http://www.craymc.com/2017/09/02/web%E5%AE%89%E5%85%A8-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    <id>http://www.craymc.com/2017/09/02/web安全-客户端安全/</id>
    <published>2017-09-02T14:27:54.000Z</published>
    <updated>2017-09-02T14:29:45.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="跨站脚本攻击（xss）"><a href="#跨站脚本攻击（xss）" class="headerlink" title="跨站脚本攻击（xss）"></a>跨站脚本攻击（xss）</h3><p><strong>定义：</strong> 通过向页面注入恶意HTML代码，插入JS脚本，在用户浏览网页的时候发起攻击。</p>
<p><strong>本质：</strong> 是一种HTML的注入，用户的数据被当成了HTML代码的一部分执行。</p>
<p><strong>分类</strong></p>
<p>1.反射型（payload不经过数据库）</p>
<p>XSS脚本在URL中，当用户点击URL的时候，XSS代码随响应内容一起传回给浏览器。也就是说payload存储在URL中</p>
<hr>
<p>2.存储型（payload经过数据库）</p>
<p>XSS脚本存储在服务器中，只要有用户访问就会触发。【容易造成xss 蠕虫但是我不知道该如何构造】<br><a id="more"></a></p>
<hr>
<p>3.DOM型（payload在前端页面）</p>
<p>通过修改页面的DOM节点形成XSS。</p>
<hr>
<p><strong>利用方法</strong></p>
<p>1.我认为XSS的利用本质就是JS脚本的利用，可以实现以下功能：</p>
<ul>
<li><p>依靠恶意脚本获取cookie</p>
</li>
<li><p>构造POST与GET请求</p>
</li>
<li><p>xss钓鱼（但是我觉得这个实现起来有一定的技术难度）</p>
</li>
<li><p>此外其他的场景我认为跟JS的基础有关系，可以自己定义一些模板</p>
</li>
</ul>
<p>2.accesskey的利用</p>
<hr>
<p><strong>构造方法</strong></p>
<p>1.字符编码</p>
<p>2.绕过长度限制：</p>
<ul>
<li><p>利用“事件”</p>
</li>
<li><p>location.hash</p>
</li>
<li><p>利用注释</p>
</li>
<li><p>Windows.name：特点是不受同源策略的限制，可以实现跨域，跨页面传输数据</p>
</li>
</ul>
<hr>
<p><strong>防御方法</strong></p>
<p>1.httpOnly:给关键的cookie使用(使用这个之后，JS取不到cookie的值)</p>
<p>2.xss filter</p>
<p>3.移除用户上传的DOM属性，移除用户上传的style节点，script节点，Iframe节点</p>
<p>4.使用安全编码函数HTMLencode，Javascriptencode，转译敏感字符</p>
<p>5.其实更稳妥的办法是根据不同场景的XSS利用构造适合的防御策略。</p>
<hr>
<h3 id="跨站请求伪造（csrf）"><a href="#跨站请求伪造（csrf）" class="headerlink" title="跨站请求伪造（csrf）"></a>跨站请求伪造（csrf）</h3><p><strong>理解：</strong>hacker诱导用户访问一个页面，就以该用户身份在第三方站点执行操作。或者说攻击者创建一个连接，受害者点击之后就会完成攻击者想要的操作。</p>
<hr>
<p><em>*本质</em>：*重要的操作和参数都是可以被攻击者猜测出。然后攻击者就可以继续构造。利用用户的身份操作用户的账户的攻击方式。</p>
<p><strong>场景模拟</strong></p>
<ol>
<li>hacker在购物网站下单，生成CSRF攻击脚本，诱导用户A打开攻击页面，A完成对hacker下单的付账。</li>
</ol>
<hr>
<p><strong>利用</strong></p>
<p>1.如果攻击的目标并不需要cookie则不必考虑浏览器的cookie，否则需要。</p>
<p>2.利用JS  可以构造POST请求</p>
<hr>
<p><strong>防御</strong></p>
<ul>
<li><p>把参数加密，或者使用一些随机数，从而让攻击者无法猜测出。</p>
</li>
<li><p>添加reference check（检查请求是否来自合法的源头），但是如果从HTTP条转到HTTPS的时候，浏览器不会发送referer</p>
</li>
<li><p>增加CSRF token，但是如果网站存在XSS，攻击者可以在请求页面后，找到页面内容里的token值，然后在构造请求。（<strong>xsrf</strong>）</p>
</li>
</ul>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;跨站脚本攻击（xss）&quot;&gt;&lt;a href=&quot;#跨站脚本攻击（xss）&quot; class=&quot;headerlink&quot; title=&quot;跨站脚本攻击（xss）&quot;&gt;&lt;/a&gt;跨站脚本攻击（xss）&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt; 通过向页面注入恶意HTML代码，插入JS脚本，在用户浏览网页的时候发起攻击。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本质：&lt;/strong&gt; 是一种HTML的注入，用户的数据被当成了HTML代码的一部分执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.反射型（payload不经过数据库）&lt;/p&gt;
&lt;p&gt;XSS脚本在URL中，当用户点击URL的时候，XSS代码随响应内容一起传回给浏览器。也就是说payload存储在URL中&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2.存储型（payload经过数据库）&lt;/p&gt;
&lt;p&gt;XSS脚本存储在服务器中，只要有用户访问就会触发。【容易造成xss 蠕虫但是我不知道该如何构造】&lt;br&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="http://www.craymc.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web安全-文件上传</title>
    <link href="http://www.craymc.com/2017/09/02/web%E5%AE%89%E5%85%A8-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://www.craymc.com/2017/09/02/web安全-文件上传/</id>
    <published>2017-09-02T14:17:03.000Z</published>
    <updated>2017-09-02T14:26:58.784Z</updated>
    
    <content type="html"><![CDATA[<p><em>定义:</em>用户上传了一个可执行的脚本文件，并通过此脚本获得了执行服务器端的命令，也就是能通过菜刀连接获取WEBSHELL。</p>
<hr>
<p><strong>常见的问题</strong></p>
<ul>
<li><p>上传的文件是web脚本语言，服务器解释并执行了用户上传的脚本，导致恶意代码执行</p>
</li>
<li><p>上传的文件夹是木马或者病毒诱导网站管理员下载执行</p>
</li>
</ul>
<hr>
<a id="more"></a>
<p><strong>利用</strong></p>
<ul>
<li>FCKEditor文件上传漏洞,ewebeditor漏洞</li>
</ul>
<hr>
<p><em>绕过方式</em></p>
<ul>
<li><p>抓包，改包（MIME修改绕过）</p>
</li>
<li><p>文件名后缀大小写绕过</p>
</li>
<li><p>文件内容绕过</p>
</li>
<li><p>JS绕过：</p>
<p>  1.HTTP数据包<br>  2.审查元素–取消JS函数的调用<br>  3.JS部分全部删掉<br>  4.禁止加载JS</p>
</li>
</ul>
<hr>
<p>##解析漏洞##</p>
<p>1.Nginx:</p>
<p>假如有一张图片：http:a.test.com/1.jpg.当我们正常访问，nginx会把这个当做非脚本语言直接读取传送回客户端（浏览器），但存在解析漏洞的nginx会把如下链接解析并执行<strong><a href="http://a.test.com" target="_blank" rel="external">http://a.test.com</a> :8080/1.jpg/1.php</strong></p>
<p>影响范围：0.765以下及0.8.37以下到8系列</p>
<p>2.IIS：</p>
<ul>
<li><p>文件名解析：在IIS6.0下，分号后面不被解析，默认可执行文件：/.asa/.cer/.cdx</p>
</li>
<li><p>目录解析：网站目录有一个名为1.aso（其他的asp扩展名也可以），目录里面有一个1.jpg内容为asp的代码。访问:<a href="http://a.test.com/1.asp/1.jpg会被放成正常ASP文件执行。" target="_blank" rel="external">http://a.test.com/1.asp/1.jpg会被放成正常ASP文件执行。</a></p>
</li>
</ul>
<p>3.Apache：</p>
<ul>
<li><p>Apache是从右到左开始判断解析，如果为不和识别解析，就在往左判断。例如：mst.php.owf.rar,由于.owf和.rar不可识别解析，Apache就会把它解析为php</p>
</li>
<li><p><em>如何判断是不是合法的后缀就是这个漏洞利用的关键</em></p>
</li>
</ul>
<p>但是我不知道这个漏洞该如何修复</p>
<p>##IIS写入权限漏洞##</p>
<p>漏洞成因：</p>
<ul>
<li><p>IIS来宾用户对网站文件有写入权限</p>
</li>
<li><p>WEB服务扩展：webDev打钩</p>
</li>
<li><p>网站主目录：写入打钩</p>
</li>
<li><p>网站主目录：脚本资源访问打钩（可copy，Move）</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;定义:&lt;/em&gt;用户上传了一个可执行的脚本文件，并通过此脚本获得了执行服务器端的命令，也就是能通过菜刀连接获取WEBSHELL。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;常见的问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;上传的文件是web脚本语言，服务器解释并执行了用户上传的脚本，导致恶意代码执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上传的文件夹是木马或者病毒诱导网站管理员下载执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="http://www.craymc.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web安全-命令注入</title>
    <link href="http://www.craymc.com/2017/09/02/web%E5%AE%89%E5%85%A8-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/"/>
    <id>http://www.craymc.com/2017/09/02/web安全-命令注入/</id>
    <published>2017-09-02T14:16:51.000Z</published>
    <updated>2017-09-02T14:26:56.920Z</updated>
    
    <content type="html"><![CDATA[<p>类型：</p>
<ul>
<li><p>文件包含：把文件包含进来，执行其中的代码</p>
<pre><code>绕过方式：1.%00截断

         2.%00截断目录遍历

         3.路径长度截断

         4.点号截断
</code></pre></li>
<li><p>任意代码执行</p>
</li>
<li><p>任意命令执行</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件包含：把文件包含进来，执行其中的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;绕过方式：1.%00截断

         2.%00截断目录遍历

         3.路径长度截断

         4.点号截断
&lt;/code&gt;&lt;/p
    
    </summary>
    
    
      <category term="web安全" scheme="http://www.craymc.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web安全-逻辑漏洞</title>
    <link href="http://www.craymc.com/2017/09/02/web%E5%AE%89%E5%85%A8-%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    <id>http://www.craymc.com/2017/09/02/web安全-逻辑漏洞/</id>
    <published>2017-09-02T14:16:40.000Z</published>
    <updated>2017-09-02T14:26:54.873Z</updated>
    
    <content type="html"><![CDATA[<p><strong>定义：</strong>通常指网站业务功能方面的缺陷，开发者在思考过程中做出的特殊假装存在明显或者隐含的错误</p>
<p>举几个列子：<br><a id="more"></a></p>
<ol>
<li><p>密码找回（任意手机号注册）:程序根据一个验证码来确定是用户本人，但攻击者可以暴力破解密码</p>
</li>
<li><p>支付漏洞：修改商品数量为负数是的支付价格为负数，或者修改支付金额</p>
</li>
<li><p>越权</p>
</li>
<li><p>cookie和session验证问题（攻击者在知道用户ID的前提下，构造一个cookies或让session值为true就可以绕过验证）</p>
</li>
<li><p>顺序执行缺陷：假如在网购过程中直接从放入购物车调过支付直接进入先写收货地址步骤</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;通常指网站业务功能方面的缺陷，开发者在思考过程中做出的特殊假装存在明显或者隐含的错误&lt;/p&gt;
&lt;p&gt;举几个列子：&lt;br&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="http://www.craymc.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web安全-服务端安全</title>
    <link href="http://www.craymc.com/2017/09/02/web%E5%AE%89%E5%85%A8-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    <id>http://www.craymc.com/2017/09/02/web安全-服务端安全/</id>
    <published>2017-09-02T14:16:28.000Z</published>
    <updated>2017-09-02T14:26:47.415Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本质:</strong>服务器获取外部资源，修改外部资源，但是服务器并没有发现别修改，然后让其通过。服务器以自己的身份来访问其他服务器，然后实现了外网无法访问内网系统的需求。</p>
<p><strong>场景：</strong></p>
<ul>
<li><p>web应用使用了用户指定的URL获取数据（图片），然后把这个数据（图片）展示。</p>
</li>
<li><p>应用根据用户提供的URL，抓取用户的WEB站点，并生成WAP站</p>
</li>
<li><p>web应用的分享功能处，如果没有对目标地址的范围做过滤和限制，存在了SSRF    </p>
</li>
<li><p>转码服务，在线翻译，图片加载下载</p>
</li>
</ul>
<hr>
<a id="more"></a>
<p><strong>漏洞验证</strong></p>
<ul>
<li><p>常见的方法是排除法：比如一个URL+image=baidu.com/test.jpg,直接右键图片，在新窗口中打开图片，如果浏览器的URL是baidu.com/test.jpg则不存在</p>
</li>
<li><p>使用burp抓包，由于SSRF是服务端发起的请求，因此在加载资源的时候是由服务端发起的，所以在本地浏览器请求中就不应该存在资源的请求。</p>
</li>
</ul>
<hr>
<p><strong>防御</strong></p>
<ul>
<li>限制请求端口为常用端口</li>
<li>禁用不需要的网协议</li>
<li>内网IP限制</li>
</ul>
<hr>
<p> <strong>绕过</strong></p>
<ul>
<li>URL构造和URL跳转</li>
<li>IP转换为16进制，8进制</li>
<li>短网址绕过</li>
</ul>
<hr>
<p><strong>攻击</strong></p>
<ul>
<li><p>从容易出现的点进行排查</p>
</li>
<li><p>从URL关键字中寻找</p>
</li>
</ul>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p><em>定义:</em>用户上传了一个可执行的脚本文件，并通过此脚本获得了执行服务器端的命令，也就是能通过菜刀连接获取WEBSHELL。</p>
<hr>
<p><strong>常见的问题</strong></p>
<ul>
<li><p>上传的文件是web脚本语言，服务器解释并执行了用户上传的脚本，导致恶意代码执行</p>
</li>
<li><p>上传的文件夹是木马或者病毒诱导网站管理员下载执行</p>
</li>
</ul>
<hr>
<p><strong>利用</strong></p>
<ul>
<li>FCKEditor文件上传漏洞,ewebeditor漏洞</li>
</ul>
<hr>
<p><em>绕过方式</em></p>
<ul>
<li><p>抓包，改包（MIME修改绕过）</p>
</li>
<li><p>文件名后缀大小写绕过</p>
</li>
<li><p>文件内容绕过</p>
</li>
<li><p>JS绕过：</p>
<p>  1.HTTP数据包<br>  2.审查元素–取消JS函数的调用<br>  3.JS部分全部删掉<br>  4.禁止加载JS</p>
</li>
</ul>
<hr>
<p>##解析漏洞##</p>
<p>1.Nginx:</p>
<p>假如有一张图片：http:a.test.com/1.jpg.当我们正常访问，nginx会把这个当做非脚本语言直接读取传送回客户端（浏览器），但存在解析漏洞的nginx会把如下链接解析并执行<strong><a href="http://a.test.com" target="_blank" rel="external">http://a.test.com</a> :8080/1.jpg/1.php</strong></p>
<p>影响范围：0.765以下及0.8.37以下到8系列</p>
<p>2.IIS：</p>
<ul>
<li><p>文件名解析：在IIS6.0下，分号后面不被解析，默认可执行文件：/.asa/.cer/.cdx</p>
</li>
<li><p>目录解析：网站目录有一个名为1.aso（其他的asp扩展名也可以），目录里面有一个1.jpg内容为asp的代码。访问:<a href="http://a.test.com/1.asp/1.jpg会被放成正常ASP文件执行。" target="_blank" rel="external">http://a.test.com/1.asp/1.jpg会被放成正常ASP文件执行。</a></p>
</li>
</ul>
<p>3.Apache：</p>
<ul>
<li><p>Apache是从右到左开始判断解析，如果为不和识别解析，就在往左判断。例如：mst.php.owf.rar,由于.owf和.rar不可识别解析，Apache就会把它解析为php</p>
</li>
<li><p><em>如何判断是不是合法的后缀就是这个漏洞利用的关键</em></p>
</li>
</ul>
<p>但是我不知道这个漏洞该如何修复</p>
<p>##IIS写入权限漏洞##</p>
<p>漏洞成因：</p>
<ul>
<li><p>IIS来宾用户对网站文件有写入权限</p>
</li>
<li><p>WEB服务扩展：webDev打钩</p>
</li>
<li><p>网站主目录：写入打钩</p>
</li>
<li><p>网站主目录：脚本资源访问打钩（可copy，Move）</p>
</li>
</ul>
<hr>
<!--more-->
<h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><p>类型：</p>
<ul>
<li><p>文件包含：把文件包含进来，执行其中的代码</p>
<pre><code>绕过方式：1.%00截断

         2.%00截断目录遍历

         3.路径长度截断

         4.点号截断
</code></pre></li>
<li><p>任意代码执行</p>
</li>
<li><p>任意命令执行</p>
</li>
</ul>
<hr>
<h2 id="越权"><a href="#越权" class="headerlink" title="越权"></a>越权</h2><p><strong>原因：</strong> 开发人员在对数据进行CRUD的时候对客户端的请求过分相信而遗漏了权限的判定。</p>
<p><strong>分类</strong></p>
<ul>
<li>垂直：身份不变，权限改变</li>
</ul>
<ul>
<li>水平：权限不变，身份改变</li>
</ul>
<ul>
<li>交叉： 二者都改变</li>
</ul>
<hr>
<h3 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h3><p><strong>定义：</strong>通常指网站业务功能方面的缺陷，开发者在思考过程中做出的特殊假装存在明显或者隐含的错误</p>
<p>举几个列子：</p>
<ol>
<li><p>密码找回（任意手机号注册）:程序根据一个验证码来确定是用户本人，但攻击者可以暴力破解密码</p>
</li>
<li><p>支付漏洞：修改商品数量为负数是的支付价格为负数，或者修改支付金额</p>
</li>
<li><p>越权</p>
</li>
<li><p>cookie和session验证问题（攻击者在知道用户ID的前提下，构造一个cookies或让session值为true就可以绕过验证）</p>
</li>
<li><p>顺序执行缺陷：假如在网购过程中直接从放入购物车调过支付直接进入先写收货地址步骤</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本质:&lt;/strong&gt;服务器获取外部资源，修改外部资源，但是服务器并没有发现别修改，然后让其通过。服务器以自己的身份来访问其他服务器，然后实现了外网无法访问内网系统的需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;web应用使用了用户指定的URL获取数据（图片），然后把这个数据（图片）展示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应用根据用户提供的URL，抓取用户的WEB站点，并生成WAP站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;web应用的分享功能处，如果没有对目标地址的范围做过滤和限制，存在了SSRF    &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;转码服务，在线翻译，图片加载下载&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="http://www.craymc.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web安全-第三方风险</title>
    <link href="http://www.craymc.com/2017/09/02/web%E5%AE%89%E5%85%A8-%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A3%8E%E9%99%A9/"/>
    <id>http://www.craymc.com/2017/09/02/web安全-第三方风险/</id>
    <published>2017-09-02T14:16:02.000Z</published>
    <updated>2017-09-02T14:26:28.684Z</updated>
    
    <content type="html"><![CDATA[<p>分类：</p>
<ul>
<li><p>域名商</p>
</li>
<li><p>IDC</p>
</li>
<li><p>外域JS</p>
</li>
</ul>
<p>这一块我了解的大概方向就是这个三个，好多资料搜集的也不全。</p>
<hr>
<a id="more"></a>
<h3 id="web层中间件"><a href="#web层中间件" class="headerlink" title="web层中间件"></a>web层中间件</h3><p><em>分类</em>：</p>
<pre><code>1.Tomcat

2.weblogic

3.jboss

4.jonas

5.websphere    


这些WEB中间件是应用于Java web工程容器，脚本语言：jsp，可在kali下生产war包  jar -cvf test.war test,jsp
</code></pre><p><em>存在的漏洞</em>：</p>
<ul>
<li><p>弱口令</p>
</li>
<li><p>Java反序列</p>
</li>
<li><p>未授权</p>
</li>
<li><p>代码执行</p>
</li>
</ul>
<p><em>漏洞挖掘</em>：</p>
<ul>
<li><p>Nmap扫描以下端口：8080,7001,9990,9000,9043</p>
</li>
<li><p>注意以上5种类型的对应路径</p>
</li>
</ul>
<hr>
<h3 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h3><p>目前我了解到的有：</p>
<ul>
<li><p>spring框架反序列化漏洞：利用JtaTransactionManager类中可以被控制的readObject()方法，从而构造恶意的被序列化类，利用readObject()会触发远程恶意类中的构造函数达到自己的目的。</p>
</li>
<li><p>fastjson反序列化漏洞：可以通过JSON.parse    Object来实例化任何带有setter方法的类；攻击者可以构造恶意json字符串，当fastjson解析的时候，会导致任意代码的执行。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;域名商&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IDC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;外域JS&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一块我了解的大概方向就是这个三个，好多资料搜集的也不全。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="http://www.craymc.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web安全-SQL注入</title>
    <link href="http://www.craymc.com/2017/09/02/web%E5%AE%89%E5%85%A8-SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://www.craymc.com/2017/09/02/web安全-SQL注入/</id>
    <published>2017-09-02T14:15:40.000Z</published>
    <updated>2017-09-02T14:30:19.629Z</updated>
    
    <content type="html"><![CDATA[<p>###SQL注入注入##</p>
<p><em>注入类型：</em></p>
<ul>
<li><p>数字型：sql语句特点：ID=1</p>
</li>
<li><p>字符型：SQL语句特点：’admin’</p>
<pre><code>判断方式：&apos;and &apos;1&apos;=&apos;1

          &apos;and&apos;1&apos;=&apos;2
</code></pre><a id="more"></a>
</li>
<li><p>搜索型：sql语句特点：’%9%’</p>
<pre><code>判断方式: %&apos;and&apos;%1%&apos;=&apos;%1

         %&apos;and&apos;%1%&apos;=&apos;%2
</code></pre></li>
</ul>
<hr>
<p>当前阶段我主要使用的是sqlmap</p>
<p><em>SQL注入总结</em></p>
<h5 id="access偏移注入（当知道表名不知道列名的时候使用）"><a href="#access偏移注入（当知道表名不知道列名的时候使用）" class="headerlink" title="access偏移注入（当知道表名不知道列名的时候使用）"></a>access偏移注入（当知道表名不知道列名的时候使用）</h5><p>步骤：</p>
<ul>
<li><p>判断表名</p>
</li>
<li><p>判断字段长度：假设这里的字段长度为18我把它记做A</p>
</li>
<li><p>显示位数</p>
</li>
<li><p>判断表的字段数：假设这里的字段数为11我把它记做B</p>
</li>
<li><p>偏移注入的公式</p>
<pre><code>A-B=C

A-2C=D
</code></pre><p>  <strong>把这个D带入到 union select 1，2,3,4 from （表名  as  a inner jion 表名 as b on a.id=b.id）</strong></p>
</li>
<li><p>如果经过上一步操作没有得到结果就打乱顺序</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###SQL注入注入##&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注入类型：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数字型：sql语句特点：ID=1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字符型：SQL语句特点：’admin’&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;判断方式：&amp;apos;and &amp;apos;1&amp;apos;=&amp;apos;1

          &amp;apos;and&amp;apos;1&amp;apos;=&amp;apos;2
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="http://www.craymc.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web安全-ddos</title>
    <link href="http://www.craymc.com/2017/09/02/web%E5%AE%89%E5%85%A8-ddos/"/>
    <id>http://www.craymc.com/2017/09/02/web安全-ddos/</id>
    <published>2017-09-02T14:08:12.000Z</published>
    <updated>2017-09-02T14:13:30.558Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DDOS-分布式拒绝服务"><a href="#DDOS-分布式拒绝服务" class="headerlink" title="DDOS(分布式拒绝服务)"></a>DDOS(分布式拒绝服务)</h3><p><strong>理解：</strong> 以停车场来类比，系统就像是停车场，系统中的资源就是停车位。当车位都停满车之后，再有车想进来就必须等前面的车先出去才行，如果所有车位的车都不出去，那么停车场的入口就会出现堵塞，不能正常工作。即为：<em>拒绝服务</em></p>
<hr>
<a id="more"></a>
<p><strong>分类</strong></p>
<ul>
<li><p>协议层DDOS：</p>
<p>  SYN flood:利用TCP/IP三次握手的特点，伪造大量的源IP地址，分别向服务的端发送大量的SYN包，此时服务器会返回SYN/ACK包，因为源IP是伪造的，所以并不会进行应答，此时服务端会进行重试和等待。如果发送大量的伪造IP地址不断发送请求，服务端就会消耗大量的资源。那么就会发<br>  生一个情况，服务端无暇顾及正常访问的IP地址的请求，所以就会造成拒绝服务。</p>
</li>
<li><p>应用层DDOS：</p>
<p>  对一些资源消耗比较大的应用页面进行不断发起正常的请求，达到消耗服务端资源的目的。</p>
<p>  <em>常见的消耗资源比较大的场景有：查询数据库，读写硬盘文件操作</em></p>
</li>
</ul>
<ul>
<li><p>Slowloris：</p>
<p>  对web server连接数资源的恶意消耗，无限滥用。</p>
</li>
</ul>
<hr>
<p><strong>防御：</strong>只是知道一个理论上的防御方法就是<em>限制每个不可信任的资源使用者的配额</em>但是我不知道具体落实下来有什么可行的方案，之前了解过一种方案是：根据IP地址和COOKIE等信息，对客户端的请求频率进行计算，然后进行拦截。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;DDOS-分布式拒绝服务&quot;&gt;&lt;a href=&quot;#DDOS-分布式拒绝服务&quot; class=&quot;headerlink&quot; title=&quot;DDOS(分布式拒绝服务)&quot;&gt;&lt;/a&gt;DDOS(分布式拒绝服务)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;理解：&lt;/strong&gt; 以停车场来类比，系统就像是停车场，系统中的资源就是停车位。当车位都停满车之后，再有车想进来就必须等前面的车先出去才行，如果所有车位的车都不出去，那么停车场的入口就会出现堵塞，不能正常工作。即为：&lt;em&gt;拒绝服务&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="web安全" scheme="http://www.craymc.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>秒杀系统实现思路</title>
    <link href="http://www.craymc.com/2017/05/09/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/"/>
    <id>http://www.craymc.com/2017/05/09/秒杀系统实现思路/</id>
    <published>2017-05-09T12:40:43.000Z</published>
    <updated>2017-05-09T12:46:04.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何设计一个秒杀系统"><a href="#如何设计一个秒杀系统" class="headerlink" title="如何设计一个秒杀系统"></a>如何设计一个秒杀系统</h3><hr>
<h4 id="一-条件"><a href="#一-条件" class="headerlink" title="一.条件"></a>一.条件</h4><p>1.这是一个秒杀系统，即大量用户抢有限的商品，先到先得<br>2.用户并发访问流量非常大, 需要分布式的机器集群处理请求<br>3.系统实现使用Java</p>
<hr>
<h4 id="二-实现思路"><a href="#二-实现思路" class="headerlink" title="二.实现思路"></a>二.实现思路</h4><p>1.用户请求首先进入请求分发集群，该集群通过OCS等分布式缓存初步判断分发条件是否合适(例如是否还有库存，没有库存直接在这一步就停了)<br><a id="more"></a><br>2.分发集群发现还有库存，则将请求路由到负载较低的业务处理机器</p>
<p>3.业务处理机对分布式缓存进行count–原子操作(或在分布式缓存上自己实现CAS操作)，如果成功则进入数据库处理逻辑</p>
<p>4.数据库正确的进行了count–操作，给用户返回成功秒杀</p>
<p>5.如果数据库操作没有完成count–或者发现库存竟然没了，则触发分布式缓存重新加载数据库库存，同时返回给用户秒杀失败</p>
<hr>
<h4 id="三-模块设计"><a href="#三-模块设计" class="headerlink" title="三.模块设计"></a>三.模块设计</h4><p>1、用户请求分发模块：使用Nginx或Apache将用户的请求分发到不同的机器上。<br>2、用户请求预处理模块：判断商品是不是还有剩余来决定是不是要处理该请求。<br>3、用户请求处理模块：把通过预处理的请求封装成事务提交给数据库，并返回是否成功。<br>4、数据库接口模块：该模块是数据库的唯一接口，负责与数据库交互，提供RPC接口供查询是否秒杀结束、剩余数量等信息。</p>
<hr>
<h5 id="具体方案："><a href="#具体方案：" class="headerlink" title="具体方案："></a>具体方案：</h5><p>1.配置HTTP服务器<br>2.经过HTTP服务器的分发后，单个服务器的负载相对低了一些，但总量依然可能很大，如果后台商品已经被秒杀完毕，那么直接给后来的请求返回秒杀失败即可，不必再进一步发送事务了<br>3.<strong>并发队列的选择</strong> Java的并发包提供了三个常用的并发队列实现，分别是：ConcurrentLinkedQueue 、 LinkedBlockingQueue 和 ArrayBlockingQueue。</p>
<p>ArrayBlockingQueue是初始容量固定的阻塞队列，我们可以用来作为数据库模块成功竞拍的队列，比如有10个商品，那么我们就设定一个10大小的数组队列。</p>
<p>ConcurrentLinkedQueue使用的是CAS原语无锁队列实现，是一个异步队列，入队的速度很快，出队进行了加锁，性能稍慢。</p>
<p>LinkedBlockingQueue也是阻塞的队列，入队和出队都用了加锁，当队空的时候线程会暂时阻塞。</p>
<p>由于我们的系统入队需求要远大于出队需求，一般不会出现队空的情况，所以我们可以选择ConcurrentLinkedQueue来作为我们的请求队列实现。<br>4.<strong>数据库模块</strong> 数据库主要是使用一个ArrayBlockingQueue来暂存有可能成功的用户请求。</p>
<hr>
<p>参考资料：<br><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue" target="_blank" rel="external">http://www.infoq.com/cn/articles/ConcurrentLinkedQueue</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-concurrent/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/java/j-lo-concurrent/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何设计一个秒杀系统&quot;&gt;&lt;a href=&quot;#如何设计一个秒杀系统&quot; class=&quot;headerlink&quot; title=&quot;如何设计一个秒杀系统&quot;&gt;&lt;/a&gt;如何设计一个秒杀系统&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;一-条件&quot;&gt;&lt;a href=&quot;#一-条件&quot; class=&quot;headerlink&quot; title=&quot;一.条件&quot;&gt;&lt;/a&gt;一.条件&lt;/h4&gt;&lt;p&gt;1.这是一个秒杀系统，即大量用户抢有限的商品，先到先得&lt;br&gt;2.用户并发访问流量非常大, 需要分布式的机器集群处理请求&lt;br&gt;3.系统实现使用Java&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;二-实现思路&quot;&gt;&lt;a href=&quot;#二-实现思路&quot; class=&quot;headerlink&quot; title=&quot;二.实现思路&quot;&gt;&lt;/a&gt;二.实现思路&lt;/h4&gt;&lt;p&gt;1.用户请求首先进入请求分发集群，该集群通过OCS等分布式缓存初步判断分发条件是否合适(例如是否还有库存，没有库存直接在这一步就停了)&lt;br&gt;
    
    </summary>
    
    
      <category term="秒杀系统" scheme="http://www.craymc.com/tags/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>win8.1下vc6.0的安装详解</title>
    <link href="http://www.craymc.com/2017/03/11/win8-1%E4%B8%8Bvc6-0%E7%9A%84%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/03/11/win8-1下vc6-0的安装详解/</id>
    <published>2017-03-11T06:38:26.000Z</published>
    <updated>2017-03-11T06:41:01.437Z</updated>
    
    <content type="html"><![CDATA[<h4 id="本文主要为大家解答一下如何在win8-1下安装vc6-0的相关步骤和容易出现的问题"><a href="#本文主要为大家解答一下如何在win8-1下安装vc6-0的相关步骤和容易出现的问题" class="headerlink" title="本文主要为大家解答一下如何在win8.1下安装vc6.0的相关步骤和容易出现的问题"></a>本文主要为大家解答一下如何在win8.1下安装vc6.0的相关步骤和容易出现的问题</h4><hr>
<p>1.首先，提供一个下载的地址：<a href="http://pan.baidu.com/s/1gfMI9gv，下载之后安装，要先将" target="_blank" rel="external">http://pan.baidu.com/s/1gfMI9gv，下载之后安装，要先将</a> MSDEV.EXE 重命名为 MSDEV3.EXE或者4.5都行就是改变一下MSDEV.EXE他的名字即可。</p>
<p>2.在 VC6.0 的快捷方式或开始菜单上单击鼠标右键，选择“属性”：</p>
<p>3.在弹出的对话框中，将兼容模式修改为Windows XP SP3 或 SP2，并设置为“以管理员的身份运行”；<br><a id="more"></a></p>
<p>4.由于MSDEV.EXE 是 VC6.0 的主程序，位于 VC6.0 的安装目录下，可以在属性面板中快速找到 MSDEV.EXE（在属性中找到“快捷方式”，在快捷方式下找到“打开文件位置”）；</p>
<p>5.重命名完成后，还要修改快捷方式指向的目标文件，具体修改方法参照第四步；</p>
<p>6.启动VC6.0，如果报错，关闭后再次启动，一般就正常了。成功启动一次后，以后就可以正常运行了；</p>
<p>7.按照以上步骤完成，开始进行一个测试程序“hello world”，如果程序编写正确且出现<strong>错误 Compiling… Error spawning cl.exe 1.obj - 1 error(s), 0 warning(s）</strong>则需要进行以下修改：<br>            ①.打开vc界面 点击VC“TOOLS（工具）”—&gt;“Option（选择）” —&gt;“Directories（目录）”重新设置“Excutable Fils、Include Files、 Library Files、Source Files”的路径</p>
<pre><code>②.executatble files: 
    C:\Program Files\Microsoft Visual Studio\Common\MSDev98\Bin 
    C:\Program Files\Microsoft Visual Studio\VC98\BIN 
    C:\Program Files\Microsoft Visual Studio\Common\TOOLS 
    C:\Program Files\Microsoft Visual Studio\Common\TOOLS\WINNT 

③：include files: 
    C:\Program Files\Microsoft Visual Studio\VC98\INCLUDE 
    C:\Program Files\Microsoft Visual Studio\VC98\MFC\INCLUDE 
    C:\Program Files\Microsoft Visual Studio\VC98\ATL\INCLUDE 

④：library files: 
    C:\Program Files\Microsoft Visual Studio\VC98\LIB 
    C:\Program Files\Microsoft Visual Studio\VC98\MFC\LIB 


⑤：source files: 
    C:\Program Files\Microsoft Visual Studio\VC98\MFC\SRC 
    C:\Program Files\Microsoft Visual Studio\VC98\MFC\INCLUDE 
    C:\Program Files\Microsoft Visual Studio\VC98\ATL\INCLUDE 
    C:\Program Files\Microsoft Visual Studio\VC98\CRT\SRC
</code></pre><p>8.如果你的安装包了没有CRT\SRC，这里为大家提供以下下载地址：<a href="https://pan.baidu.com/s/1bo9JqCB" target="_blank" rel="external">https://pan.baidu.com/s/1bo9JqCB</a>  CRT</p>
<h2 id="9-出现这种情况一般是由于路径设置的问题引起的，这里默认为C盘，具体应该参照你自己安装vc6-0的路径进行替换。"><a href="#9-出现这种情况一般是由于路径设置的问题引起的，这里默认为C盘，具体应该参照你自己安装vc6-0的路径进行替换。" class="headerlink" title="9.出现这种情况一般是由于路径设置的问题引起的，这里默认为C盘，具体应该参照你自己安装vc6.0的路径进行替换。"></a>9.出现这种情况一般是由于路径设置的问题引起的，这里默认为C盘，具体应该参照你自己安装vc6.0的路径进行替换。</h2><p>正常情况下安装上述步骤进行就可以正常运行了，如果你出现了其他情况，请留言。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;本文主要为大家解答一下如何在win8-1下安装vc6-0的相关步骤和容易出现的问题&quot;&gt;&lt;a href=&quot;#本文主要为大家解答一下如何在win8-1下安装vc6-0的相关步骤和容易出现的问题&quot; class=&quot;headerlink&quot; title=&quot;本文主要为大家解答一下如何在win8.1下安装vc6.0的相关步骤和容易出现的问题&quot;&gt;&lt;/a&gt;本文主要为大家解答一下如何在win8.1下安装vc6.0的相关步骤和容易出现的问题&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;1.首先，提供一个下载的地址：&lt;a href=&quot;http://pan.baidu.com/s/1gfMI9gv，下载之后安装，要先将&quot;&gt;http://pan.baidu.com/s/1gfMI9gv，下载之后安装，要先将&lt;/a&gt; MSDEV.EXE 重命名为 MSDEV3.EXE或者4.5都行就是改变一下MSDEV.EXE他的名字即可。&lt;/p&gt;
&lt;p&gt;2.在 VC6.0 的快捷方式或开始菜单上单击鼠标右键，选择“属性”：&lt;/p&gt;
&lt;p&gt;3.在弹出的对话框中，将兼容模式修改为Windows XP SP3 或 SP2，并设置为“以管理员的身份运行”；&lt;br&gt;
    
    </summary>
    
    
      <category term="软件安装" scheme="http://www.craymc.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>基于ssh框架的员工管理系统的总结</title>
    <link href="http://www.craymc.com/2017/03/06/%E5%9F%BA%E4%BA%8Essh%E6%A1%86%E6%9E%B6%E7%9A%84%E5%91%98%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://www.craymc.com/2017/03/06/基于ssh框架的员工管理系统的总结/</id>
    <published>2017-03-06T05:23:24.000Z</published>
    <updated>2017-03-06T05:26:09.877Z</updated>
    
    <content type="html"><![CDATA[<p>一个基于ssh框架的员工管理系统的总结.md</p>
<h3 id="先来回顾一下SSH的知识点"><a href="#先来回顾一下SSH的知识点" class="headerlink" title="先来回顾一下SSH的知识点"></a>先来回顾一下SSH的知识点</h3><hr>
<h5 id="三大框架的整合的jar文件是根据实际需求来确定真正使用的jar-下面列举的是必须的jar文件和常用的jar文件，一般的项目这些个jar都会导入，除此之外会增加别的jar来完成所需的功能。"><a href="#三大框架的整合的jar文件是根据实际需求来确定真正使用的jar-下面列举的是必须的jar文件和常用的jar文件，一般的项目这些个jar都会导入，除此之外会增加别的jar来完成所需的功能。" class="headerlink" title="三大框架的整合的jar文件是根据实际需求来确定真正使用的jar,下面列举的是必须的jar文件和常用的jar文件，一般的项目这些个jar都会导入，除此之外会增加别的jar来完成所需的功能。"></a>三大框架的整合的jar文件是根据实际需求来确定真正使用的jar,下面列举的是必须的jar文件和常用的jar文件，一般的项目这些个jar都会导入，除此之外会增加别的jar来完成所需的功能。</h5><p>一、首先整合Struts2: </p>
<p>首先是必须要导入的jar文件 </p>
<p>1.导入struts-2.3.15.1-all\struts-2.3.15.1\apps\struts2-blank\WEB-INF\lib下面的所有的jar文件 </p>
<p>2.导入Struts2与Spring整合的jar文件struts-2.3.15.1-all\struts-2.3.15.1\lib下的struts2-spring-plugin-2.3.15.1.jar<br>其次导入可选的工具jar文件,例如:<br>1.struts2-json-plugin-2.3.15.1.jar，使用json并且整合Ajax的jar文件<br>2.struts2-convention-plugin-2.3.15.1.jar，使用注解开发的jar文件<br><a id="more"></a></p>
<p>二、然后导入Hibernate的相关jar文件 </p>
<p>1.核心的jar文件:hibernate3.jar </p>
<p>2.lib\required目录下所有的jar文件 </p>
<p>3.lib\jpa目录下所有的jar文件 </p>
<p>4.数据库的驱动的jar文件 </p>
<p>5.数据库的连接池所使用的jar文件 </p>
<p>6.slf4j整合log4j的使用的jar文件 </p>
<p>7.使用二级缓存的jar文件 </p>
<p>三、最后导入Spring的jar文件(这里使用的是Spring的3.2版本): </p>
<hr>
<h4 id="项目配置文件的整理"><a href="#项目配置文件的整理" class="headerlink" title="项目配置文件的整理:"></a>项目配置文件的整理:</h4><p>一、struts2的配置文件:<br>1.配置web.xml:<br>2.配置struts.xml:配置请求映射，以及方法处理之后的跳转：<br>二、Spring的配置文件:<br>1.web.xml中<br>2.applicationContext.xml中:进行Bean的管理，管理事务等。<br>3.在src下引入log4j.properties属性文件.</p>
<h2 id="4-最后实现逻辑部分。"><a href="#4-最后实现逻辑部分。" class="headerlink" title="4.最后实现逻辑部分。"></a>4.最后实现逻辑部分。</h2><p>#####　在完成框架搭建后，谈一下关于本项目的一些需要注意的地方和在开发过程中遇到的一些问题及解决办法：</p>
<p>1.依赖注入的理解：依赖注入是Spring的思想,在使用Spring进行开发时，可以将对象交给spring进行管理，在初始化时spring创建一批对象，当你需要用的时候只要从spring的容器中获取对象，而不用自己去new，当然在对象创建的时候可以注入另一个对象。比如A,B两个对象都由spring管理，A中持有对B的引用，那么spring在生成A对象的时候就已经吧B对象的一个实例给到A了，当你在A中用到B的时候直接使用就可以了。如果还要实例的话就不需要用spring了，spring就是做管理这些对象的实例工作.applicationContext.xml里配置的bean可以看成就是已经实例了，且默认是单例的。</p>
<p>2.ioc就是其实就是依赖注入，即用接口编程，在程序中不出现new关键字，而是用接口来命名引用，然后通过某种方式（多数用spring，不过Google guice也是很好的ioc框架）把接口的某个实现类的实例注入到引用里，从而实现与接口具体实现类的松耦合<br>aop方式就理解起来就简单了，其方式很类似j2ee中的filter，就是在程序正常的业务流中间像切面一样插入很多其他需要执行的代码，比如登陆时候在进入登录页面前写入日志，登录以后查看cookie等类似的操作，很常用的，尤其是跟数据库有关的，或者跟支付有关的程序肯定会在每一步前面插入日志，还有某些国际化项目会在每次跳转时候都转换字符集之类</p>
<p>3.在页面录入信息的时候出现乱码的解决方法：jdbc.url= jdbc\:mysql\://localhost\:3306/你项目的名称?characterEncoding\=utf8</p>
<p>4.%{}是保证’{‘ 和 ‘}’之间的内容是OGNL表达式 ，如果这样写<s:textfield value="#model.dname">会发现输出的是#model.dname而不是你想要的值<br>因为value并不是默认执行OGNL表达式的，而是字符串%{}是为了保证用OGNL的表达式去执行{}里面的字符串</s:textfield></p>
<p>5.通过本项目能掌握对SSH的整合，对web层，业务层，持久层的一个整体感知，可以体会到框架带给我们的便利。</p>
<hr>
<p>最后附上项目源码的地址：<a href="https://github.com/geekmc/ssh--" target="_blank" rel="external">https://github.com/geekmc/ssh--</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个基于ssh框架的员工管理系统的总结.md&lt;/p&gt;
&lt;h3 id=&quot;先来回顾一下SSH的知识点&quot;&gt;&lt;a href=&quot;#先来回顾一下SSH的知识点&quot; class=&quot;headerlink&quot; title=&quot;先来回顾一下SSH的知识点&quot;&gt;&lt;/a&gt;先来回顾一下SSH的知识点&lt;/h3&gt;&lt;hr&gt;
&lt;h5 id=&quot;三大框架的整合的jar文件是根据实际需求来确定真正使用的jar-下面列举的是必须的jar文件和常用的jar文件，一般的项目这些个jar都会导入，除此之外会增加别的jar来完成所需的功能。&quot;&gt;&lt;a href=&quot;#三大框架的整合的jar文件是根据实际需求来确定真正使用的jar-下面列举的是必须的jar文件和常用的jar文件，一般的项目这些个jar都会导入，除此之外会增加别的jar来完成所需的功能。&quot; class=&quot;headerlink&quot; title=&quot;三大框架的整合的jar文件是根据实际需求来确定真正使用的jar,下面列举的是必须的jar文件和常用的jar文件，一般的项目这些个jar都会导入，除此之外会增加别的jar来完成所需的功能。&quot;&gt;&lt;/a&gt;三大框架的整合的jar文件是根据实际需求来确定真正使用的jar,下面列举的是必须的jar文件和常用的jar文件，一般的项目这些个jar都会导入，除此之外会增加别的jar来完成所需的功能。&lt;/h5&gt;&lt;p&gt;一、首先整合Struts2: &lt;/p&gt;
&lt;p&gt;首先是必须要导入的jar文件 &lt;/p&gt;
&lt;p&gt;1.导入struts-2.3.15.1-all\struts-2.3.15.1\apps\struts2-blank\WEB-INF\lib下面的所有的jar文件 &lt;/p&gt;
&lt;p&gt;2.导入Struts2与Spring整合的jar文件struts-2.3.15.1-all\struts-2.3.15.1\lib下的struts2-spring-plugin-2.3.15.1.jar&lt;br&gt;其次导入可选的工具jar文件,例如:&lt;br&gt;1.struts2-json-plugin-2.3.15.1.jar，使用json并且整合Ajax的jar文件&lt;br&gt;2.struts2-convention-plugin-2.3.15.1.jar，使用注解开发的jar文件&lt;br&gt;
    
    </summary>
    
    
      <category term="J2EE" scheme="http://www.craymc.com/tags/J2EE/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础知识</title>
    <link href="http://www.craymc.com/2017/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.craymc.com/2017/02/08/计算机网络基础知识/</id>
    <published>2017-02-08T06:01:26.000Z</published>
    <updated>2017-03-06T05:27:18.871Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先从协议开始"><a href="#先从协议开始" class="headerlink" title="先从协议开始"></a>先从协议开始</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<p><strong>OSI，TCP/IP，五层协议的体系结构，以及各层协议</strong></p>
<p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。<br>每一层的协议如下：<br>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS<br><a id="more"></a><br>每一层的作用如下：<br>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</p>
<h2 id="应用层：允许访问OSI环境的手段（应用协议数据单元APDU）"><a href="#应用层：允许访问OSI环境的手段（应用协议数据单元APDU）" class="headerlink" title="应用层：允许访问OSI环境的手段（应用协议数据单元APDU）"></a>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</h2><p><strong>IP地址的分类</strong><br>A类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；<br>B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；<br>C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；<br>10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部）</p>
<h2 id="IP地址与子网掩码相与得到网络号"><a href="#IP地址与子网掩码相与得到网络号" class="headerlink" title="IP地址与子网掩码相与得到网络号"></a>IP地址与子网掩码相与得到网络号</h2><p><strong>ARP是地址解析协议的理解</strong><br>1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。<br>2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。<br>3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。<br>4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<h2 id="广播发送ARP请求，单播发送ARP响应。"><a href="#广播发送ARP请求，单播发送ARP响应。" class="headerlink" title="广播发送ARP请求，单播发送ARP响应。"></a>广播发送ARP请求，单播发送ARP响应。</h2><p><strong>各种协议的介绍</strong><br>ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。<br>TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。<br>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<br>DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。<br>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，</p>
<h2 id="DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。"><a href="#DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。" class="headerlink" title="DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。"></a>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</h2><p><strong>描述RARP协议</strong></p>
<h2 id="RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。"><a href="#RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。" class="headerlink" title="RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。"></a>RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。</h2><p><strong>TCP三次握手和四次挥手的全过程</strong><br>三次握手：<br>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。<br>四次挥手<br>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。<br>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。<br>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<h2 id="第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号-1，至此，完成四次挥手。"><a href="#第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号-1，至此，完成四次挥手。" class="headerlink" title="第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。"></a>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</h2><p><strong>浏览器执行网络URL的过程</strong><br>1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。<br>2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。<br>3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<h2 id="4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。"><a href="#4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。" class="headerlink" title="4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。"></a>4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</h2><p><strong>TCP和UDP的区别</strong><br>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。<br>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。<br>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。<br>TCP对应的协议和UDP对应的协议<br>TCP对应的协议：<br>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。<br>UDP对应的协议：<br>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<h2 id="（3）-TFTP-Trival-File-Tran敏感词er-Protocal-，简单文件传输协议，该协议在熟知端口69上使用UDP服务。"><a href="#（3）-TFTP-Trival-File-Tran敏感词er-Protocal-，简单文件传输协议，该协议在熟知端口69上使用UDP服务。" class="headerlink" title="（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。"></a>（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</h2><p><strong>TCP为什么是安全的UDP为什么不安全</strong></p>
<h2 id="TCP提供面向连接服务，传输数据前必须先建立连接，接收方确认，数据传输后要释放链接。比如说电子邮件。UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认。提供不可靠交付，比如说qq用的就是UDP协议，优点是传输效率高。"><a href="#TCP提供面向连接服务，传输数据前必须先建立连接，接收方确认，数据传输后要释放链接。比如说电子邮件。UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认。提供不可靠交付，比如说qq用的就是UDP协议，优点是传输效率高。" class="headerlink" title="TCP提供面向连接服务，传输数据前必须先建立连接，接收方确认，数据传输后要释放链接。比如说电子邮件。UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认。提供不可靠交付，比如说qq用的就是UDP协议，优点是传输效率高。"></a>TCP提供面向连接服务，传输数据前必须先建立连接，接收方确认，数据传输后要释放链接。比如说电子邮件。UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认。提供不可靠交付，比如说qq用的就是UDP协议，优点是传输效率高。</h2><p><strong>DNS域名系统，简单描述其工作原理</strong><br>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。<br>面向连接和非面向连接的服务的特点是什么？<br>面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。</p>
<h2 id="非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。"><a href="#非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。" class="headerlink" title="非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。"></a>非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。</h2><p><strong>TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</strong><br>建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。<br>（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。<br>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。</p>
<h2 id="（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。"><a href="#（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。" class="headerlink" title="（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。"></a>（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</h2><p><strong>交换机、路由器、网关的概念，和各自的用途</strong><br>1）交换机<br>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。<br>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。<br>交换机被广泛应用于二层网络交换，俗称“二层交换机”。<br>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。<br>2）路由器<br>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。<br>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。<br>3）网关<br>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。<br>在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。<br>在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。<br>网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。</p>
<h2 id="对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。"><a href="#对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。" class="headerlink" title="对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。"></a>对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;先从协议开始&quot;&gt;&lt;a href=&quot;#先从协议开始&quot; class=&quot;headerlink&quot; title=&quot;先从协议开始&quot;&gt;&lt;/a&gt;先从协议开始&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;OSI，TCP/IP，五层协议的体系结构，以及各层协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。&lt;br&gt;TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。&lt;br&gt;五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。&lt;br&gt;每一层的协议如下：&lt;br&gt;物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）&lt;br&gt;数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）&lt;br&gt;网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）&lt;br&gt;传输层：TCP、UDP、SPX&lt;br&gt;会话层：NFS、SQL、NETBIOS、RPC&lt;br&gt;表示层：JPEG、MPEG、ASII&lt;br&gt;应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS&lt;br&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://www.craymc.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>解释器模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/解释器模式详解/</id>
    <published>2017-01-29T04:10:57.000Z</published>
    <updated>2017-01-29T04:12:58.922Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解释器模式详解"><a href="#解释器模式详解" class="headerlink" title="解释器模式详解"></a>解释器模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。"><a href="#定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。" class="headerlink" title="定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。"></a>定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</h4><hr>
<h4 id="理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。"><a href="#理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。" class="headerlink" title="理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。"></a>理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。</h4><hr>
<h4 id="解释器模式的结构与使用"><a href="#解释器模式的结构与使用" class="headerlink" title="解释器模式的结构与使用"></a>解释器模式的结构与使用</h4><p>解释器模式包括四种角色：</p>
<ul>
<li>抽象表达式：该角色为一个接口，负责定义抽象的解释操作。</li>
<li>终结符表达式：实现AbstracttExpression接口的类。该类接口中的解释操作实现为与文法中的终结符相关联的操作，既文法中每个终结符号需要一个TerminalExpression类。</li>
<li>非终结者符表达式：实现AbstractExpression接口的类。文法中是每一条规则都需要一个NonterminalExpression类。NonterminalExpression类为文法中的非终结符号实现解释器操作，该解释器操作通常使用递归表示哪些对象的解释操作。</li>
<li>上下文：包含解释器之外的一些全局信息。</li>
</ul>
<hr>
<h4 id="解释器模式的优点"><a href="#解释器模式的优点" class="headerlink" title="解释器模式的优点"></a>解释器模式的优点</h4><ul>
<li>将每一个语法规则表示成一个类，方便与实现简单的语言。</li>
<li>由于使用类表示语法规则，可以较容易改变或扩展语言的行为。</li>
<li>通过在类结构中加入新的方法，可以在解释的同时增加新的行为。</li>
</ul>
<hr>
<h4 id="适合使用解释模式的场景"><a href="#适合使用解释模式的场景" class="headerlink" title="适合使用解释模式的场景"></a>适合使用解释模式的场景</h4><h2 id="当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。"><a href="#当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。" class="headerlink" title="当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。"></a>当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。</h2><h4 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h4><p>使用解释器模式设计程序有三个步骤：</p>
<ul>
<li>解析出语句中的动作标记</li>
<li>将标记归纳为动作</li>
<li>执行动作</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h5 id="抽象表达式"><a href="#抽象表达式" class="headerlink" title="抽象表达式"></a>抽象表达式</h5><pre><code>public interface Node {
public void parse(Context context);
public void execute();
}
</code></pre><h5 id="终结符表达式"><a href="#终结符表达式" class="headerlink" title="终结符表达式"></a>终结符表达式</h5><pre><code>public class SubjectPronounOrNounNode implements Node {
String []word={&quot;you&quot;,&quot;He &quot;,&quot;Teacher&quot;,&quot;Student&quot;};
String token;
boolean boo;
@Override
public void parse(Context context) {
    token=context.nextToken();
    int i = 0;
    for (i = 0; i &lt; word.length; i++) {
        if(token.equalsIgnoreCase(word[i])){
            boo=true;
            break;
        }
    }
    if(i==word.length)
        boo=false;
            }

@Override
public void execute() {
        if(boo){
            if(token.equalsIgnoreCase(word[0]));
                System.out.println(&quot;你&quot;);
            if(token.equalsIgnoreCase(word[1]));
                System.out.println(&quot;它&quot;);
            if(token.equalsIgnoreCase(word[2]));
                System.out.println(&quot;老师&quot;);
            if(token.equalsIgnoreCase(word[3]));
                System.out.println(&quot;学生&quot;);
        }    else{
            System.out.println(token+&quot;(NO)&quot;);
        }

}


}

public class ObjectPronounOrNouNode implements Node {
    String []word={&quot;ME&quot;,&quot;Him&quot;,&quot;Tiger&quot;,&quot;Apple&quot;};
    String token;
    boolean boo;


    @Override
    public void parse(Context context) {
        token=context.nextToken();
        int i=0;
        for (i = 0; i &lt; word.length;i ++) {
            if(token.equalsIgnoreCase(word[i])){
                boo=true;
                break;
            }
        }
        if(i==word.length)
            boo=false;
}

@Override
public void execute() {
        if(boo){
        if(token.equalsIgnoreCase(word[0]));
            System.out.println(&quot;我&quot;);
        if(token.equalsIgnoreCase(word[1]));
            System.out.println(&quot;他&quot;);
        if(token.equalsIgnoreCase(word[2]));
            System.out.println(&quot;老虎&quot;);
        if(token.equalsIgnoreCase(word[3]));
            System.out.println(&quot;苹果&quot;);
    }    else{
        System.out.println(token+&quot;(NO)&quot;);
    }

}            
}

public class VerbNode implements Node {
String []word={&quot;Drink&quot;,&quot;Eat&quot;,&quot;Look&quot;,&quot;beat&quot;};
String token;
boolean boo;


@Override
public void parse(Context context) {
    token=context.nextToken();
    int i=0;
    for ( i = 0; i &lt; word.length; i++) {
        if(token.equalsIgnoreCase(word[i])){
            boo=true;
            break;
        }
    }
    if(i==word.length)
        boo=false;
}

@Override
public void execute() {
    if(boo){
        if(token.equalsIgnoreCase(word[0]));
        System.out.println(&quot;吃&quot;);
    if(token.equalsIgnoreCase(word[1]));
        System.out.println(&quot;喝&quot;);
    if(token.equalsIgnoreCase(word[2]));
        System.out.println(&quot;看&quot;);
    if(token.equalsIgnoreCase(word[3]));
        System.out.println(&quot;打&quot;);
}    else{
    System.out.println(token+&quot;(NO)&quot;);
}


    }


}
</code></pre><h5 id="非终结符表达式"><a href="#非终结符表达式" class="headerlink" title="非终结符表达式"></a>非终结符表达式</h5><pre><code>public class SentenceNode implements Node{

Node subjectNode,predicateNode;


@Override
public void parse(Context context) {
    subjectNode=new SubjectNode();
    predicateNode=new PredicateNode();
    subjectNode.parse(context);
    predicateNode.parse(context);
}

@Override
public void execute() {
    subjectNode.execute();
    predicateNode.execute();
}

}
public class SubjectNode implements Node {

Node node;

@Override
public void parse(Context context) {
    node=new SubjectPronounOrNounNode();
    node.parse(context);
}

@Override
public void execute() {
    node.execute();
}

}
public class PredicateNode implements Node {
Node verbNode,objectNode;

@Override
public void parse(Context context) {
    verbNode=new VerbNode();
    objectNode=new ObjectPronounOrNouNode();
    verbNode.parse(context);
    objectNode.parse(context);
}

@Override
public void execute() {
    verbNode.execute();
    objectNode.execute();
}

}
</code></pre><h5 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h5><pre><code>import java.util.StringTokenizer;

public class Context {
    StringTokenizer tokenizer;
    String token;
    public Context(String text) {
    setContext(text);
    }
    public void setContext(String text){
    tokenizer=new StringTokenizer(text);
    }
    String nextToken(){
        if(tokenizer.hasMoreTokens()){
        token=tokenizer.nextToken();
    }else
        token=&quot;&quot;;

    return token;

}
}
</code></pre><h5 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h5><pre><code>public class Application {
public static void main(String[] args) {
    String text=&quot;Teacher beat tiger&quot;;
    Context context=new Context(text);
    Node node=new SentenceNode();
    node.parse(context);
    node.execute();
    text=&quot;You eat apple&quot;;
    context.setContext(text);
    System.out.println();
    node.parse(context);
    node.execute();
    text=&quot;you look him&quot;;
    context.setContext(text);
    System.out.println();
    node.parse(context);
    node.execute();
}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;解释器模式详解&quot;&gt;&lt;a href=&quot;#解释器模式详解&quot; class=&quot;headerlink&quot; title=&quot;解释器模式详解&quot;&gt;&lt;/a&gt;解释器模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>备忘录模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/备忘录模式详解/</id>
    <published>2017-01-29T04:10:34.000Z</published>
    <updated>2017-01-29T04:13:37.223Z</updated>
    
    <content type="html"><![CDATA[<h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><h2 id="定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。"><a href="#定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。" class="headerlink" title="###　定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。"></a>###　定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。</h2><h4 id="理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。"><a href="#理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。" class="headerlink" title="理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。"></a>理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。</h4><hr>
<h4 id="核心：备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。"><a href="#核心：备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。" class="headerlink" title="核心：备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。"></a><strong>核心：</strong>备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>备忘录模式包括三种角色：</p>
<ul>
<li>原发者：需要在某个时刻保存其状态的对象。原发者负责创建备忘录，然后原发者使用该备忘录记录自己的状态。当原发者需要恢复某个时刻的状态时，它通过获得相应备忘录中的数据来恢复那个时刻的状态。</li>
<li>备忘录：负责存储原发者状态的对象，创建备忘录的类和创建原发者的类在同一个包中的类是实例才可以访问备忘录中的数据。</li>
<li>负责人：负责保管保存备忘录的对象。负责人如果需要将备忘录保存到磁盘，负责人可以使用对象流将备忘录写入文件。</li>
</ul>
<hr>
<h4 id="备忘录的优点"><a href="#备忘录的优点" class="headerlink" title="备忘录的优点"></a>备忘录的优点</h4><ul>
<li>备忘录模式使用备忘录可以把原发者的内部状态保存起来，使只有恨“亲密的”对象可以访问备忘录中的数据。</li>
<li>备忘录模式强调了类设计单一责任原则，既将状态的刻画和保存分开。</li>
</ul>
<hr>
<h4 id="使用备忘录模式的场景"><a href="#使用备忘录模式的场景" class="headerlink" title="使用备忘录模式的场景"></a>使用备忘录模式的场景</h4><ul>
<li>必须保存一个对象在某一时刻的全部或部分状态，以便在需要的时刻恢复该对象先前的状态。</li>
<li>一个对象不想通过提供public权限的，且想让其他对象得到自己的内部状态。</li>
</ul>
<hr>
<h5 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h5><h6 id="原发者"><a href="#原发者" class="headerlink" title="原发者"></a>原发者</h6><pre><code>import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

public class ReaderPhrase {
    long readPosition;
    File file;
    RandomAccessFile in;
    String phrase=null;
    public ReaderPhrase(File file) {
        this.file = file;
        try {
        in=new RandomAccessFile(file, &quot;r&quot;);

    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
}
public Memento createMemento(){
    Memento mem=new Memento();
    mem.setPositionState(readPosition);
    return mem;
}
public void restoreFromMemento(Memento mem){
    readPosition=mem.getPositionState();
}
public String readLine(){
    try {
        in.seek(readPosition);
        if(phrase!=null){
            byte b[]=phrase.getBytes(&quot;iso-8859-1&quot;);
            phrase=new String(b);
        }
        readPosition=in.getFilePointer();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return phrase;
}
public void closeRead(){
    try {
        in.close();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}

}
</code></pre><h6 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h6><pre><code>public class Memento implements java.io.Serializable{
        private long state;
        void setPositionState(long state){
        this.state=state;
        }
        long getPositionState(){
        return state;
        }

}
</code></pre><h6 id="负责人"><a href="#负责人" class="headerlink" title="负责人"></a>负责人</h6><pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class Caretaker {
File file;
private Memento memento=null;
public Caretaker() {
        file=new File(&quot;&quot;);
}
public Memento getMemento(){
    if(file.exists()){
        try {
            FileInputStream in=new FileInputStream(&quot;&quot;);
            ObjectInputStream inObject = null;
            try {
                inObject = new ObjectInputStream(in);
            } catch (IOException e1) {
                // TODO Auto-generated catch block
                e1.printStackTrace();
            }
            try {
                try {
                    memento=(Memento) inObject.readObject();
                } catch (ClassNotFoundException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }
    return memento;
}
public void saveMemento(Memento memento) {
    FileOutputStream out = null;
    try {
        out = new FileOutputStream(&quot;&quot;);
    } catch (FileNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    try {
        ObjectOutputStream outObject=new ObjectOutputStream(out);
        outObject.writeObject(memento);
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}

}
</code></pre><h6 id="模式的使用"><a href="#模式的使用" class="headerlink" title="模式的使用"></a>模式的使用</h6><pre><code>import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.Scanner;


public class Application {
    public static void main(String[] args) {
        Scanner reader=new Scanner(System.in);
        ReaderPhrase readerPhrase=new ReaderPhrase(new File(&quot;&quot;));
        File favorPhrase=new File(&quot;&quot;);
        RandomAccessFile out =null;
        try {
            out= new RandomAccessFile(favorPhrase, &quot;rw&quot;);

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Y or N&quot;);
        String answer=reader.nextLine();
        if(answer.startsWith(&quot;y&quot;)||answer.startsWith(&quot;Y&quot;)){
            Caretaker caretaker=new Caretaker();
            Memento memento=caretaker.getMemento();
            if(memento!=null)
                readerPhrase.restoreFromMemento(memento);
        }
            String phrase=null;
            while((phrase=readerPhrase.readLine())!=null){
                System.out.println(phrase);
                System.out.println();
                answer=reader.nextLine();
                if(answer.startsWith(&quot;y&quot;)||answer.startsWith(&quot;Y&quot;)){
                    try {
                        out.seek(favorPhrase.length());
                        byte []b=phrase.getBytes();
                        out.write(b);
                        out.writeChar(&apos;\n&apos;);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&quot;Y or Y&quot;);
                    answer=reader.nextLine();
                    if(answer.startsWith(&quot;y&quot;)||answer.startsWith(&quot;Y&quot;))
                        continue;
                    else{
                        readerPhrase.closeRead();
                        Caretaker caretaker=new Caretaker();
                        caretaker.saveMemento(readerPhrase.createMemento());

                        try {
                                out.close();

                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        System.exit(0);;
                    }
                }
                System.out.println(&quot;OK&quot;);
            }
}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;h2 id=&quot;定义：在
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>享元模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/享元模式详解/</id>
    <published>2017-01-29T04:10:15.000Z</published>
    <updated>2017-01-29T04:14:09.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：运用共享技术有效地支持大量细粒度的对象。"><a href="#定义：运用共享技术有效地支持大量细粒度的对象。" class="headerlink" title="定义：运用共享技术有效地支持大量细粒度的对象。"></a>定义：运用共享技术有效地支持大量细粒度的对象。</h3><hr>
<h4 id="理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。"><a href="#理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。" class="headerlink" title="理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。"></a>理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。</h4><hr>
<h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>享元模式包括三种角色：</p>
<ul>
<li>享元接口：是一个接口，该接口定义了享元对外公开其内部数据的方法，以及享元接收外部数据的方法。</li>
<li>具体享元：实现享元接口的类，该类的实例称为享元对象，或简称享元。具体享元类的成员变量为享元对象的应用程序无法更改享元的内部状态，只有这样才能使得享元对象在系统中被共享。因为享元对象是用来共享的，所以不能允许用户各自地使用具体享元类来创建的对象显然是不同的，所以，具体享元类的构造方法必须是private的，其目的是不允许用户程序直接使用具体享元类创建享元对象，创建和管理享元对象由享元工厂负责。</li>
<li>享元工厂：享元工厂是一个类，该类的实例负责创建和管理享元对象，用户或其他对象必须请求享元工厂为它得到一个享元对象，当用户程序或其他若干个对象向享元对象，用户或其他对象必须请求享元对象，当用户程序或其他若干个对象向享元对象提供给请求者，否则就创建一个享元对象添加到散列表中，同时将该享元对象提供给请求者。显然，当若干个用户或对象请求享元工厂提供一个享元对象时，第一个用户获得该享元对象的时间可能慢一些，但是后继的用户会较快地获得这个享元对象。可以使用单列模式来设计享元工厂，既让系统中只有一个享元工厂的实例。另外，为了让享元工厂能生成享元对象，需要将具体享元类作为享元工厂的内部类。</li>
</ul>
<hr>
<h4 id="享元模式的优点"><a href="#享元模式的优点" class="headerlink" title="享元模式的优点"></a>享元模式的优点</h4><ul>
<li>使用享元可以节省内存的开销，特别适合处理大量细粒度对象，这些对象的许多属性值是相同的，而且一旦创建则不容许修改。</li>
<li>享元模式中的享元可以使用方法的参数接收外部状态中的数据，但外部状态数据不会干扰到享元中的内部数据，这就使享元可以在不同的环境中被共享。</li>
</ul>
<hr>
<h4 id="适合享元模式的场景"><a href="#适合享元模式的场景" class="headerlink" title="适合享元模式的场景"></a>适合享元模式的场景</h4><ul>
<li>一个应用程序使用大量的对象，这些对象之间部分属性本质上是相同的，这时应使用享元来封装相同的部分。</li>
<li>对象的多数状态都可变为外部状态，就可以考虑将这样对象作为系统中的享元来使用。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h5 id="享元接口"><a href="#享元接口" class="headerlink" title="享元接口"></a>享元接口</h5><pre><code>public interface Flyweight {
    public double getHeight();
    public double getWidth();
    public double getLength();
    public void printMess(String mess);
}
</code></pre><h5 id="享元工厂与具体享元"><a href="#享元工厂与具体享元" class="headerlink" title="享元工厂与具体享元"></a>享元工厂与具体享元</h5><pre><code>import java.util.HashMap;

public class FlyweightFactory {
        private HashMap&lt;String, Flyweight&gt; hashMap;
        static FlyweightFactory factory=new FlyweightFactory();
        private FlyweightFactory(){
            hashMap=new HashMap&lt;String,Flyweight&gt;();
        }
        public static FlyweightFactory getFactory(){
            return factory;
        }
        public synchronized Flyweight getFlyweight(String key){
            if(hashMap.containsKey(key))
                return hashMap.get(key);
            else{
                    double width=0,height=0,length=0;
                    String []str=key.split(&quot;#&quot;);
                    width=Double.parseDouble(str[0]);
                    height=Double.parseDouble(str[1]);
                    length=Double.parseDouble(str[2]);
                    Flyweight ft= new ConcreFlyweight(width, height, length);
                    hashMap.put(key, ft);
                    return ft;
                }
}
class ConcreFlyweight implements Flyweight{

    private double width;
    private double height;
    private double length;


    private ConcreFlyweight(double width, double height, double length) {
    this.width = width;
    this.height = height;
    this.length = length;
    }

    @Override
    public double getHeight() {

        return height;
    }

    @Override
    public double getWidth() {

        return width;
    }

    @Override
    public double getLength() {

    return length;
    }

    @Override
    public void printMess(String mess) {
        System.out.println(mess);
        System.out.println(&quot;宽度：&quot;+width);
        System.out.println(&quot;高度：&quot;+height);
        System.out.println(&quot;长度：&quot;+length);
    }
}
}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>public class Car {
    Flyweight flyweight;
    String name,color;
    int power;
    public Car(Flyweight flyweight, String name, String color, int power) {
    super();
    this.flyweight = flyweight;
    this.name = name;
    this.color = color;
    this.power = power;
    }
    public void print(){
        System.out.println(&quot;名称：&quot;+name);
        System.out.println(&quot;颜色：&quot;+color);
        System.out.println(&quot;功率：&quot;+power);
        System.out.println(&quot;宽度：&quot;+flyweight.getWidth());
        System.out.println(&quot;高度:&quot;+flyweight.getHeight());
        System.out.println(&quot;长度:&quot;+flyweight.getLength());
    }

}

public class Application {

    public static void main(String[] args) {

        FlyweightFactory factory=FlyweightFactory.getFactory();

        double width=1.82,height=1.47,length=5.12;

        String key=&quot;&quot;+width+&quot;#&quot;+height+&quot;#&quot;+length;

        Flyweight flyweight=factory.getFlyweight(key);

        Car audiA6One=new Car(flyweight, &quot;奥迪&quot;, &quot;黑色&quot;, 128);

        Car audiA6Two=new Car(flyweight, &quot;奥迪&quot;, &quot;灰色&quot;, 160);

        audiA6One.print();
        audiA6Two.print();

        width=1.77;
        height=1.45;
        length=4.63;

        key=&quot;&quot;+width+&quot;#&quot;+height+&quot;#&quot;+length;

        flyweight=factory.getFlyweight(key);

        Car audiA4One=new Car(flyweight, &quot;A4&quot;, &quot;蓝色&quot;, 126);
        Car audiA4Two=new Car(flyweight, &quot;A4&quot;, &quot;红色&quot;, 138);

        flyweight.printMess(&quot;名称：奥迪A6：颜色：蓝色 功率：126&quot;);
        flyweight.printMess(&quot;名称：A4 颜色：红色 功率：138&quot;);


    }

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;headerlink&quot; title=&quot;享元模式&quot;&gt;&lt;/a&gt;享元模式&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/访问者模式详解/</id>
    <published>2017-01-29T04:09:46.000Z</published>
    <updated>2017-01-29T04:14:33.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="访问者模式详解"><a href="#访问者模式详解" class="headerlink" title="访问者模式详解"></a>访问者模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：-表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。"><a href="#定义：-表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。" class="headerlink" title="定义： 表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。"></a>定义： 表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。</h4><hr>
<h4 id="理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。"><a href="#理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。" class="headerlink" title="理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。"></a>理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>访问者模式包括五种角色：</p>
<ul>
<li>抽象元素：一个抽象类，该类定义了接收访问者的accept操作。</li>
<li>具体元素：element的子类。</li>
<li>对象结构：一个集合，用于存放element对象，提供遍历它自己的方法。</li>
<li>抽象访问者：一个接口，该接口定义操作对象的方法。</li>
<li>具体访问者：实现visitot接口的类。</li>
</ul>
<hr>
<h4 id="双重分流"><a href="#双重分流" class="headerlink" title="双重分流"></a>双重分流</h4><h2 id="访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。"><a href="#访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。" class="headerlink" title="访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。"></a>访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。</h2><h4 id="访问者模式的优点"><a href="#访问者模式的优点" class="headerlink" title="访问者模式的优点"></a>访问者模式的优点</h4><ul>
<li>可以在不改变一个集合中元素的类的情况下，增加新的施加于该元素上新操作、</li>
<li>可以将集合中各个元素的某些操作集中到访问者中，不仅便于集合的维护，也有利于集合中元素的复用。</li>
</ul>
<hr>
<h4 id="适合访问者的场景"><a href="#适合访问者的场景" class="headerlink" title="适合访问者的场景"></a>适合访问者的场景</h4><ul>
<li>一个对象结构中，比如某个集合中，包含很多对象，想对集合中的对象增加一些新的操作。</li>
<li>需要对集合中的对象进行很多不同的并且不相关的操作，而不仅不想修改对象的类，就可以使用访问者模式。访问者模式可以在visitor类中集中定义了<br>一些关于集合中对象的操作。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;访问者模式详解&quot;&gt;&lt;a href=&quot;#访问者模式详解&quot; class=&quot;headerlink&quot; title=&quot;访问者模式详解&quot;&gt;&lt;/a&gt;访问者模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>桥接模式</title>
    <link href="http://www.craymc.com/2017/01/29/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.craymc.com/2017/01/29/桥接模式/</id>
    <published>2017-01-29T04:09:22.000Z</published>
    <updated>2017-01-29T04:14:55.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="桥接模式详解"><a href="#桥接模式详解" class="headerlink" title="桥接模式详解"></a>桥接模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<p>[author：craymc][anchor-id]</p>
<h3 id="定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。"><a href="#定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。" class="headerlink" title="定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。"></a>定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。</h3><hr>
<h4 id="理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。"><a href="#理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。" class="headerlink" title="理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。"></a>理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。</h4><h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>桥接模式包括四种角色：</p>
<ul>
<li>抽象：是一个抽象类，该抽象类含有implementor声明的变量，既维护一个implemnentor类型对象。</li>
<li>实现者：实现者角色是一个接口，该接口中的方法不一定与abstract类中的方法一致。implementor接口负责定义基本操作，而abstract类负责定义基于这些基本操作的较高层次的操作。</li>
<li>细化抽象：是抽象角色的一个子类，该子类在重写抽象角色中的抽象方法时，在给出一些必要的操作后，将委托所维护implementor类型对象调用相应的方法。</li>
<li>具体实现者：是实现implementor接口的类。</li>
</ul>
<hr>
<h3 id="桥接模式的优点"><a href="#桥接模式的优点" class="headerlink" title="桥接模式的优点"></a>桥接模式的优点</h3><ul>
<li>桥接模式分离实现与抽象，使抽象和实现可以独立的扩展。当修改实现的代码时，不影响抽象的代码，反之也一样。</li>
<li>满足开-闭模式。抽象和实现者处于同层次，使系统可独立地扩展者两个层次。增加新的具体实现者，不需要修改细化抽象，反之增加新的细化抽象也不需要修改具体实现。</li>
</ul>
<hr>
<h3 id="适合桥接模式的情景"><a href="#适合桥接模式的情景" class="headerlink" title="适合桥接模式的情景"></a>适合桥接模式的情景</h3><ul>
<li>不想让抽象和某些重要的实现代码是固定的绑定关系，这部分实现可运行时动态决定。</li>
<li>抽象和实现者都可以继承的方式独立地扩充而互不影响，程序在运行期间可能需要动态的将一个抽象的子类的实例与一个实现者的子类的实例进行组合。</li>
<li>希望对实现者层次代码的修改对抽象层不产生影响，既抽象层的代码不必重新编译，反之亦然。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><hr>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>   public abstract class ArchitectureCore {<br>    BuildingDesign design;<br>    double unitPrice;<br>    public abstract double giveCost();</p>
<pre><code>}
</code></pre><h4 id="实现者"><a href="#实现者" class="headerlink" title="实现者"></a>实现者</h4><pre><code>public interface BuildingDesign {
    public double computerArea();
}
</code></pre><h4 id="细化抽象"><a href="#细化抽象" class="headerlink" title="细化抽象"></a>细化抽象</h4><pre><code>public class BuildingCost extends ArchitectureCore{
public BuildingCost(BuildingDesign design,double unitPrice) {
        this.design=design;
        this.unitPrice=unitPrice;
}



@Override
public double giveCost() {
    double area=design.computerArea();
    return area*unitPrice;
}

}
</code></pre><h4 id="具体实现者"><a href="#具体实现者" class="headerlink" title="具体实现者"></a>具体实现者</h4><pre><code>public class HouseDesign implements BuildingDesign{
double width,length;
int floorNumber;


public HouseDesign(double width, double length, int floorNumber) {
    this.width = width;
    this.length = length;
    this.floorNumber = floorNumber;
}


@Override
public double computerArea() {

    return width*length*floorNumber;
}

}
</code></pre><h4 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h4><pre><code>public class Application {
public static void main(String[] args) {
    double width=63,height=30;
    int floorNumber=8;
    double unitPrice=6867.38;
    BuildingDesign design=new HouseDesign(width, height, floorNumber);
    System.out.println(&quot;宽&quot;+width+&quot;米，高&quot;+height+&quot;米，层数为：&quot;+floorNumber);
    ArchitectureCore cost=new BuildingCost(design, unitPrice);
    double price=cost.giveCost();
    System.out.printf(&quot;每平方米造价为：&quot;+unitPrice+&quot;元的商业楼的建设成本：%.2f\n&quot;,price);
    width=50;
    height=28;
    floorNumber=6;
    unitPrice=2687.88;
    design=new HouseDesign(width, height, floorNumber);
    System.out.printf(&quot;宽&quot;+width+&quot;米，高&quot;+height+&quot;米，层数为&quot;+floorNumber);

    cost=new BuildingCost(design, unitPrice);
    price=cost.giveCost();
    System.out.printf(&quot;每平方米造价&quot;+unitPrice+&quot;元的住宅楼的建设成本%.2f\n&quot;,price);

}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;桥接模式详解&quot;&gt;&lt;a href=&quot;#桥接模式详解&quot; class=&quot;headerlink&quot; title=&quot;桥接模式详解&quot;&gt;&lt;/a&gt;桥接模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/代理模式详解/</id>
    <published>2017-01-29T04:08:58.000Z</published>
    <updated>2017-03-11T06:42:41.058Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代理模式详解"><a href="#代理模式详解" class="headerlink" title="代理模式详解"></a>代理模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：为其他对象提供一种代理以控制对这个对象的访问。"><a href="#定义：为其他对象提供一种代理以控制对这个对象的访问。" class="headerlink" title="定义：为其他对象提供一种代理以控制对这个对象的访问。"></a>定义：为其他对象提供一种代理以控制对这个对象的访问。</h4><hr>
<h4 id="理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。"><a href="#理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。" class="headerlink" title="理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。"></a>理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。</h4><hr>
<a id="more"></a>
<h4 id="代理的特点是：它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。"><a href="#代理的特点是：它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。" class="headerlink" title="代理的特点是：它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。"></a>代理的特点是：<strong>它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。</strong></h4><hr>
<h4 id="代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。"><a href="#代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。" class="headerlink" title="代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。"></a>代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。</h4><hr>
<h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>代理模式包括三种角色</p>
<ul>
<li>抽象主题：是一个接口，该接口是对象和它的代理所共用的接口。</li>
<li>实际主题：实际主题是实现抽象主题接口的类。实际主题的实例是代理角色实例所要代理的对象。</li>
<li>代理：代理是实现抽象主题接口的类。代理含有主题接口声明的变量，该变量用来存放realSubject角色的实例引用，这样一来，代理的实例就可以控制对它所包含的realSubject角色的实例访问，既可以控制对它所代理对象的访问。</li>
</ul>
<hr>
<p>####　代理模式的优点</p>
<ul>
<li>代理模式可以屏蔽用户真正请求的对象，使用户程序和真正的对象之间解耦。</li>
<li><p>使用代理来担当哪些创建耗时的对象的替身。</p>
<h4 id="适合代理模式的场景"><a href="#适合代理模式的场景" class="headerlink" title="适合代理模式的场景"></a>适合代理模式的场景</h4></li>
<li><p>程序可能不希望用户直接访问该对象，而是提供一个特殊的对象以控制当前对象的访问</p>
</li>
<li>如果一个对象需要很长时间才能加载完成。</li>
<li>如果对象位于远程主机上，需要为用户提供访问该远程对象的能力。</li>
</ul>
<hr>
<h5 id="代码模式"><a href="#代码模式" class="headerlink" title="代码模式"></a>代码模式</h5><h6 id="抽象主题"><a href="#抽象主题" class="headerlink" title="抽象主题"></a>抽象主题</h6><pre><code>public interface Geometry {
    public double getArea();

}
</code></pre><h6 id="具体模板"><a href="#具体模板" class="headerlink" title="具体模板"></a>具体模板</h6><pre><code>public class Triangle implements Geometry{
 double sideA,sideB,sideC,area;


public Triangle(double sideA, double sideB, double sideC) {
    this.sideA = sideA;
    this.sideB = sideB;
    this.sideC = sideC;
}


@Override
public double getArea() {
    double p=(sideA+sideB+sideC)/2.0;
    area=Math.sqrt(p*(p-sideA)*(p-sideB)*(p-sideC));
    return area;
}

}
</code></pre><h6 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h6><pre><code>public class TriangleProxy implements Geometry{
double sideA,sideB,sideC;
Triangle Triangle;
public void setABC(double a,double b,double c){
    sideA=a;
    sideB=b;
    sideC=c;
}
@Override
public double getArea() {
    if(sideA+sideB&gt;sideC&amp;&amp;sideA+sideC&gt;sideB&amp;&amp;sideB+sideC&gt;sideA){
        Triangle=new Triangle(sideA, sideB, sideC);
        double area=Triangle.getArea();
        return area;
    }else{
        return -1;
    }
}

}
</code></pre><h6 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h6><pre><code>import java.util.Scanner;

public class Application {
    public static void main(String[] args) {
        Scanner reader=new Scanner(System.in);
        System.out.println(&quot;请输入按个数&quot;);
        double a=-1,b=-1,c=-1;
        a=reader.nextDouble();
        b=reader.nextDouble();
        c=reader.nextDouble();
        TriangleProxy proxy=new TriangleProxy();
        proxy.setABC(a, b, c);
        double area=proxy.getArea();
        System.out.println(&quot;面积是：&quot;+area);
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代理模式详解&quot;&gt;&lt;a href=&quot;#代理模式详解&quot; class=&quot;headerlink&quot; title=&quot;代理模式详解&quot;&gt;&lt;/a&gt;代理模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;hr&gt;
&lt;h4 id=&quot;定义：为其他对象提供一种代理以控制对这个对象的访问。&quot;&gt;&lt;a href=&quot;#定义：为其他对象提供一种代理以控制对这个对象的访问。&quot; class=&quot;headerlink&quot; title=&quot;定义：为其他对象提供一种代理以控制对这个对象的访问。&quot;&gt;&lt;/a&gt;定义：为其他对象提供一种代理以控制对这个对象的访问。&lt;/h4&gt;&lt;hr&gt;
&lt;h4 id=&quot;理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。&quot;&gt;&lt;a href=&quot;#理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。&quot; class=&quot;headerlink&quot; title=&quot;理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。&quot;&gt;&lt;/a&gt;理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。&lt;/h4&gt;&lt;hr&gt;
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>状态模式详解</title>
    <link href="http://www.craymc.com/2017/01/26/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/26/状态模式详解/</id>
    <published>2017-01-26T14:05:31.000Z</published>
    <updated>2017-01-26T14:07:09.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="状态模式详解"><a href="#状态模式详解" class="headerlink" title="状态模式详解"></a>状态模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。"><a href="#定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。" class="headerlink" title="定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。"></a>定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</h3><hr>
<h4 id="理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。核心：状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。"><a href="#理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。核心：状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。" class="headerlink" title="理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。核心：状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。"></a>理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。<strong>核心：</strong>状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。</h4><hr>
<h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>状态模式包括三种角色：</p>
<ul>
<li>环境：环境是一个类，该类含有抽象状态声明的变量，可以引用任何具体状态类的实例。用户对该环境类的实例在某种状态下的行为感兴趣。</li>
<li>抽象状态：抽象状态是一个接口或抽象类。抽象状态中定义了与环境的一个特定状态相关的若干个方法。</li>
<li>具体状态：具体状态是实现抽象状态的类。</li>
</ul>
<hr>
<h4 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h4><h2 id="环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。"><a href="#环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。" class="headerlink" title="环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。"></a>环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。</h2><h4 id="状态模式的优点"><a href="#状态模式的优点" class="headerlink" title="状态模式的优点"></a>状态模式的优点</h4><ul>
<li>使用一个类封装对象的一种状态，很容易增加 新的状态。</li>
<li>在状态模式中，环境中不必出现大量的条件判断语句。环境实例所呈现的状态变得更加清晰，容易理解。</li>
<li>使用状态模式可以让用户程序很方便地切换环境实例状态。</li>
<li>使用状态模式不会让环境的实例中出现内部状态不一致的情况。</li>
<li>当前对象没有实例变量时，环境的各个实例可以共享一个状态对象。</li>
</ul>
<hr>
<h4 id="适合使用状态模式的情景"><a href="#适合使用状态模式的情景" class="headerlink" title="适合使用状态模式的情景"></a>适合使用状态模式的情景</h4><ul>
<li>一个对象的行为依赖于它的状态，并且它必须在运行时根据状态改变它的行为。</li>
<li>需要编写大量的条件分支语句来决定一个操作的行为，而且这些条件恰好表示对象的一种状态。</li>
</ul>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><pre><code>public class Thermometer {
  TempreatureState state;
   public void showMessage(){
    System.out.println(&quot;****&quot;);
    state.showTemperature();
    System.out.println(&quot;*****&quot;);
}
public void setState(TempreatureState state){
    this.state=state;
}

}
</code></pre><h5 id="抽象状态"><a href="#抽象状态" class="headerlink" title="抽象状态"></a>抽象状态</h5><pre><code>public interface TempreatureState {
public void showTemperature();

 }
</code></pre><h5 id="具体状态"><a href="#具体状态" class="headerlink" title="具体状态"></a>具体状态</h5><pre><code>public class LowState implements TempreatureState {
  double n=0;


  public LowState(double n) {
    if(n&lt;=0)
    this.n = n;
   }


@Override
public void showTemperature() {
        System.out.println(&quot;现在的温度是&quot;+n+&quot;属于低温度&quot;);
}

}

public class MiddleState implements TempreatureState{
double n=15;



public MiddleState(int n) {
    if(n&gt;0&amp;&amp;n&lt;26)
    this.n = n;
}



@Override
public void showTemperature() {
    System.out.println(&quot;现在是温度是&quot;+n+&quot;属于正常温度&quot;);
}

}


public class HeightState implements TempreatureState{
   double n=39;


   public HeightState(double n) {
    if(n&gt;39)
    this.n = n;
    }


    @Override
    public void showTemperature() {
    System.out.println(&quot;现在温度是&quot;+n+&quot;属于高温&quot;);
     }

}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>public class Application {
    public static void main(String[] args) {

            TempreatureState state=new LowState(-12);
            Thermometer thermometer=new Thermometer();

            thermometer.setState(state);
            thermometer.showMessage();

            state=new MiddleState(20);
            thermometer.setState(state);
            thermometer.showMessage();

            state=new HeightState(39);
            thermometer.setState(state);
            thermometer.showMessage();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;状态模式详解&quot;&gt;&lt;a href=&quot;#状态模式详解&quot; class=&quot;headerlink&quot; title=&quot;状态模式详解&quot;&gt;&lt;/a&gt;状态模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法详解</title>
    <link href="http://www.craymc.com/2017/01/26/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/26/模板方法详解/</id>
    <published>2017-01-26T14:04:55.000Z</published>
    <updated>2017-01-26T14:06:42.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模板方法详解"><a href="#模板方法详解" class="headerlink" title="模板方法详解"></a>模板方法详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h2 id="定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。"><a href="#定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。" class="headerlink" title="###　定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。"></a>###　定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。</h2><h4 id="理解：-类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。"><a href="#理解：-类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。" class="headerlink" title="理解： 类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。"></a>理解： 类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。</h4><h4 id="核心：模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象-类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。"><a href="#核心：模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象-类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。" class="headerlink" title="核心：模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象 类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。"></a><strong>核心：</strong>模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象 类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。</h4><h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>模板方法模式包括两种角色：</p>
<ul>
<li>抽象模板：抽象模板是一个抽象类。抽象模板定义了若干个方法来表示一个算法的各个步骤，这些方法中有抽象方法也有非抽象方法，其中的抽象方法称作<br>原语操作。更重要的一点是，抽象模板中还定义了一个称作模板方法的方法，该方法不仅包含有抽象模板中表示算法步骤的方法调用，而且也可以包含有定义在抽象模板中的其他对象方法调用，既模板方法定义了算法骨架。</li>
<li>具体模板：具体模板是抽象模板的子类，实现抽象模板中的原语操作。</li>
</ul>
<hr>
<h4 id="模板方法模式的优点："><a href="#模板方法模式的优点：" class="headerlink" title="模板方法模式的优点："></a>模板方法模式的优点：</h4><ul>
<li>可以通过在抽象模板定义模板方法给出成熟的算法步骤，同时又不限制步骤的细节，具体模板实现算法细节不会改变整个算法的骨架。</li>
<li>在抽象模板模式中，可以通过钩子方法对 某些步骤进行挂钩，具体模板通过钩子可以选择算法骨架中的某些步骤。</li>
</ul>
<hr>
<h4 id="适合模板方法模式的场景："><a href="#适合模板方法模式的场景：" class="headerlink" title="适合模板方法模式的场景："></a>适合模板方法模式的场景：</h4><ul>
<li>设计者需要给出一个算法的固定步骤，并将某些步骤的具体实现留给子类来实现。</li>
<li>需要对代码进行重构，将各个子类公共行为提取出来集中到一个共同的父类中以避免代码重复。</li>
</ul>
<hr>
<h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><h5 id="抽象模板"><a href="#抽象模板" class="headerlink" title="抽象模板"></a>抽象模板</h5><pre><code> import java.io.File;

public abstract class AbstractTemplate {  
   File[]allFile;
   File dir;
   public AbstractTemplate(File dir) {
    this.dir = dir;
    }
   public final void showFileName(){
    allFile=dir.listFiles();
    sort();
    printFiles();
    }
   public abstract void printFiles();
   public abstract void sort();

}
</code></pre><h5 id="具体模板"><a href="#具体模板" class="headerlink" title="具体模板"></a>具体模板</h5><pre><code>import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ConcreteTemplatel extends AbstractTemplate {


   public ConcreteTemplatel(File dir) {
    super(dir);
    }

    @Override
    public void printFiles() {
        for (int i = 0; i &lt; allFile.length; i++) {
            long time=allFile[i].lastModified();
            Date date=new Date();
            SimpleDateFormat matter=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            String name=allFile[i].getName();
            int k=i+1;
            System.out.println(k+&quot; &quot;+name+&quot;(&quot;+name+&quot;)&quot;);
    }

}

    @Override
    public void sort() {
        for (int i = 0; i &lt; allFile.length; i++) {
            for (int j = i+1; j &lt; allFile.length; j++) {
                if(allFile[j].lastModified()&lt;allFile[i].lastModified()){
                    File file=allFile[j];
                    allFile[j]=allFile[i];
                    allFile[i]=file;
            }
        }
    }

}
}

import java.io.File;

public class ConcreteTemplate2  extends AbstractTemplate{

    public ConcreteTemplate2(File dir) {
    super(dir);
    }

    @Override
    public void printFiles() {
        for (int i = 0; i &lt; allFile.length; i++) {
            long fileSize=allFile[i].length();
            String name=allFile[i].getName();
            int k=i+1;
            System.out.println(k+&quot; &quot;+name+&quot;(&quot;+fileSize+&quot;字节&quot;);
        }
}

    @Override
    public void sort() {
        for (int i = 0; i &lt; allFile.length; i++) {
            for (int j = i+1; j &lt; allFile.length; j++) {
                if(allFile[j].length()&lt;allFile[i].length()){
                    File file=allFile[j];
                    allFile[j]=allFile[i];
                    allFile[i]=file;
            }
        }
    }
}

}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>import java.io.File;

public class Application {
    public static void main(String[] args) {
            File dir=new File(&quot;路径&quot;);
            AbstractTemplate template=new ConcreteTemplatel(dir);
            System.out.println(dir.getPath()+&quot;目录下的文件：&quot;);
            template.showFileName();
            template=new ConcreteTemplate2(dir);
            System.out.println(dir.getPath()+&quot;目录下的文件：&quot;);
            template.showFileName();


    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模板方法详解&quot;&gt;&lt;a href=&quot;#模板方法详解&quot; class=&quot;headerlink&quot; title=&quot;模板方法详解&quot;&gt;&lt;/a&gt;模板方法详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
