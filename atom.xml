<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>craymc</title>
  <subtitle>http://www.craymc.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.craymc.com/"/>
  <updated>2017-02-08T06:06:40.396Z</updated>
  <id>http://www.craymc.com/</id>
  
  <author>
    <name>craymc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络基础知识</title>
    <link href="http://www.craymc.com/2017/02/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://www.craymc.com/2017/02/08/计算机网络基础知识/</id>
    <published>2017-02-08T06:01:26.000Z</published>
    <updated>2017-02-08T06:06:40.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="先从协议开始"><a href="#先从协议开始" class="headerlink" title="先从协议开始"></a>先从协议开始</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<p><strong>OSI，TCP/IP，五层协议的体系结构，以及各层协议</strong><br><a id="more"></a></p>
<p>OSI分层 （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>TCP/IP分层（4层）：网络接口层、 网际层、运输层、 应用层。<br>五层协议 （5层）：物理层、数据链路层、网络层、运输层、 应用层。<br>每一层的协议如下：<br>物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器）<br>数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机）<br>网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）<br>传输层：TCP、UDP、SPX<br>会话层：NFS、SQL、NETBIOS、RPC<br>表示层：JPEG、MPEG、ASII<br>应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS<br>每一层的作用如下：<br>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）<br>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）<br>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）<br>会话层：建立、管理和终止会话（会话协议数据单元SPDU）<br>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</p>
<h2 id="应用层：允许访问OSI环境的手段（应用协议数据单元APDU）"><a href="#应用层：允许访问OSI环境的手段（应用协议数据单元APDU）" class="headerlink" title="应用层：允许访问OSI环境的手段（应用协议数据单元APDU）"></a>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</h2><p><strong>IP地址的分类</strong><br>A类地址：以0开头， 第一个字节范围：0~126（1.0.0.0 - 126.255.255.255）；<br>B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；<br>C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；<br>10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部）</p>
<h2 id="IP地址与子网掩码相与得到网络号"><a href="#IP地址与子网掩码相与得到网络号" class="headerlink" title="IP地址与子网掩码相与得到网络号"></a>IP地址与子网掩码相与得到网络号</h2><p><strong>ARP是地址解析协议的理解</strong><br>1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。<br>2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。<br>3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。<br>4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<h2 id="广播发送ARP请求，单播发送ARP响应。"><a href="#广播发送ARP请求，单播发送ARP响应。" class="headerlink" title="广播发送ARP请求，单播发送ARP响应。"></a>广播发送ARP请求，单播发送ARP响应。</h2><p><strong>各种协议的介绍</strong><br>ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。<br>TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。<br>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<br>DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。<br>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，</p>
<h2 id="DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。"><a href="#DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。" class="headerlink" title="DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。"></a>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</h2><p><strong>描述RARP协议</strong></p>
<h2 id="RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。"><a href="#RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。" class="headerlink" title="RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。"></a>RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。</h2><p><strong>TCP三次握手和四次挥手的全过程</strong><br>三次握手：<br>第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。<br>四次挥手<br>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。<br>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。<br>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<h2 id="第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号-1，至此，完成四次挥手。"><a href="#第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号-1，至此，完成四次挥手。" class="headerlink" title="第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。"></a>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</h2><p><strong>浏览器执行网络URL的过程</strong><br>1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。<br>2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。<br>3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<h2 id="4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。"><a href="#4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。" class="headerlink" title="4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。"></a>4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</h2><p><strong>TCP和UDP的区别</strong><br>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。<br>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。<br>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。<br>TCP对应的协议和UDP对应的协议<br>TCP对应的协议：<br>（1） FTP：定义了文件传输协议，使用21端口。<br>（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。<br>（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。<br>（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。<br>（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。<br>UDP对应的协议：<br>（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。<br>（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<h2 id="（3）-TFTP-Trival-File-Tran敏感词er-Protocal-，简单文件传输协议，该协议在熟知端口69上使用UDP服务。"><a href="#（3）-TFTP-Trival-File-Tran敏感词er-Protocal-，简单文件传输协议，该协议在熟知端口69上使用UDP服务。" class="headerlink" title="（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。"></a>（3） TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</h2><p><strong>TCP为什么是安全的UDP为什么不安全</strong></p>
<h2 id="TCP提供面向连接服务，传输数据前必须先建立连接，接收方确认，数据传输后要释放链接。比如说电子邮件。UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认。提供不可靠交付，比如说qq用的就是UDP协议，优点是传输效率高。"><a href="#TCP提供面向连接服务，传输数据前必须先建立连接，接收方确认，数据传输后要释放链接。比如说电子邮件。UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认。提供不可靠交付，比如说qq用的就是UDP协议，优点是传输效率高。" class="headerlink" title="TCP提供面向连接服务，传输数据前必须先建立连接，接收方确认，数据传输后要释放链接。比如说电子邮件。UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认。提供不可靠交付，比如说qq用的就是UDP协议，优点是传输效率高。"></a>TCP提供面向连接服务，传输数据前必须先建立连接，接收方确认，数据传输后要释放链接。比如说电子邮件。UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认。提供不可靠交付，比如说qq用的就是UDP协议，优点是传输效率高。</h2><p><strong>DNS域名系统，简单描述其工作原理</strong><br>当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。<br>面向连接和非面向连接的服务的特点是什么？<br>面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。</p>
<h2 id="非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。"><a href="#非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。" class="headerlink" title="非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。"></a>非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。</h2><p><strong>TCP的三次握手过程？为什么会采用三次握手，若采用二次握手可以吗？</strong><br>建立连接的过程是利用客户服务器模式，假设主机A为客户端，主机B为服务器端。<br>（1）TCP的三次握手过程：主机A向B发送连接请求；主机B对收到的主机A的报文段进行确认；主机A再次对主机B的确认进行确认。<br>（2）采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。</p>
<h2 id="（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。"><a href="#（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。" class="headerlink" title="（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。"></a>（3）采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。</h2><p><strong>交换机、路由器、网关的概念，和各自的用途</strong><br>1）交换机<br>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。<br>交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。<br>交换机被广泛应用于二层网络交换，俗称“二层交换机”。<br>交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。<br>2）路由器<br>路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。<br>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。<br>3）网关<br>网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。<br>在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。<br>在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。<br>网关是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过网关还原成模拟的电话信号，最后才能在电话机上听到。</p>
<h2 id="对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。"><a href="#对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。" class="headerlink" title="对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。"></a>对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;先从协议开始&quot;&gt;&lt;a href=&quot;#先从协议开始&quot; class=&quot;headerlink&quot; title=&quot;先从协议开始&quot;&gt;&lt;/a&gt;先从协议开始&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;OSI，TCP/IP，五层协议的体系结构，以及各层协议&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://www.craymc.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>解释器模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/解释器模式详解/</id>
    <published>2017-01-29T04:10:57.000Z</published>
    <updated>2017-01-29T04:12:58.922Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解释器模式详解"><a href="#解释器模式详解" class="headerlink" title="解释器模式详解"></a>解释器模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。"><a href="#定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。" class="headerlink" title="定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。"></a>定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</h4><hr>
<h4 id="理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。"><a href="#理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。" class="headerlink" title="理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。"></a>理解：语言是由语句组成的集合，而语句是由一组符号所构成的序列。当表述一种语言时，无非是说明这种语言有怎样的语句。解释模式是关于怎样实现一个简单语言的成熟模式，其关键是将每一个语法规则表示成一个类。</h4><hr>
<h4 id="解释器模式的结构与使用"><a href="#解释器模式的结构与使用" class="headerlink" title="解释器模式的结构与使用"></a>解释器模式的结构与使用</h4><p>解释器模式包括四种角色：</p>
<ul>
<li>抽象表达式：该角色为一个接口，负责定义抽象的解释操作。</li>
<li>终结符表达式：实现AbstracttExpression接口的类。该类接口中的解释操作实现为与文法中的终结符相关联的操作，既文法中每个终结符号需要一个TerminalExpression类。</li>
<li>非终结者符表达式：实现AbstractExpression接口的类。文法中是每一条规则都需要一个NonterminalExpression类。NonterminalExpression类为文法中的非终结符号实现解释器操作，该解释器操作通常使用递归表示哪些对象的解释操作。</li>
<li>上下文：包含解释器之外的一些全局信息。</li>
</ul>
<hr>
<h4 id="解释器模式的优点"><a href="#解释器模式的优点" class="headerlink" title="解释器模式的优点"></a>解释器模式的优点</h4><ul>
<li>将每一个语法规则表示成一个类，方便与实现简单的语言。</li>
<li>由于使用类表示语法规则，可以较容易改变或扩展语言的行为。</li>
<li>通过在类结构中加入新的方法，可以在解释的同时增加新的行为。</li>
</ul>
<hr>
<h4 id="适合使用解释模式的场景"><a href="#适合使用解释模式的场景" class="headerlink" title="适合使用解释模式的场景"></a>适合使用解释模式的场景</h4><h2 id="当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。"><a href="#当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。" class="headerlink" title="当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。"></a>当有一个简单的语言需要解释执行，并且可以将该语言的每一个规则表示为一个类时，就可以使用解释器模式。</h2><h4 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h4><p>使用解释器模式设计程序有三个步骤：</p>
<ul>
<li>解析出语句中的动作标记</li>
<li>将标记归纳为动作</li>
<li>执行动作</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h5 id="抽象表达式"><a href="#抽象表达式" class="headerlink" title="抽象表达式"></a>抽象表达式</h5><pre><code>public interface Node {
public void parse(Context context);
public void execute();
}
</code></pre><h5 id="终结符表达式"><a href="#终结符表达式" class="headerlink" title="终结符表达式"></a>终结符表达式</h5><pre><code>public class SubjectPronounOrNounNode implements Node {
String []word={&quot;you&quot;,&quot;He &quot;,&quot;Teacher&quot;,&quot;Student&quot;};
String token;
boolean boo;
@Override
public void parse(Context context) {
    token=context.nextToken();
    int i = 0;
    for (i = 0; i &lt; word.length; i++) {
        if(token.equalsIgnoreCase(word[i])){
            boo=true;
            break;
        }
    }
    if(i==word.length)
        boo=false;
            }

@Override
public void execute() {
        if(boo){
            if(token.equalsIgnoreCase(word[0]));
                System.out.println(&quot;你&quot;);
            if(token.equalsIgnoreCase(word[1]));
                System.out.println(&quot;它&quot;);
            if(token.equalsIgnoreCase(word[2]));
                System.out.println(&quot;老师&quot;);
            if(token.equalsIgnoreCase(word[3]));
                System.out.println(&quot;学生&quot;);
        }    else{
            System.out.println(token+&quot;(NO)&quot;);
        }

}


}

public class ObjectPronounOrNouNode implements Node {
    String []word={&quot;ME&quot;,&quot;Him&quot;,&quot;Tiger&quot;,&quot;Apple&quot;};
    String token;
    boolean boo;


    @Override
    public void parse(Context context) {
        token=context.nextToken();
        int i=0;
        for (i = 0; i &lt; word.length;i ++) {
            if(token.equalsIgnoreCase(word[i])){
                boo=true;
                break;
            }
        }
        if(i==word.length)
            boo=false;
}

@Override
public void execute() {
        if(boo){
        if(token.equalsIgnoreCase(word[0]));
            System.out.println(&quot;我&quot;);
        if(token.equalsIgnoreCase(word[1]));
            System.out.println(&quot;他&quot;);
        if(token.equalsIgnoreCase(word[2]));
            System.out.println(&quot;老虎&quot;);
        if(token.equalsIgnoreCase(word[3]));
            System.out.println(&quot;苹果&quot;);
    }    else{
        System.out.println(token+&quot;(NO)&quot;);
    }

}            
}

public class VerbNode implements Node {
String []word={&quot;Drink&quot;,&quot;Eat&quot;,&quot;Look&quot;,&quot;beat&quot;};
String token;
boolean boo;


@Override
public void parse(Context context) {
    token=context.nextToken();
    int i=0;
    for ( i = 0; i &lt; word.length; i++) {
        if(token.equalsIgnoreCase(word[i])){
            boo=true;
            break;
        }
    }
    if(i==word.length)
        boo=false;
}

@Override
public void execute() {
    if(boo){
        if(token.equalsIgnoreCase(word[0]));
        System.out.println(&quot;吃&quot;);
    if(token.equalsIgnoreCase(word[1]));
        System.out.println(&quot;喝&quot;);
    if(token.equalsIgnoreCase(word[2]));
        System.out.println(&quot;看&quot;);
    if(token.equalsIgnoreCase(word[3]));
        System.out.println(&quot;打&quot;);
}    else{
    System.out.println(token+&quot;(NO)&quot;);
}


    }


}
</code></pre><h5 id="非终结符表达式"><a href="#非终结符表达式" class="headerlink" title="非终结符表达式"></a>非终结符表达式</h5><pre><code>public class SentenceNode implements Node{

Node subjectNode,predicateNode;


@Override
public void parse(Context context) {
    subjectNode=new SubjectNode();
    predicateNode=new PredicateNode();
    subjectNode.parse(context);
    predicateNode.parse(context);
}

@Override
public void execute() {
    subjectNode.execute();
    predicateNode.execute();
}

}
public class SubjectNode implements Node {

Node node;

@Override
public void parse(Context context) {
    node=new SubjectPronounOrNounNode();
    node.parse(context);
}

@Override
public void execute() {
    node.execute();
}

}
public class PredicateNode implements Node {
Node verbNode,objectNode;

@Override
public void parse(Context context) {
    verbNode=new VerbNode();
    objectNode=new ObjectPronounOrNouNode();
    verbNode.parse(context);
    objectNode.parse(context);
}

@Override
public void execute() {
    verbNode.execute();
    objectNode.execute();
}

}
</code></pre><h5 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h5><pre><code>import java.util.StringTokenizer;

public class Context {
    StringTokenizer tokenizer;
    String token;
    public Context(String text) {
    setContext(text);
    }
    public void setContext(String text){
    tokenizer=new StringTokenizer(text);
    }
    String nextToken(){
        if(tokenizer.hasMoreTokens()){
        token=tokenizer.nextToken();
    }else
        token=&quot;&quot;;

    return token;

}
}
</code></pre><h5 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h5><pre><code>public class Application {
public static void main(String[] args) {
    String text=&quot;Teacher beat tiger&quot;;
    Context context=new Context(text);
    Node node=new SentenceNode();
    node.parse(context);
    node.execute();
    text=&quot;You eat apple&quot;;
    context.setContext(text);
    System.out.println();
    node.parse(context);
    node.execute();
    text=&quot;you look him&quot;;
    context.setContext(text);
    System.out.println();
    node.parse(context);
    node.execute();
}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;解释器模式详解&quot;&gt;&lt;a href=&quot;#解释器模式详解&quot; class=&quot;headerlink&quot; title=&quot;解释器模式详解&quot;&gt;&lt;/a&gt;解释器模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>备忘录模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/备忘录模式详解/</id>
    <published>2017-01-29T04:10:34.000Z</published>
    <updated>2017-01-29T04:13:37.223Z</updated>
    
    <content type="html"><![CDATA[<h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><h2 id="定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。"><a href="#定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。" class="headerlink" title="###　定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。"></a>###　定义：在不破坏封装性的前提的下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将对象恢复到原先的状态。</h2><h4 id="理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。"><a href="#理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。" class="headerlink" title="理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。"></a>理解：对象的状态依赖于它的变量的取值情况，对象在程序运行期间的各个时刻可能具有不同的状态。在某些应用中，程序可能需要一种合理的方式来保存对象在某一时刻的状以便在需要时，对象能恢复到原先保存的状态。</h4><hr>
<h4 id="核心：备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。"><a href="#核心：备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。" class="headerlink" title="核心：备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。"></a><strong>核心：</strong>备忘录模式是关于怎么保存对象状态的成熟模式，其关键是提供一个备忘录对象，该备忘录负责存储一个对象的状态，程序可以在磁盘或内存中保存这个备忘录，这样一来，程序就可以根据对象的备忘录将该对象恢复到备忘录中所存储的状态。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>备忘录模式包括三种角色：</p>
<ul>
<li>原发者：需要在某个时刻保存其状态的对象。原发者负责创建备忘录，然后原发者使用该备忘录记录自己的状态。当原发者需要恢复某个时刻的状态时，它通过获得相应备忘录中的数据来恢复那个时刻的状态。</li>
<li>备忘录：负责存储原发者状态的对象，创建备忘录的类和创建原发者的类在同一个包中的类是实例才可以访问备忘录中的数据。</li>
<li>负责人：负责保管保存备忘录的对象。负责人如果需要将备忘录保存到磁盘，负责人可以使用对象流将备忘录写入文件。</li>
</ul>
<hr>
<h4 id="备忘录的优点"><a href="#备忘录的优点" class="headerlink" title="备忘录的优点"></a>备忘录的优点</h4><ul>
<li>备忘录模式使用备忘录可以把原发者的内部状态保存起来，使只有恨“亲密的”对象可以访问备忘录中的数据。</li>
<li>备忘录模式强调了类设计单一责任原则，既将状态的刻画和保存分开。</li>
</ul>
<hr>
<h4 id="使用备忘录模式的场景"><a href="#使用备忘录模式的场景" class="headerlink" title="使用备忘录模式的场景"></a>使用备忘录模式的场景</h4><ul>
<li>必须保存一个对象在某一时刻的全部或部分状态，以便在需要的时刻恢复该对象先前的状态。</li>
<li>一个对象不想通过提供public权限的，且想让其他对象得到自己的内部状态。</li>
</ul>
<hr>
<h5 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h5><h6 id="原发者"><a href="#原发者" class="headerlink" title="原发者"></a>原发者</h6><pre><code>import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;

public class ReaderPhrase {
    long readPosition;
    File file;
    RandomAccessFile in;
    String phrase=null;
    public ReaderPhrase(File file) {
        this.file = file;
        try {
        in=new RandomAccessFile(file, &quot;r&quot;);

    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }
}
public Memento createMemento(){
    Memento mem=new Memento();
    mem.setPositionState(readPosition);
    return mem;
}
public void restoreFromMemento(Memento mem){
    readPosition=mem.getPositionState();
}
public String readLine(){
    try {
        in.seek(readPosition);
        if(phrase!=null){
            byte b[]=phrase.getBytes(&quot;iso-8859-1&quot;);
            phrase=new String(b);
        }
        readPosition=in.getFilePointer();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return phrase;
}
public void closeRead(){
    try {
        in.close();
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}

}
</code></pre><h6 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h6><pre><code>public class Memento implements java.io.Serializable{
        private long state;
        void setPositionState(long state){
        this.state=state;
        }
        long getPositionState(){
        return state;
        }

}
</code></pre><h6 id="负责人"><a href="#负责人" class="headerlink" title="负责人"></a>负责人</h6><pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class Caretaker {
File file;
private Memento memento=null;
public Caretaker() {
        file=new File(&quot;&quot;);
}
public Memento getMemento(){
    if(file.exists()){
        try {
            FileInputStream in=new FileInputStream(&quot;&quot;);
            ObjectInputStream inObject = null;
            try {
                inObject = new ObjectInputStream(in);
            } catch (IOException e1) {
                // TODO Auto-generated catch block
                e1.printStackTrace();
            }
            try {
                try {
                    memento=(Memento) inObject.readObject();
                } catch (ClassNotFoundException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

    }
    return memento;
}
public void saveMemento(Memento memento) {
    FileOutputStream out = null;
    try {
        out = new FileOutputStream(&quot;&quot;);
    } catch (FileNotFoundException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    try {
        ObjectOutputStream outObject=new ObjectOutputStream(out);
        outObject.writeObject(memento);
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

}

}
</code></pre><h6 id="模式的使用"><a href="#模式的使用" class="headerlink" title="模式的使用"></a>模式的使用</h6><pre><code>import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.Scanner;


public class Application {
    public static void main(String[] args) {
        Scanner reader=new Scanner(System.in);
        ReaderPhrase readerPhrase=new ReaderPhrase(new File(&quot;&quot;));
        File favorPhrase=new File(&quot;&quot;);
        RandomAccessFile out =null;
        try {
            out= new RandomAccessFile(favorPhrase, &quot;rw&quot;);

        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;Y or N&quot;);
        String answer=reader.nextLine();
        if(answer.startsWith(&quot;y&quot;)||answer.startsWith(&quot;Y&quot;)){
            Caretaker caretaker=new Caretaker();
            Memento memento=caretaker.getMemento();
            if(memento!=null)
                readerPhrase.restoreFromMemento(memento);
        }
            String phrase=null;
            while((phrase=readerPhrase.readLine())!=null){
                System.out.println(phrase);
                System.out.println();
                answer=reader.nextLine();
                if(answer.startsWith(&quot;y&quot;)||answer.startsWith(&quot;Y&quot;)){
                    try {
                        out.seek(favorPhrase.length());
                        byte []b=phrase.getBytes();
                        out.write(b);
                        out.writeChar(&apos;\n&apos;);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                    System.out.println(&quot;Y or Y&quot;);
                    answer=reader.nextLine();
                    if(answer.startsWith(&quot;y&quot;)||answer.startsWith(&quot;Y&quot;))
                        continue;
                    else{
                        readerPhrase.closeRead();
                        Caretaker caretaker=new Caretaker();
                        caretaker.saveMemento(readerPhrase.createMemento());

                        try {
                                out.close();

                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        System.exit(0);;
                    }
                }
                System.out.println(&quot;OK&quot;);
            }
}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink&quot; title=&quot;author：craymc&quot;&gt;&lt;/a&gt;&lt;strong&gt;author：craymc&lt;/strong&gt;&lt;/h5&gt;&lt;h2 id=&quot;定义：在
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>享元模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/享元模式详解/</id>
    <published>2017-01-29T04:10:15.000Z</published>
    <updated>2017-01-29T04:14:09.910Z</updated>
    
    <content type="html"><![CDATA[<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：运用共享技术有效地支持大量细粒度的对象。"><a href="#定义：运用共享技术有效地支持大量细粒度的对象。" class="headerlink" title="定义：运用共享技术有效地支持大量细粒度的对象。"></a>定义：运用共享技术有效地支持大量细粒度的对象。</h3><hr>
<h4 id="理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。"><a href="#理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。" class="headerlink" title="理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。"></a>理解：一个类中的成员变量表明该类所创建对象所具有的属性，在某些程序设计中可能用一个类创建若干个对象，但是发现这些对象的一个共同特点是他们有一部分属性的取值必须是完全相同。</h4><hr>
<h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>享元模式包括三种角色：</p>
<ul>
<li>享元接口：是一个接口，该接口定义了享元对外公开其内部数据的方法，以及享元接收外部数据的方法。</li>
<li>具体享元：实现享元接口的类，该类的实例称为享元对象，或简称享元。具体享元类的成员变量为享元对象的应用程序无法更改享元的内部状态，只有这样才能使得享元对象在系统中被共享。因为享元对象是用来共享的，所以不能允许用户各自地使用具体享元类来创建的对象显然是不同的，所以，具体享元类的构造方法必须是private的，其目的是不允许用户程序直接使用具体享元类创建享元对象，创建和管理享元对象由享元工厂负责。</li>
<li>享元工厂：享元工厂是一个类，该类的实例负责创建和管理享元对象，用户或其他对象必须请求享元工厂为它得到一个享元对象，当用户程序或其他若干个对象向享元对象，用户或其他对象必须请求享元对象，当用户程序或其他若干个对象向享元对象提供给请求者，否则就创建一个享元对象添加到散列表中，同时将该享元对象提供给请求者。显然，当若干个用户或对象请求享元工厂提供一个享元对象时，第一个用户获得该享元对象的时间可能慢一些，但是后继的用户会较快地获得这个享元对象。可以使用单列模式来设计享元工厂，既让系统中只有一个享元工厂的实例。另外，为了让享元工厂能生成享元对象，需要将具体享元类作为享元工厂的内部类。</li>
</ul>
<hr>
<h4 id="享元模式的优点"><a href="#享元模式的优点" class="headerlink" title="享元模式的优点"></a>享元模式的优点</h4><ul>
<li>使用享元可以节省内存的开销，特别适合处理大量细粒度对象，这些对象的许多属性值是相同的，而且一旦创建则不容许修改。</li>
<li>享元模式中的享元可以使用方法的参数接收外部状态中的数据，但外部状态数据不会干扰到享元中的内部数据，这就使享元可以在不同的环境中被共享。</li>
</ul>
<hr>
<h4 id="适合享元模式的场景"><a href="#适合享元模式的场景" class="headerlink" title="适合享元模式的场景"></a>适合享元模式的场景</h4><ul>
<li>一个应用程序使用大量的对象，这些对象之间部分属性本质上是相同的，这时应使用享元来封装相同的部分。</li>
<li>对象的多数状态都可变为外部状态，就可以考虑将这样对象作为系统中的享元来使用。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h5 id="享元接口"><a href="#享元接口" class="headerlink" title="享元接口"></a>享元接口</h5><pre><code>public interface Flyweight {
    public double getHeight();
    public double getWidth();
    public double getLength();
    public void printMess(String mess);
}
</code></pre><h5 id="享元工厂与具体享元"><a href="#享元工厂与具体享元" class="headerlink" title="享元工厂与具体享元"></a>享元工厂与具体享元</h5><pre><code>import java.util.HashMap;

public class FlyweightFactory {
        private HashMap&lt;String, Flyweight&gt; hashMap;
        static FlyweightFactory factory=new FlyweightFactory();
        private FlyweightFactory(){
            hashMap=new HashMap&lt;String,Flyweight&gt;();
        }
        public static FlyweightFactory getFactory(){
            return factory;
        }
        public synchronized Flyweight getFlyweight(String key){
            if(hashMap.containsKey(key))
                return hashMap.get(key);
            else{
                    double width=0,height=0,length=0;
                    String []str=key.split(&quot;#&quot;);
                    width=Double.parseDouble(str[0]);
                    height=Double.parseDouble(str[1]);
                    length=Double.parseDouble(str[2]);
                    Flyweight ft= new ConcreFlyweight(width, height, length);
                    hashMap.put(key, ft);
                    return ft;
                }
}
class ConcreFlyweight implements Flyweight{

    private double width;
    private double height;
    private double length;


    private ConcreFlyweight(double width, double height, double length) {
    this.width = width;
    this.height = height;
    this.length = length;
    }

    @Override
    public double getHeight() {

        return height;
    }

    @Override
    public double getWidth() {

        return width;
    }

    @Override
    public double getLength() {

    return length;
    }

    @Override
    public void printMess(String mess) {
        System.out.println(mess);
        System.out.println(&quot;宽度：&quot;+width);
        System.out.println(&quot;高度：&quot;+height);
        System.out.println(&quot;长度：&quot;+length);
    }
}
}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>public class Car {
    Flyweight flyweight;
    String name,color;
    int power;
    public Car(Flyweight flyweight, String name, String color, int power) {
    super();
    this.flyweight = flyweight;
    this.name = name;
    this.color = color;
    this.power = power;
    }
    public void print(){
        System.out.println(&quot;名称：&quot;+name);
        System.out.println(&quot;颜色：&quot;+color);
        System.out.println(&quot;功率：&quot;+power);
        System.out.println(&quot;宽度：&quot;+flyweight.getWidth());
        System.out.println(&quot;高度:&quot;+flyweight.getHeight());
        System.out.println(&quot;长度:&quot;+flyweight.getLength());
    }

}

public class Application {

    public static void main(String[] args) {

        FlyweightFactory factory=FlyweightFactory.getFactory();

        double width=1.82,height=1.47,length=5.12;

        String key=&quot;&quot;+width+&quot;#&quot;+height+&quot;#&quot;+length;

        Flyweight flyweight=factory.getFlyweight(key);

        Car audiA6One=new Car(flyweight, &quot;奥迪&quot;, &quot;黑色&quot;, 128);

        Car audiA6Two=new Car(flyweight, &quot;奥迪&quot;, &quot;灰色&quot;, 160);

        audiA6One.print();
        audiA6Two.print();

        width=1.77;
        height=1.45;
        length=4.63;

        key=&quot;&quot;+width+&quot;#&quot;+height+&quot;#&quot;+length;

        flyweight=factory.getFlyweight(key);

        Car audiA4One=new Car(flyweight, &quot;A4&quot;, &quot;蓝色&quot;, 126);
        Car audiA4Two=new Car(flyweight, &quot;A4&quot;, &quot;红色&quot;, 138);

        flyweight.printMess(&quot;名称：奥迪A6：颜色：蓝色 功率：126&quot;);
        flyweight.printMess(&quot;名称：A4 颜色：红色 功率：138&quot;);


    }

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;享元模式&quot;&gt;&lt;a href=&quot;#享元模式&quot; class=&quot;headerlink&quot; title=&quot;享元模式&quot;&gt;&lt;/a&gt;享元模式&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;headerlink
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/访问者模式详解/</id>
    <published>2017-01-29T04:09:46.000Z</published>
    <updated>2017-01-29T04:14:33.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="访问者模式详解"><a href="#访问者模式详解" class="headerlink" title="访问者模式详解"></a>访问者模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：-表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。"><a href="#定义：-表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。" class="headerlink" title="定义： 表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。"></a>定义： 表示一个作用于某些对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下定义作用于这些元素的新操作。</h4><hr>
<h4 id="理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。"><a href="#理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。" class="headerlink" title="理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。"></a>理解：编写类的时候，可能在该类中编写了若干个实例方法，该类的对象通过调用这些实例方法操作其成员变量表明所产生的行为。在某些设计中，可能需要定义作用于类成员变量的新操作，而且这个新操作不应该由该类中的某个实例方法来承担。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>访问者模式包括五种角色：</p>
<ul>
<li>抽象元素：一个抽象类，该类定义了接收访问者的accept操作。</li>
<li>具体元素：element的子类。</li>
<li>对象结构：一个集合，用于存放element对象，提供遍历它自己的方法。</li>
<li>抽象访问者：一个接口，该接口定义操作对象的方法。</li>
<li>具体访问者：实现visitot接口的类。</li>
</ul>
<hr>
<h4 id="双重分流"><a href="#双重分流" class="headerlink" title="双重分流"></a>双重分流</h4><h2 id="访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。"><a href="#访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。" class="headerlink" title="访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。"></a>访问者模式在不改变类的情况下可有效地增加其上的操作，为了达到这样的效果，使用了一种称为“双重分派”的技术：在访问者模式中，被访问者，既element角色element，首先调用accept方法“接收”访问者，而被接收的访问者visitor再调用visit方法访问当前element对象。</h2><h4 id="访问者模式的优点"><a href="#访问者模式的优点" class="headerlink" title="访问者模式的优点"></a>访问者模式的优点</h4><ul>
<li>可以在不改变一个集合中元素的类的情况下，增加新的施加于该元素上新操作、</li>
<li>可以将集合中各个元素的某些操作集中到访问者中，不仅便于集合的维护，也有利于集合中元素的复用。</li>
</ul>
<hr>
<h4 id="适合访问者的场景"><a href="#适合访问者的场景" class="headerlink" title="适合访问者的场景"></a>适合访问者的场景</h4><ul>
<li>一个对象结构中，比如某个集合中，包含很多对象，想对集合中的对象增加一些新的操作。</li>
<li>需要对集合中的对象进行很多不同的并且不相关的操作，而不仅不想修改对象的类，就可以使用访问者模式。访问者模式可以在visitor类中集中定义了<br>一些关于集合中对象的操作。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;访问者模式详解&quot;&gt;&lt;a href=&quot;#访问者模式详解&quot; class=&quot;headerlink&quot; title=&quot;访问者模式详解&quot;&gt;&lt;/a&gt;访问者模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>桥接模式</title>
    <link href="http://www.craymc.com/2017/01/29/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.craymc.com/2017/01/29/桥接模式/</id>
    <published>2017-01-29T04:09:22.000Z</published>
    <updated>2017-01-29T04:14:55.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="桥接模式详解"><a href="#桥接模式详解" class="headerlink" title="桥接模式详解"></a>桥接模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<p>[author：craymc][anchor-id]</p>
<h3 id="定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。"><a href="#定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。" class="headerlink" title="定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。"></a>定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。</h3><hr>
<h4 id="理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。"><a href="#理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。" class="headerlink" title="理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。"></a>理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。</h4><h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>桥接模式包括四种角色：</p>
<ul>
<li>抽象：是一个抽象类，该抽象类含有implementor声明的变量，既维护一个implemnentor类型对象。</li>
<li>实现者：实现者角色是一个接口，该接口中的方法不一定与abstract类中的方法一致。implementor接口负责定义基本操作，而abstract类负责定义基于这些基本操作的较高层次的操作。</li>
<li>细化抽象：是抽象角色的一个子类，该子类在重写抽象角色中的抽象方法时，在给出一些必要的操作后，将委托所维护implementor类型对象调用相应的方法。</li>
<li>具体实现者：是实现implementor接口的类。</li>
</ul>
<hr>
<h3 id="桥接模式的优点"><a href="#桥接模式的优点" class="headerlink" title="桥接模式的优点"></a>桥接模式的优点</h3><ul>
<li>桥接模式分离实现与抽象，使抽象和实现可以独立的扩展。当修改实现的代码时，不影响抽象的代码，反之也一样。</li>
<li>满足开-闭模式。抽象和实现者处于同层次，使系统可独立地扩展者两个层次。增加新的具体实现者，不需要修改细化抽象，反之增加新的细化抽象也不需要修改具体实现。</li>
</ul>
<hr>
<h3 id="适合桥接模式的情景"><a href="#适合桥接模式的情景" class="headerlink" title="适合桥接模式的情景"></a>适合桥接模式的情景</h3><ul>
<li>不想让抽象和某些重要的实现代码是固定的绑定关系，这部分实现可运行时动态决定。</li>
<li>抽象和实现者都可以继承的方式独立地扩充而互不影响，程序在运行期间可能需要动态的将一个抽象的子类的实例与一个实现者的子类的实例进行组合。</li>
<li>希望对实现者层次代码的修改对抽象层不产生影响，既抽象层的代码不必重新编译，反之亦然。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><hr>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>   public abstract class ArchitectureCore {<br>    BuildingDesign design;<br>    double unitPrice;<br>    public abstract double giveCost();</p>
<pre><code>}
</code></pre><h4 id="实现者"><a href="#实现者" class="headerlink" title="实现者"></a>实现者</h4><pre><code>public interface BuildingDesign {
    public double computerArea();
}
</code></pre><h4 id="细化抽象"><a href="#细化抽象" class="headerlink" title="细化抽象"></a>细化抽象</h4><pre><code>public class BuildingCost extends ArchitectureCore{
public BuildingCost(BuildingDesign design,double unitPrice) {
        this.design=design;
        this.unitPrice=unitPrice;
}



@Override
public double giveCost() {
    double area=design.computerArea();
    return area*unitPrice;
}

}
</code></pre><h4 id="具体实现者"><a href="#具体实现者" class="headerlink" title="具体实现者"></a>具体实现者</h4><pre><code>public class HouseDesign implements BuildingDesign{
double width,length;
int floorNumber;


public HouseDesign(double width, double length, int floorNumber) {
    this.width = width;
    this.length = length;
    this.floorNumber = floorNumber;
}


@Override
public double computerArea() {

    return width*length*floorNumber;
}

}
</code></pre><h4 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h4><pre><code>public class Application {
public static void main(String[] args) {
    double width=63,height=30;
    int floorNumber=8;
    double unitPrice=6867.38;
    BuildingDesign design=new HouseDesign(width, height, floorNumber);
    System.out.println(&quot;宽&quot;+width+&quot;米，高&quot;+height+&quot;米，层数为：&quot;+floorNumber);
    ArchitectureCore cost=new BuildingCost(design, unitPrice);
    double price=cost.giveCost();
    System.out.printf(&quot;每平方米造价为：&quot;+unitPrice+&quot;元的商业楼的建设成本：%.2f\n&quot;,price);
    width=50;
    height=28;
    floorNumber=6;
    unitPrice=2687.88;
    design=new HouseDesign(width, height, floorNumber);
    System.out.printf(&quot;宽&quot;+width+&quot;米，高&quot;+height+&quot;米，层数为&quot;+floorNumber);

    cost=new BuildingCost(design, unitPrice);
    price=cost.giveCost();
    System.out.printf(&quot;每平方米造价&quot;+unitPrice+&quot;元的住宅楼的建设成本%.2f\n&quot;,price);

}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;桥接模式详解&quot;&gt;&lt;a href=&quot;#桥接模式详解&quot; class=&quot;headerlink&quot; title=&quot;桥接模式详解&quot;&gt;&lt;/a&gt;桥接模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式详解</title>
    <link href="http://www.craymc.com/2017/01/29/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/29/代理模式详解/</id>
    <published>2017-01-29T04:08:58.000Z</published>
    <updated>2017-01-29T04:15:25.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代理模式详解"><a href="#代理模式详解" class="headerlink" title="代理模式详解"></a>代理模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：为其他对象提供一种代理以控制对这个对象的访问。"><a href="#定义：为其他对象提供一种代理以控制对这个对象的访问。" class="headerlink" title="定义：为其他对象提供一种代理以控制对这个对象的访问。"></a>定义：为其他对象提供一种代理以控制对这个对象的访问。</h4><hr>
<h4 id="理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。"><a href="#理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。" class="headerlink" title="理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。"></a>理解：当用户希望和某个对象打交道，但程序可能不希望用户之间访问该对象，而是提供一个特殊的对象，这个特殊的对象称为当前用户要访问对象的代理，程序让用户和对象的代理打交道，既让用户通过访问代理来访问想要访问的对象。</h4><hr>
<h4 id="代理的特点是：它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。"><a href="#代理的特点是：它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。" class="headerlink" title="代理的特点是：它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。"></a>代理的特点是：<strong>它与所代理的对象实现了相同的接口，代理和它所代理的对象向用户公开了相同的方法，当用户请求代理调用这样的方法时，代理可能需要验证某些信息或检查它所代理的对象是否可用，当代理确认它所代理的对象能调用相同的方法时，就把实际的方法调用委派给他它所代理的对象，既让所代理的对象调用同样的方法。</strong></h4><hr>
<h4 id="代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。"><a href="#代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。" class="headerlink" title="代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。"></a>代理模式是为对象提供一个代理，代理可以控制对它所代理对象的访问。</h4><hr>
<h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>代理模式包括三种角色</p>
<ul>
<li>抽象主题：是一个接口，该接口是对象和它的代理所共用的接口。</li>
<li>实际主题：实际主题是实现抽象主题接口的类。实际主题的实例是代理角色实例所要代理的对象。</li>
<li>代理：代理是实现抽象主题接口的类。代理含有主题接口声明的变量，该变量用来存放realSubject角色的实例引用，这样一来，代理的实例就可以控制对它所包含的realSubject角色的实例访问，既可以控制对它所代理对象的访问。</li>
</ul>
<hr>
<p>####　代理模式的优点</p>
<ul>
<li>代理模式可以屏蔽用户真正请求的对象，使用户程序和真正的对象之间解耦。</li>
<li><p>使用代理来担当哪些创建耗时的对象的替身。</p>
<h4 id="适合代理模式的场景"><a href="#适合代理模式的场景" class="headerlink" title="适合代理模式的场景"></a>适合代理模式的场景</h4></li>
<li><p>程序可能不希望用户直接访问该对象，而是提供一个特殊的对象以控制当前对象的访问</p>
</li>
<li>如果一个对象需要很长时间才能加载完成。</li>
<li>如果对象位于远程主机上，需要为用户提供访问该远程对象的能力。</li>
</ul>
<hr>
<h5 id="代码模式"><a href="#代码模式" class="headerlink" title="代码模式"></a>代码模式</h5><h6 id="抽象主题"><a href="#抽象主题" class="headerlink" title="抽象主题"></a>抽象主题</h6><pre><code>public interface Geometry {
    public double getArea();

}
</code></pre><h6 id="具体模板"><a href="#具体模板" class="headerlink" title="具体模板"></a>具体模板</h6><pre><code>public class Triangle implements Geometry{
 double sideA,sideB,sideC,area;


public Triangle(double sideA, double sideB, double sideC) {
    this.sideA = sideA;
    this.sideB = sideB;
    this.sideC = sideC;
}


@Override
public double getArea() {
    double p=(sideA+sideB+sideC)/2.0;
    area=Math.sqrt(p*(p-sideA)*(p-sideB)*(p-sideC));
    return area;
}

}
</code></pre><h6 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h6><pre><code>public class TriangleProxy implements Geometry{
double sideA,sideB,sideC;
Triangle Triangle;
public void setABC(double a,double b,double c){
    sideA=a;
    sideB=b;
    sideC=c;
}
@Override
public double getArea() {
    if(sideA+sideB&gt;sideC&amp;&amp;sideA+sideC&gt;sideB&amp;&amp;sideB+sideC&gt;sideA){
        Triangle=new Triangle(sideA, sideB, sideC);
        double area=Triangle.getArea();
        return area;
    }else{
        return -1;
    }
}

}
</code></pre><h6 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h6><pre><code>import java.util.Scanner;

public class Application {
    public static void main(String[] args) {
        Scanner reader=new Scanner(System.in);
        System.out.println(&quot;请输入按个数&quot;);
        double a=-1,b=-1,c=-1;
        a=reader.nextDouble();
        b=reader.nextDouble();
        c=reader.nextDouble();
        TriangleProxy proxy=new TriangleProxy();
        proxy.setABC(a, b, c);
        double area=proxy.getArea();
        System.out.println(&quot;面积是：&quot;+area);
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代理模式详解&quot;&gt;&lt;a href=&quot;#代理模式详解&quot; class=&quot;headerlink&quot; title=&quot;代理模式详解&quot;&gt;&lt;/a&gt;代理模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>状态模式详解</title>
    <link href="http://www.craymc.com/2017/01/26/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/26/状态模式详解/</id>
    <published>2017-01-26T14:05:31.000Z</published>
    <updated>2017-01-26T14:07:09.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="状态模式详解"><a href="#状态模式详解" class="headerlink" title="状态模式详解"></a>状态模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。"><a href="#定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。" class="headerlink" title="定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。"></a>定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</h3><hr>
<h4 id="理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。核心：状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。"><a href="#理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。核心：状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。" class="headerlink" title="理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。核心：状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。"></a>理解：一个对象的状态依赖于它的变量的取值情况，对象在不同的运行环境中，可能具有不同的状态。在许多情况下，对象调用方法所产生的行为效果依赖于它当时的状态。<strong>核心：</strong>状态模式的关键是将对象的状态封装成为独立的类，对象调用方法时，可以委托当前对象所具有的状态调用相应的方法，使当前对象看起来好像修改了它的类。</h4><hr>
<h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>状态模式包括三种角色：</p>
<ul>
<li>环境：环境是一个类，该类含有抽象状态声明的变量，可以引用任何具体状态类的实例。用户对该环境类的实例在某种状态下的行为感兴趣。</li>
<li>抽象状态：抽象状态是一个接口或抽象类。抽象状态中定义了与环境的一个特定状态相关的若干个方法。</li>
<li>具体状态：具体状态是实现抽象状态的类。</li>
</ul>
<hr>
<h4 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h4><h2 id="环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。"><a href="#环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。" class="headerlink" title="环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。"></a>环境实例在某种状态下执行一个方法后，可能导致该实例的状态发生变化。程序通过使用状态模式可方便地将环境实例从一个状态切换为另一个状态。当一个环境实例有确定的若干个状态时，可以由环境实例本身负责状态的切换，该环境实例可以含有所有状态的引用，并提供设置改变状态的方法。</h2><h4 id="状态模式的优点"><a href="#状态模式的优点" class="headerlink" title="状态模式的优点"></a>状态模式的优点</h4><ul>
<li>使用一个类封装对象的一种状态，很容易增加 新的状态。</li>
<li>在状态模式中，环境中不必出现大量的条件判断语句。环境实例所呈现的状态变得更加清晰，容易理解。</li>
<li>使用状态模式可以让用户程序很方便地切换环境实例状态。</li>
<li>使用状态模式不会让环境的实例中出现内部状态不一致的情况。</li>
<li>当前对象没有实例变量时，环境的各个实例可以共享一个状态对象。</li>
</ul>
<hr>
<h4 id="适合使用状态模式的情景"><a href="#适合使用状态模式的情景" class="headerlink" title="适合使用状态模式的情景"></a>适合使用状态模式的情景</h4><ul>
<li>一个对象的行为依赖于它的状态，并且它必须在运行时根据状态改变它的行为。</li>
<li>需要编写大量的条件分支语句来决定一个操作的行为，而且这些条件恰好表示对象的一种状态。</li>
</ul>
<hr>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><pre><code>public class Thermometer {
  TempreatureState state;
   public void showMessage(){
    System.out.println(&quot;****&quot;);
    state.showTemperature();
    System.out.println(&quot;*****&quot;);
}
public void setState(TempreatureState state){
    this.state=state;
}

}
</code></pre><h5 id="抽象状态"><a href="#抽象状态" class="headerlink" title="抽象状态"></a>抽象状态</h5><pre><code>public interface TempreatureState {
public void showTemperature();

 }
</code></pre><h5 id="具体状态"><a href="#具体状态" class="headerlink" title="具体状态"></a>具体状态</h5><pre><code>public class LowState implements TempreatureState {
  double n=0;


  public LowState(double n) {
    if(n&lt;=0)
    this.n = n;
   }


@Override
public void showTemperature() {
        System.out.println(&quot;现在的温度是&quot;+n+&quot;属于低温度&quot;);
}

}

public class MiddleState implements TempreatureState{
double n=15;



public MiddleState(int n) {
    if(n&gt;0&amp;&amp;n&lt;26)
    this.n = n;
}



@Override
public void showTemperature() {
    System.out.println(&quot;现在是温度是&quot;+n+&quot;属于正常温度&quot;);
}

}


public class HeightState implements TempreatureState{
   double n=39;


   public HeightState(double n) {
    if(n&gt;39)
    this.n = n;
    }


    @Override
    public void showTemperature() {
    System.out.println(&quot;现在温度是&quot;+n+&quot;属于高温&quot;);
     }

}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>public class Application {
    public static void main(String[] args) {

            TempreatureState state=new LowState(-12);
            Thermometer thermometer=new Thermometer();

            thermometer.setState(state);
            thermometer.showMessage();

            state=new MiddleState(20);
            thermometer.setState(state);
            thermometer.showMessage();

            state=new HeightState(39);
            thermometer.setState(state);
            thermometer.showMessage();
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;状态模式详解&quot;&gt;&lt;a href=&quot;#状态模式详解&quot; class=&quot;headerlink&quot; title=&quot;状态模式详解&quot;&gt;&lt;/a&gt;状态模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法详解</title>
    <link href="http://www.craymc.com/2017/01/26/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/26/模板方法详解/</id>
    <published>2017-01-26T14:04:55.000Z</published>
    <updated>2017-01-26T14:06:42.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模板方法详解"><a href="#模板方法详解" class="headerlink" title="模板方法详解"></a>模板方法详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h2 id="定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。"><a href="#定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。" class="headerlink" title="###　定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。"></a>###　定义：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可用不改变一个算法的结构即可重定义该算法的某些特定步骤。</h2><h4 id="理解：-类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。"><a href="#理解：-类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。" class="headerlink" title="理解： 类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。"></a>理解： 类中的方法用以表明该类的实例所具有的行为，一个类可以有许多方法，而且类中的实例方法也可以调用该类中的其他若干个方法。在编写类的时候，可能需要将类的许多方法集成到一个实例方法中，既用一个实例方法封装若干方法的调用，以此表示一个算法的骨架，也就是说，调用该实例方法相当于按着一定顺序执行若干个方法。</h4><h4 id="核心：模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象-类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。"><a href="#核心：模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象-类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。" class="headerlink" title="核心：模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象 类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。"></a><strong>核心：</strong>模板方法是关于怎样将若干个方法集成到一个方法中，以便于形成一个解决问题的算法骨架。模板方法模式的关键是在一个抽象 类中定义一个算法的骨架，既将若干个方法集成到一个方法中，并称该方法为一个模板方法，或简称为模板。模板方法所调用的其他方法通常为抽象的方法，这些抽象方法相当于算法骨架中的各个步骤，这些步骤的实现可以由子类进行重构去完成。</h4><h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>模板方法模式包括两种角色：</p>
<ul>
<li>抽象模板：抽象模板是一个抽象类。抽象模板定义了若干个方法来表示一个算法的各个步骤，这些方法中有抽象方法也有非抽象方法，其中的抽象方法称作<br>原语操作。更重要的一点是，抽象模板中还定义了一个称作模板方法的方法，该方法不仅包含有抽象模板中表示算法步骤的方法调用，而且也可以包含有定义在抽象模板中的其他对象方法调用，既模板方法定义了算法骨架。</li>
<li>具体模板：具体模板是抽象模板的子类，实现抽象模板中的原语操作。</li>
</ul>
<hr>
<h4 id="模板方法模式的优点："><a href="#模板方法模式的优点：" class="headerlink" title="模板方法模式的优点："></a>模板方法模式的优点：</h4><ul>
<li>可以通过在抽象模板定义模板方法给出成熟的算法步骤，同时又不限制步骤的细节，具体模板实现算法细节不会改变整个算法的骨架。</li>
<li>在抽象模板模式中，可以通过钩子方法对 某些步骤进行挂钩，具体模板通过钩子可以选择算法骨架中的某些步骤。</li>
</ul>
<hr>
<h4 id="适合模板方法模式的场景："><a href="#适合模板方法模式的场景：" class="headerlink" title="适合模板方法模式的场景："></a>适合模板方法模式的场景：</h4><ul>
<li>设计者需要给出一个算法的固定步骤，并将某些步骤的具体实现留给子类来实现。</li>
<li>需要对代码进行重构，将各个子类公共行为提取出来集中到一个共同的父类中以避免代码重复。</li>
</ul>
<hr>
<h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><h5 id="抽象模板"><a href="#抽象模板" class="headerlink" title="抽象模板"></a>抽象模板</h5><pre><code> import java.io.File;

public abstract class AbstractTemplate {  
   File[]allFile;
   File dir;
   public AbstractTemplate(File dir) {
    this.dir = dir;
    }
   public final void showFileName(){
    allFile=dir.listFiles();
    sort();
    printFiles();
    }
   public abstract void printFiles();
   public abstract void sort();

}
</code></pre><h5 id="具体模板"><a href="#具体模板" class="headerlink" title="具体模板"></a>具体模板</h5><pre><code>import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ConcreteTemplatel extends AbstractTemplate {


   public ConcreteTemplatel(File dir) {
    super(dir);
    }

    @Override
    public void printFiles() {
        for (int i = 0; i &lt; allFile.length; i++) {
            long time=allFile[i].lastModified();
            Date date=new Date();
            SimpleDateFormat matter=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
            String name=allFile[i].getName();
            int k=i+1;
            System.out.println(k+&quot; &quot;+name+&quot;(&quot;+name+&quot;)&quot;);
    }

}

    @Override
    public void sort() {
        for (int i = 0; i &lt; allFile.length; i++) {
            for (int j = i+1; j &lt; allFile.length; j++) {
                if(allFile[j].lastModified()&lt;allFile[i].lastModified()){
                    File file=allFile[j];
                    allFile[j]=allFile[i];
                    allFile[i]=file;
            }
        }
    }

}
}

import java.io.File;

public class ConcreteTemplate2  extends AbstractTemplate{

    public ConcreteTemplate2(File dir) {
    super(dir);
    }

    @Override
    public void printFiles() {
        for (int i = 0; i &lt; allFile.length; i++) {
            long fileSize=allFile[i].length();
            String name=allFile[i].getName();
            int k=i+1;
            System.out.println(k+&quot; &quot;+name+&quot;(&quot;+fileSize+&quot;字节&quot;);
        }
}

    @Override
    public void sort() {
        for (int i = 0; i &lt; allFile.length; i++) {
            for (int j = i+1; j &lt; allFile.length; j++) {
                if(allFile[j].length()&lt;allFile[i].length()){
                    File file=allFile[j];
                    allFile[j]=allFile[i];
                    allFile[i]=file;
            }
        }
    }
}

}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>import java.io.File;

public class Application {
    public static void main(String[] args) {
            File dir=new File(&quot;路径&quot;);
            AbstractTemplate template=new ConcreteTemplatel(dir);
            System.out.println(dir.getPath()+&quot;目录下的文件：&quot;);
            template.showFileName();
            template=new ConcreteTemplate2(dir);
            System.out.println(dir.getPath()+&quot;目录下的文件：&quot;);
            template.showFileName();


    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模板方法详解&quot;&gt;&lt;a href=&quot;#模板方法详解&quot; class=&quot;headerlink&quot; title=&quot;模板方法详解&quot;&gt;&lt;/a&gt;模板方法详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>桥接模式详解</title>
    <link href="http://www.craymc.com/2017/01/25/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/25/桥接模式详解/</id>
    <published>2017-01-25T12:11:29.000Z</published>
    <updated>2017-01-25T13:50:32.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="桥接模式详解"><a href="#桥接模式详解" class="headerlink" title="桥接模式详解"></a>桥接模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。"><a href="#定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。" class="headerlink" title="定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。"></a>定义：将抽象部分与它的实现部分分离，使他们都可以独立地变化。</h3><hr>
<h4 id="理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。"><a href="#理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。" class="headerlink" title="理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。"></a>理解：抽象类或接口中可以定义若干抽象方法，习惯上将抽象方法称作操作。抽象类或接口使程序的设计者忽略操作的细节，既不必考虑这些操作是如何实现的，当用户程序面向抽象类或接口时，就不会依赖具体的实现，使系统有很好扩展性。</h4><h4 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h4><p>桥接模式包括四种角色：</p>
<ul>
<li>抽象：是一个抽象类，该抽象类含有implementor声明的变量，既维护一个implemnentor类型对象。</li>
<li>实现者：实现者角色是一个接口，该接口中的方法不一定与abstract类中的方法一致。implementor接口负责定义基本操作，而abstract类负责定义基于这些基本操作的较高层次的操作。</li>
<li>细化抽象：是抽象角色的一个子类，该子类在重写抽象角色中的抽象方法时，在给出一些必要的操作后，将委托所维护implementor类型对象调用相应的方法。</li>
<li>具体实现者：是实现implementor接口的类。</li>
</ul>
<hr>
<h3 id="桥接模式的优点"><a href="#桥接模式的优点" class="headerlink" title="桥接模式的优点"></a>桥接模式的优点</h3><ul>
<li>桥接模式分离实现与抽象，使抽象和实现可以独立的扩展。当修改实现的代码时，不影响抽象的代码，反之也一样。</li>
<li>满足开-闭模式。抽象和实现者处于同层次，使系统可独立地扩展者两个层次。增加新的具体实现者，不需要修改细化抽象，反之增加新的细化抽象也不需要修改具体实现。</li>
</ul>
<hr>
<h3 id="适合桥接模式的情景"><a href="#适合桥接模式的情景" class="headerlink" title="适合桥接模式的情景"></a>适合桥接模式的情景</h3><ul>
<li>不想让抽象和某些重要的实现代码是固定的绑定关系，这部分实现可运行时动态决定。</li>
<li>抽象和实现者都可以继承的方式独立地扩充而互不影响，程序在运行期间可能需要动态的将一个抽象的子类的实例与一个实现者的子类的实例进行组合。</li>
<li>希望对实现者层次代码的修改对抽象层不产生影响，既抽象层的代码不必重新编译，反之亦然。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><hr>
<h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>   public abstract class ArchitectureCore {<br>    BuildingDesign design;<br>    double unitPrice;<br>    public abstract double giveCost();</p>
<pre><code>}
</code></pre><h4 id="实现者"><a href="#实现者" class="headerlink" title="实现者"></a>实现者</h4><pre><code>public interface BuildingDesign {
    public double computerArea();
}
</code></pre><h4 id="细化抽象"><a href="#细化抽象" class="headerlink" title="细化抽象"></a>细化抽象</h4><pre><code>public class BuildingCost extends ArchitectureCore{
public BuildingCost(BuildingDesign design,double unitPrice) {
        this.design=design;
        this.unitPrice=unitPrice;
}



@Override
public double giveCost() {
    double area=design.computerArea();
    return area*unitPrice;
}

}
</code></pre><h4 id="具体实现者"><a href="#具体实现者" class="headerlink" title="具体实现者"></a>具体实现者</h4><pre><code>public class HouseDesign implements BuildingDesign{
double width,length;
int floorNumber;


public HouseDesign(double width, double length, int floorNumber) {
    this.width = width;
    this.length = length;
    this.floorNumber = floorNumber;
}


@Override
public double computerArea() {

    return width*length*floorNumber;
}

}
</code></pre><h4 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h4><pre><code>public class Application {
public static void main(String[] args) {
    double width=63,height=30;
    int floorNumber=8;
    double unitPrice=6867.38;
    BuildingDesign design=new HouseDesign(width, height, floorNumber);
    System.out.println(&quot;宽&quot;+width+&quot;米，高&quot;+height+&quot;米，层数为：&quot;+floorNumber);
    ArchitectureCore cost=new BuildingCost(design, unitPrice);
    double price=cost.giveCost();
    System.out.printf(&quot;每平方米造价为：&quot;+unitPrice+&quot;元的商业楼的建设成本：%.2f\n&quot;,price);
    width=50;
    height=28;
    floorNumber=6;
    unitPrice=2687.88;
    design=new HouseDesign(width, height, floorNumber);
    System.out.printf(&quot;宽&quot;+width+&quot;米，高&quot;+height+&quot;米，层数为&quot;+floorNumber);

    cost=new BuildingCost(design, unitPrice);
    price=cost.giveCost();
    System.out.printf(&quot;每平方米造价&quot;+unitPrice+&quot;元的住宅楼的建设成本%.2f\n&quot;,price);

}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;桥接模式详解&quot;&gt;&lt;a href=&quot;#桥接模式详解&quot; class=&quot;headerlink&quot; title=&quot;桥接模式详解&quot;&gt;&lt;/a&gt;桥接模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>组合模式详解</title>
    <link href="http://www.craymc.com/2017/01/25/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/25/组合模式详解/</id>
    <published>2017-01-25T12:08:18.000Z</published>
    <updated>2017-01-25T14:12:30.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组合模式详解"><a href="#组合模式详解" class="headerlink" title="组合模式详解"></a>组合模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使用户对单个对象和组合对象的使用具有一致性。"><a href="#定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使用户对单个对象和组合对象的使用具有一致性。" class="headerlink" title="定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使用户对单个对象和组合对象的使用具有一致性。"></a>定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使用户对单个对象和组合对象的使用具有一致性。</h3><hr>
<h3 id="理解：如果一个对象包含另一个对象的引用，称这样的对象为组合对象。如果将当前组合对象作为一个整体的话，那么它所包含的对象就是整体的一部分。如果一个对象不含有其他对象的引用，称这样的对象为个体对象。"><a href="#理解：如果一个对象包含另一个对象的引用，称这样的对象为组合对象。如果将当前组合对象作为一个整体的话，那么它所包含的对象就是整体的一部分。如果一个对象不含有其他对象的引用，称这样的对象为个体对象。" class="headerlink" title="理解：如果一个对象包含另一个对象的引用，称这样的对象为组合对象。如果将当前组合对象作为一个整体的话，那么它所包含的对象就是整体的一部分。如果一个对象不含有其他对象的引用，称这样的对象为个体对象。"></a>理解：如果一个对象包含另一个对象的引用，称这样的对象为组合对象。如果将当前组合对象作为一个整体的话，那么它所包含的对象就是整体的一部分。如果一个对象不含有其他对象的引用，称这样的对象为个体对象。</h3><hr>
<h3 id="组合模式包括三种角色："><a href="#组合模式包括三种角色：" class="headerlink" title="组合模式包括三种角色："></a>组合模式包括三种角色：</h3><ul>
<li>抽象组件：是一个接口（抽象类），该接口（抽象类）定义了个体对象和组合对象需要实现的关于操作其子节点的方法，比如add(),remove(),以及getChild()等方法。抽象组件也可以定义个体对象和组合对象用于操作其自身的方法，比如isLeaf（）方法等。</li>
<li>Composite节点：实现component接口类的实例，composite节点不仅实现component接口，而且可以含有其他composite节点或leaf节点的引用。</li>
<li>Leaf节点：实现component接口类的实例，leaf节点实现component接口，不可以含有其他composite节点或leaf节点的引用，因此，叶节点在实现component接口有关操作子节点的方法时，可以让方法抛出一个异常，也可以实现为空操作。</li>
</ul>
<hr>
<h3 id="组合模式的优点"><a href="#组合模式的优点" class="headerlink" title="组合模式的优点"></a>组合模式的优点</h3><ul>
<li>组合模式中包含个体对象和组合对象，并形成树形结构，使用户可以方便地处理个体对象和组合对象。</li>
<li>组合对象和个体对象实现了相同的接口，用户一般无须区分个体对象和组合对象。</li>
<li>当增加新的composite节点和Leaf节点时，用户的重要代码不需要作出修改。</li>
</ul>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><hr>
<h4 id="抽象组件"><a href="#抽象组件" class="headerlink" title="抽象组件"></a>抽象组件</h4><pre><code>import java.util.Iterator;

public interface MilitaryPerson {
    public void add(MilitaryPerson person);
    public void remove(MilitaryPerson person);
    public MilitaryPerson getChild(int index);
    public Iterator&lt;MilitaryPerson&gt; getAllChildren();
    public boolean isleaf();
    public double getSalary();
    public void setSalary(double salary);
}
</code></pre><h4 id="composite节点"><a href="#composite节点" class="headerlink" title="composite节点"></a>composite节点</h4><pre><code>import java.util.Iterator;
import java.util.LinkedList;

public class MilitaryOfficer implements MilitaryPerson {
            LinkedList&lt;MilitaryPerson&gt; list;
            String name;
            double salary;


public MilitaryOfficer( String name,
        double salary) {
    list=new LinkedList&lt;MilitaryPerson&gt;();
    this.name = name;
    this.salary = salary;
}

@Override
public void add(MilitaryPerson person) {
    list.add(person);

}

@Override
public void remove(MilitaryPerson person) {
        list.remove(person);
}

@Override
public MilitaryPerson getChild(int index) {
    return list.get(index);
}

@Override
public Iterator&lt;MilitaryPerson&gt; getAllChildren() {
    return list.iterator();
}

@Override
public boolean isleaf() {
    return false;
}

@Override
public double getSalary() {
    return salary;
}

@Override
public void setSalary(double salary) {
    this.salary=salary;
}


}
</code></pre><h4 id="Leaf节点"><a href="#Leaf节点" class="headerlink" title="Leaf节点"></a>Leaf节点</h4><pre><code>import java.util.Iterator;

public class MilitarySoldier implements MilitaryPerson {
       double salary;
       String name;

public MilitarySoldier(double salary, String name) {
    this.salary = salary;
    this.name = name;
}

@Override
public void add(MilitaryPerson person) {

}

@Override
public void remove(MilitaryPerson person) {

}

@Override
public MilitaryPerson getChild(int index) {
    return null;
}

@Override
public Iterator&lt;MilitaryPerson&gt; getAllChildren() {
    return null;
}

@Override
public boolean isleaf() {
    return true;
}

@Override
public double getSalary() {
    return salary;
}

@Override
public void setSalary(double salary) {
    this.salary=salary;
}

}
</code></pre><h4 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h4><pre><code>import java.util.Iterator;

public class ComputerSalary {
    public static double computerSalary(MilitaryPerson person){
         double sum=0;
         if(person.isleaf()==true){
        sum=sum+person.getSalary();
    }
    if(person.isleaf()==false){
        sum=sum+person.getSalary();
        Iterator&lt;MilitaryPerson&gt;iterator=person.getAllChildren();
        while(iterator.hasNext()){
            MilitaryPerson p=iterator.next();
            sum=sum+computerSalary(p);
        }

    }


    return sum;




}
}

public class Application {
public static void main(String[] args) {
    MilitaryPerson 连长=new MilitaryOfficer( &quot;连长&quot;, 5000);
    MilitaryPerson 排长1=new MilitaryOfficer(&quot;一排长&quot;, 4000);
    MilitaryPerson 排长2=new MilitaryOfficer(&quot;二排长&quot;, 4000);

    MilitaryPerson 班长11=new MilitaryOfficer(&quot;一班长&quot;, 2000);
    MilitaryPerson 班长12=new MilitaryOfficer(&quot;二班长&quot;, 2000);
    MilitaryPerson 班长13=new MilitaryOfficer(&quot;三班长&quot;, 2000);

    MilitaryPerson 班长21=new MilitaryOfficer(&quot;一班长&quot;, 2000);
    MilitaryPerson 班长22=new MilitaryOfficer(&quot;二班长&quot;, 2000);
    MilitaryPerson 班长23=new MilitaryOfficer(&quot;三班长&quot;, 2000);

    MilitaryPerson 班长31=new MilitaryOfficer(&quot;一班长&quot;, 2000);
    MilitaryPerson 班长32=new MilitaryOfficer(&quot;二班长&quot;, 2000);
    MilitaryPerson 班长33=new MilitaryOfficer(&quot;三班长&quot;, 2000);

    MilitaryPerson [] 士兵=new MilitarySoldier[600];
    for (int i = 0; i &lt; 士兵.length; i++) {
        士兵[i]=new MilitarySoldier(1000, &quot;小兵&quot;);

    }
    连长.add(排长1);
    连长.add(排长2);
    排长1.add(班长11);
    排长1.add(班长12);
    排长1.add(班长13);

    排长2.add(班长21);
    排长2.add(班长22);
    排长2.add(班长23);

    for (int i = 0; i &lt;=9; i++) {
        班长11.add(士兵[i]);
        班长12.add(士兵[i+10]);
        班长13.add(士兵[i+20]);

        班长21.add(士兵[i+30]);
        班长22.add(士兵[i+40]);
        班长23.add(士兵[i+50]);

        班长31.add(士兵[i+60]);
        班长32.add(士兵[i+70]);
        班长33.add(士兵[i+80]);
    }
    System.out.println(&quot;一班的军饷：&quot;+ComputerSalary.computerSalary(班长11));
    System.out.println(&quot;一排的军饷:&quot;+ComputerSalary.computerSalary(排长1));
    System.out.println(&quot;全连的军饷:&quot;+ComputerSalary.computerSalary(连长));




}
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;组合模式详解&quot;&gt;&lt;a href=&quot;#组合模式详解&quot; class=&quot;headerlink&quot; title=&quot;组合模式详解&quot;&gt;&lt;/a&gt;组合模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式详解</title>
    <link href="http://www.craymc.com/2017/01/23/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/23/原型模式详解/</id>
    <published>2017-01-23T15:14:43.000Z</published>
    <updated>2017-01-23T15:21:38.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型模式详解"><a href="#原型模式详解" class="headerlink" title="原型模式详解"></a>原型模式详解</h2><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。"><a href="#定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。" class="headerlink" title="定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。"></a>定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</h3><hr>
<h3 id="原型模式的优点"><a href="#原型模式的优点" class="headerlink" title="原型模式的优点"></a>原型模式的优点</h3><ul>
<li>当创建类的新实例的代价更大时，使用原型模式复制一个已有的实例可以提高创建新实例的效率。</li>
<li>可以动态地保存当前对象的动态。在运行时，可以随时使用对象流保存当前对象的一个复制品。</li>
<li>可以在运行时创建新的对象，而无须创建一系列类和继承结构。</li>
<li>可以动态地添加，删除原型复制品。</li>
</ul>
<hr>
<h3 id="原型模式的适用场景"><a href="#原型模式的适用场景" class="headerlink" title="原型模式的适用场景"></a>原型模式的适用场景</h3><ul>
<li>程序需要从一个对象出发，得到若干个和其状态相同，并可独立变化其状态的对象时。</li>
<li>当对象的创建需要独立于它的构造过程和表示时。</li>
</ul>
<hr>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在某些情况下，可能不希望反复使用类的构造方法创建许多对象，而是希望用该类创建一个对象后，以该对象为原型得到该对象的若干个复制品。也就是说，将一个对象定义为原型对象，要求该原型对象提供一个方法，使该原型对象调用此方法可以复制一个和自己有完全相同状态的同类型对象，既该方法“克隆”原型对象得到一个新对象。<strong>核心：</strong>原型模式是从一个对象出发得到一个和自己有相同状态的新对象的成熟模式，该模式的关键是将一个对象定义为原型，并为其提供复制自己方法。</p>
<hr>
<h3 id="在Java-lang-Object的clone-方法以及在Serializable接口和对象流复制对象。"><a href="#在Java-lang-Object的clone-方法以及在Serializable接口和对象流复制对象。" class="headerlink" title="在Java.lang.Object的clone()方法以及在Serializable接口和对象流复制对象。"></a><strong>在Java.lang.Object的clone()方法以及在Serializable接口和对象流复制对象。</strong></h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型模式详解&quot;&gt;&lt;a href=&quot;#原型模式详解&quot; class=&quot;headerlink&quot; title=&quot;原型模式详解&quot;&gt;&lt;/a&gt;原型模式详解&lt;/h2&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>生成器模式详解</title>
    <link href="http://www.craymc.com/2017/01/23/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/23/生成器模式详解/</id>
    <published>2017-01-23T15:14:16.000Z</published>
    <updated>2017-01-23T15:20:30.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型模式详解"><a href="#原型模式详解" class="headerlink" title="原型模式详解"></a>原型模式详解</h2><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。"><a href="#定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。" class="headerlink" title="定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。"></a>定义：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</h3><hr>
<h3 id="原型模式的优点"><a href="#原型模式的优点" class="headerlink" title="原型模式的优点"></a>原型模式的优点</h3><ul>
<li>当创建类的新实例的代价更大时，使用原型模式复制一个已有的实例可以提高创建新实例的效率。</li>
<li>可以动态地保存当前对象的动态。在运行时，可以随时使用对象流保存当前对象的一个复制品。</li>
<li>可以在运行时创建新的对象，而无须创建一系列类和继承结构。</li>
<li>可以动态地添加，删除原型复制品。</li>
</ul>
<hr>
<h3 id="原型模式的适用场景"><a href="#原型模式的适用场景" class="headerlink" title="原型模式的适用场景"></a>原型模式的适用场景</h3><ul>
<li>程序需要从一个对象出发，得到若干个和其状态相同，并可独立变化其状态的对象时。</li>
<li>当对象的创建需要独立于它的构造过程和表示时。</li>
</ul>
<hr>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在某些情况下，可能不希望反复使用类的构造方法创建许多对象，而是希望用该类创建一个对象后，以该对象为原型得到该对象的若干个复制品。也就是说，将一个对象定义为原型对象，要求该原型对象提供一个方法，使该原型对象调用此方法可以复制一个和自己有完全相同状态的同类型对象，既该方法“克隆”原型对象得到一个新对象。<strong>核心：</strong>原型模式是从一个对象出发得到一个和自己有相同状态的新对象的成熟模式，该模式的关键是将一个对象定义为原型，并为其提供复制自己方法。</p>
<hr>
<h3 id="在Java-lang-Object的clone-方法以及在Serializable接口和对象流复制对象。"><a href="#在Java-lang-Object的clone-方法以及在Serializable接口和对象流复制对象。" class="headerlink" title="在Java.lang.Object的clone()方法以及在Serializable接口和对象流复制对象。"></a><strong>在Java.lang.Object的clone()方法以及在Serializable接口和对象流复制对象。</strong></h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原型模式详解&quot;&gt;&lt;a href=&quot;#原型模式详解&quot; class=&quot;headerlink&quot; title=&quot;原型模式详解&quot;&gt;&lt;/a&gt;原型模式详解&lt;/h2&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/适配器模式详解/</id>
    <published>2017-01-22T13:42:33.000Z</published>
    <updated>2017-01-22T13:52:06.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="适配器模式详解"><a href="#适配器模式详解" class="headerlink" title="适配器模式详解"></a>适配器模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。"><a href="#定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。" class="headerlink" title="定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。"></a>定义：将一个类的接口转换成客户希望的另一个接口。adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>对象适配器模式的结构中包括三种角色：</p>
<ul>
<li>目标： 目标是一个接口，该接口是客户想要使用的接口。</li>
<li>被适配者： 被适配者是一个已经存在的接口或抽象类，这个接口或抽象类需要适配。</li>
<li>适配器：适配器是一个类，该类实现了目标接口并包含有被适配者的引用，既适配器的职责是对被适配者接口（抽象类）与目标接口进行适配。</li>
</ul>
<hr>
<h4 id="适配器的适配程度"><a href="#适配器的适配程度" class="headerlink" title="适配器的适配程度"></a>适配器的适配程度</h4><p>1.完全适配<br>如果目标接口中的方法数目与被适配者接口的方法数目相等，那么适配器可将被适配者接口与目标接口进行完全适配。<br>2.不完全适配<br>如果目标接口中的方法数目少于被适配者接口的方法数目，那么适配器只能将被适配者接口与目标接口进行部分适配。<br>3.剩余适配<br>如果目标接口中的方法数目大于被适配者接口的方法数目，那么适配器可将被适配者接口与目标接口进行完全适配，但必须将目标多余的办法给出用户允许的默认实现。</p>
<h4 id="适配器模式的优点"><a href="#适配器模式的优点" class="headerlink" title="适配器模式的优点"></a>适配器模式的优点</h4><ul>
<li>目标和被适配者是完全解耦的关系。</li>
<li>适配器模式满足“开-闭原则”。当添加一个实现adapter接口的新类时，不必修改adapter，adapter就能对这个新类的实例进行适配。</li>
</ul>
<hr>
<h4 id="适配器模式的使用场景"><a href="#适配器模式的使用场景" class="headerlink" title="适配器模式的使用场景"></a>适配器模式的使用场景</h4><h2 id="一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。"><a href="#一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。" class="headerlink" title=" 一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。"></a> 一个程序想使使用已经存在的类，但该类所实现的接口和当前程序所使用的接口不一致。</h2><h5 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h5><h6 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h6><pre><code>public interface ThreeElectricOutlet {
public abstract void connectElectricCurrent();
}
</code></pre><h6 id="被适配者："><a href="#被适配者：" class="headerlink" title="被适配者："></a>被适配者：</h6><pre><code>public interface TwoElectricOutlet {

public abstract void connectElectricCurrent();

}
</code></pre><h6 id="适配器："><a href="#适配器：" class="headerlink" title="适配器："></a>适配器：</h6><pre><code>public class TreeElectricAdapter implements ThreeElectricOutlet {

TwoElectricOutlet outlet;


public TreeElectricAdapter(TwoElectricOutlet outlet) {
    super();
    this.outlet = outlet;
}


@Override
public void connectElectricCurrent() {
    outlet.connectElectricCurrent();
}

}
</code></pre><h6 id="模式使用："><a href="#模式使用：" class="headerlink" title="模式使用："></a>模式使用：</h6><pre><code>public class Application {
        public static void main(String[] args) {
            ThreeElectricOutlet outlet;
            Wash w=new Wash();
            outlet=w;
            System.out.println(&quot;使用三相插座：&quot;);
            outlet.connectElectricCurrent();
            TV t=new TV();
            TreeElectricAdapter adapter=new TreeElectricAdapter(t);
            outlet=adapter;
            System.out.println(&quot;使用三相插座&quot;);
            outlet.connectElectricCurrent();
        }
}
class Wash implements ThreeElectricOutlet{
String name;
Wash(){
    name=&quot;黄河洗衣机&quot;;
}


public Wash(String s) {
        name=s;
}


@Override
public void connectElectricCurrent() {
        turnOn();
}


public void turnOn() {
    System.out.println(name+&quot;starting.....&quot;);
}
}
class TV implements TwoElectricOutlet{
String name;
TV(){
    name=&quot;长江电视&quot;;

}
public TV(String s) {
    name = s;
}


@Override
public void connectElectricCurrent() {
        turnOn();
}
public void turnOn() {
    System.out.println(name+&quot;开始播放节目&quot;);
}


} 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;适配器模式详解&quot;&gt;&lt;a href=&quot;#适配器模式详解&quot; class=&quot;headerlink&quot; title=&quot;适配器模式详解&quot;&gt;&lt;/a&gt;适配器模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>外观模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/外观模式详解/</id>
    <published>2017-01-22T13:41:27.000Z</published>
    <updated>2017-01-22T13:51:52.999Z</updated>
    
    <content type="html"><![CDATA[<h3 id="外观模式详解"><a href="#外观模式详解" class="headerlink" title="外观模式详解"></a>外观模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。"><a href="#定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。" class="headerlink" title="定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。"></a>定义：为系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</h3><hr>
<h3 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h3><p>外观模式的结构中包括两种角色：</p>
<ul>
<li>子系统：子系统是若干个类的集合，这些类的实例协同合作作为用户提供所需要的功能，子系统中任何类都不包括外观类的实例引用。</li>
<li>外观：外观是一个类，该类包含子系统中全部或部分类的实例引用，当用户想要和子系统中的若干类的实例打交道时，可以代替地和子系统的外观类的实例打交道。</li>
</ul>
<hr>
<h3 id="外观模式的优点"><a href="#外观模式的优点" class="headerlink" title="外观模式的优点"></a>外观模式的优点</h3><ul>
<li>使客户和子系统中的类无耦合，并且使子系统使用起来更加方便。</li>
<li>外观只是提供了一个更加简洁的界面，并不影响用户直接使用子系统中的类。</li>
<li>子系统中任何类对其方法的内容进行修改，不影响外观类的代码。</li>
</ul>
<hr>
<h3 id="使用外观模式的情景"><a href="#使用外观模式的情景" class="headerlink" title="使用外观模式的情景"></a>使用外观模式的情景</h3><ul>
<li>对于一个复杂的子系统，需要为用户提供一个单的交互操作。</li>
<li>不希望客户代码和子系统中的类有耦合，以便提高子系统的独立性和可移植性。</li>
<li>当整个系统需要构建一个层次结构的子系统，不希望这些子系统相互直接的交互。</li>
</ul>
<hr>
<h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><h5 id="子系统："><a href="#子系统：" class="headerlink" title="子系统："></a>子系统：</h5><pre><code>import java.io.BufferedReader;
import java.io.FileReader;

public class ReadFile { 
    public  String readFileContent(String fileName){
        StringBuffer str=new StringBuffer();
        try {
            FileReader inOne=new FileReader(fileName);
            BufferedReader inTwo=new BufferedReader(inOne);
            String s=null;
            while((s=inTwo.readLine())!=null){
                str.append(s);
                str.append(&quot;\n&quot;);
            }
            inOne.close();
            inTwo.close();
        } catch (Exception e) {
        }
        return new String(str);

    }
}
import java.util.regex.Matcher;
java.util.regex.Pattern;

public class AnalyzeInformation {
public String getSavedContent(String content,String deleteContent){
    Pattern p;
    Matcher m;
    p=Pattern.compile(deleteContent);
    m=p.matcher(content);
    String savedContent=m.replaceAll(&quot;&quot;);
    return savedContent;

}

}
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.StringReader;

public class WriteFile {

public void writeToFile(String fileName,String content){
    StringBuffer str=new StringBuffer();
    try {
        StringReader inOne=new StringReader(content);
        BufferedReader inTwo=new BufferedReader(inOne);
        FileWriter outOne=new FileWriter(fileName);
        BufferedWriter outTwo=new BufferedWriter(outOne);
        String s=null;
        while((s=inTwo.readLine())!=null){
            outTwo.write(s);
            outTwo.newLine();
            outTwo.flush();
        }
        inOne.close();
        inTwo.close();
        outOne.close();
        outTwo.close();
    } catch (Exception e) {
        // TODO: handle exception
    }


}

}
</code></pre><h5 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h5><pre><code>public class ReadAndWirteFacade {
private ReadFile readFile;
private WriteFile writeFile;
private AnalyzeInformation analyzeInformation;
public ReadAndWirteFacade() {
    readFile=new ReadFile();
    analyzeInformation=new AnalyzeInformation();
    writeFile=new WriteFile();
}
public void doOption(String readFileName,String delContent,String savedFileName){
    String content=readFile.readFileContent(readFileName);
    System.out.println(&quot;读取文件&quot;+readFileName+&quot;的内容&quot;);
    System.out.println(content);
    String savedContent=analyzeInformation.getSavedContent(content, delContent);
    writeFile.writeToFile(savedFileName, savedContent);
    System.out.println(&quot;保存到文件&quot;+savedContent+&quot;中的内容&quot;);
    System.out.println(savedContent);

}

}
</code></pre><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><pre><code>public class Application {
    public static void main(String[] args) {
        ReadAndWirteFacade clientFacade;
        clientFacade=new ReadAndWirteFacade();
        String readFileName=&quot;index.html&quot;;
        String delConten=&quot;&lt;[^&gt;]*&gt;&quot;;
        String savedFileName=&quot;save.txt&quot;;
        clientFacade.doOption(readFileName, delConten, savedFileName);
public class Application {
    public static void main(String[] args) {
        ReadAndWirteFacade clientFacade;
        clientFacade=new ReadAndWirteFacade();
        String readFileName=&quot;index.html&quot;;
        String delConten=&quot;&lt;[^&gt;]*&gt;&quot;;
        String savedFileName=&quot;save.txt&quot;;
        clientFacade.doOption(readFileName, delConten, savedFileName);
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;外观模式详解&quot;&gt;&lt;a href=&quot;#外观模式详解&quot; class=&quot;headerlink&quot; title=&quot;外观模式详解&quot;&gt;&lt;/a&gt;外观模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/责任链模式详解/</id>
    <published>2017-01-22T13:39:35.000Z</published>
    <updated>2017-01-22T13:51:41.605Z</updated>
    
    <content type="html"><![CDATA[<h3 id="责任链模式详解"><a href="#责任链模式详解" class="headerlink" title="责任链模式详解"></a>责任链模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><h4 id="定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。"><a href="#定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。" class="headerlink" title="定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。"></a>定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</h4><hr>
<h4 id="模式的结构与使用"><a href="#模式的结构与使用" class="headerlink" title="模式的结构与使用"></a>模式的结构与使用</h4><p>责任链模式的结构中包括两种角色：</p>
<ul>
<li>处理者：处理者是一个接口，负责规定具体处理者处理用户请求的方法以及具体处理者设置后继对象的方法。</li>
<li><p>具体处理者：具体处理者是实现处理者接口的类的实例。具体处理者通过调用处理者接口规定的方法处理用户的请求，既在接到用户的请求后，处理者将调用接口规定的方法，在执行该方法的过程中，如果发现能处理用户的请求，就处理有关数据，否则就反馈无法处理的信息给用户，然后将用户的请求传递给自己的后继对象。</p>
<h4 id="责任链模式的优点"><a href="#责任链模式的优点" class="headerlink" title="责任链模式的优点"></a>责任链模式的优点</h4></li>
<li><p>责任链中的对象只和自己的后继是低耦合关系，和其他对象毫无关联，这使得编写处理者对象以及创建责任链变得非常容易。</p>
</li>
<li>当在处理者中分配职责时，责任链给应用程序更多的灵活性。</li>
</ul>
<hr>
<h4 id="责任链的适用模式和情景"><a href="#责任链的适用模式和情景" class="headerlink" title="责任链的适用模式和情景"></a>责任链的适用模式和情景</h4><ul>
<li>有许多对象可以处理用户的请求，希望程序在运行期间自动确定处理用户的那个对象。</li>
<li>希望用户不必明确指定接收者的情况下，向多个接收者的一个提交请求。</li>
<li>程序希望动态制定可处理用户请求的对象集合。</li>
</ul>
<hr>
<h5 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h5><h6 id="处理者："><a href="#处理者：" class="headerlink" title="处理者："></a>处理者：</h6><pre><code>public interface Handler {
public abstract void computerMultiply(String number);
public abstract void setNextHandler(Handler handler);
}
</code></pre><h6 id="具体处理者："><a href="#具体处理者：" class="headerlink" title="具体处理者："></a>具体处理者：</h6><pre><code>public class UseInt implements Handler{
private Handler handler;
private int result=1;
@Override
public void computerMultiply(String number) {
        try {
            int n=Integer.parseInt(number);
            int i=1;
            while(i&lt;=n){
                result=result*i;
                if(result&lt;=0){
                    System.out.println(&quot;超出我的能力范围&quot;);
                    handler.computerMultiply(number);
                    return;
                }
                i++;
            }
            System.out.println(number+&quot;的阶乘:&quot;+result);
        } catch (Exception e) {
            // TODO: handle exception
        }
}
@Override
public void setNextHandler(Handler handler) {
        this.handler=handler;
}
}

public class UseLong implements Handler {
private Handler handler;
private long result=1;

@Override
public void computerMultiply(String number) {
        try {
            long n=Long.parseLong(number);
            long i=1;
            while(i&lt;=n){
                result=result*i;
                if(result&lt;=0){
                    System.out.println(&quot;超出能力范围,,,&quot;);
                    handler.computerMultiply(number);
                    return;
                }
                i++;
            }
            System.out.println(number+&quot;的阶乘&quot;+result);
        } catch (Exception e) {
            // TODO: handle exception
        }
}
@Override
public void setNextHandler(Handler handler) {
        this.handler=handler;
}
}

import java.math.BigInteger;

public class UseBigInteger implements Handler{
private Handler handler;
private BigInteger result=new BigInteger(&quot;1&quot;);
@Override
public void computerMultiply(String number) {
        try {
            BigInteger n=new BigInteger(number);
            BigInteger ONE=new BigInteger(&quot;1&quot;);
            BigInteger i=ONE;
            while(i.compareTo(n)&lt;=0){
                result=result.multiply(i);
                i=i.add(ONE);
            }
            System.out.println(number+&quot;的阶乘&quot;+result);
        } catch (Exception e) {
            // TODO: handle exception
        }
}
@Override
public void setNextHandler(Handler handler) {
        this.handler=handler;
}
}
</code></pre><h6 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h6><pre><code>public class Application {

        private Handler useInt, useLong, useBig;
        public void createChain(){
            useInt=new UseInt();
            useLong=new UseLong();
            useBig=new UseBigInteger();
            useInt.setNextHandler(useLong);
            useLong.setNextHandler(useBig);
        }
        public void responseClient(String number){
            useInt.computerMultiply(number);
        }
        public static void main(String[] args) {
            Application application=new Application();
            application.createChain();
            application.responseClient(&quot;32&quot;);
        }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;责任链模式详解&quot;&gt;&lt;a href=&quot;#责任链模式详解&quot; class=&quot;headerlink&quot; title=&quot;责任链模式详解&quot;&gt;&lt;/a&gt;责任链模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单子模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E5%8D%95%E5%AD%90%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/单子模式详解/</id>
    <published>2017-01-22T13:38:44.000Z</published>
    <updated>2017-01-22T13:51:36.239Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单子模式详解"><a href="#单子模式详解" class="headerlink" title="单子模式详解"></a>单子模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h2 id="定义：-保证一个类只有一个实例，并提供一个访问它的全局访问点。"><a href="#定义：-保证一个类只有一个实例，并提供一个访问它的全局访问点。" class="headerlink" title="定义： 保证一个类只有一个实例，并提供一个访问它的全局访问点。"></a>定义： 保证一个类只有一个实例，并提供一个访问它的全局访问点。</h2><h3 id="单子模式的优点"><a href="#单子模式的优点" class="headerlink" title="单子模式的优点"></a>单子模式的优点</h3><h2 id="单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。"><a href="#单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。" class="headerlink" title="单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。"></a>单子类的唯一实例由单子类本身控制，所以可以很好地控制用户何时访问它。</h2><h3 id="单子模式的使用场景"><a href="#单子模式的使用场景" class="headerlink" title="单子模式的使用场景"></a>单子模式的使用场景</h3><p>当系统需要某个类只能有一个实例。</p>
<h3 id="下面代码实现了两种经典单子模式和线程安全的单子模式"><a href="#下面代码实现了两种经典单子模式和线程安全的单子模式" class="headerlink" title="下面代码实现了两种经典单子模式和线程安全的单子模式"></a>下面代码实现了两种经典单子模式和线程安全的单子模式</h3><hr>
<h4 id="代码部分："><a href="#代码部分：" class="headerlink" title="代码部分："></a>代码部分：</h4><h5 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h5><pre><code>public class Singleton {


private Singleton() {}  
private static Singleton single=null;  
//静态工厂方法   
public static Singleton getInstance() {  
     if (single == null) {    
         single = new Singleton();  
     }    
    return single;  
}  
</code></pre><p>   }</p>
<h5 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h5><pre><code>public class Singleton1 {


   private Singleton1() {}  
    private static final Singleton1 single = new Singleton1();  
    //静态工厂方法   
    public static Singleton1 getInstance() {  
        return single;  
    } 
}
</code></pre><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><pre><code>public class TestSingleton {  
String name = null;  

    private TestSingleton() {  
}  

private static volatile TestSingleton instance = null;  

public static TestSingleton getInstance() {  
       if (instance == null) {    
         synchronized (TestSingleton.class) {    
            if (instance == null) {    
               instance = new TestSingleton();   
            }    
         }    
       }   
       return instance;  
}  

public String getName() {  
    return name;  
}  

public void setName(String name) {  
    this.name = name;  
}  

public void printInfo() {  
    System.out.println(&quot;the name is &quot; + name);  
}  

} 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单子模式详解&quot;&gt;&lt;a href=&quot;#单子模式详解&quot; class=&quot;headerlink&quot; title=&quot;单子模式详解&quot;&gt;&lt;/a&gt;单子模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/迭代器详解/</id>
    <published>2017-01-22T13:38:27.000Z</published>
    <updated>2017-01-22T13:51:30.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="迭代器模式详解"><a href="#迭代器模式详解" class="headerlink" title="迭代器模式详解"></a>迭代器模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。"><a href="#定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。" class="headerlink" title="定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。"></a>定义：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</h3><hr>
<h3 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h3><p>迭代器模式的结构中包括四种角色：</p>
<ul>
<li>集合：一个接口，规定了具体集合需要实现的操作。</li>
<li>具有集合：具体集合是实现集合接口的类的实例，具体集合按着一定结构存储对象。具体集合应该当有一个方法，该方法返回一个针对该集合的具体迭代器。</li>
<li>迭代器：一个接口，规定了遍历具体集合的方法。</li>
<li>具体迭代器实现迭代器接口的类的实例。具体迭代器在实现迭代器接口所规定的遍历集合的方法时，要保证方法的首次调用将按着集合的数据结构找到该集合中的一个对象，立刻根据该集合的存储结构得到待遍历的后继对象的引用，并保证依次调用的方法可以遍历集合。</li>
</ul>
<hr>
<h3 id="迭代器模式的优点"><a href="#迭代器模式的优点" class="headerlink" title="迭代器模式的优点"></a>迭代器模式的优点</h3><ul>
<li>用户使用迭代器访问集合中的对象，而不需要知道这些对象在集合中是如何表示及存储的。</li>
<li>用户可以同时使用多个迭代器遍历一个集合。</li>
</ul>
<hr>
<h3 id="适合使用迭代器模式的情景"><a href="#适合使用迭代器模式的情景" class="headerlink" title="适合使用迭代器模式的情景"></a>适合使用迭代器模式的情景</h3><ul>
<li>让用户访问一个集合中是对象，但不想暴露对象在集合中的存储结构。</li>
<li>希望对遍历不同的集合提供一个统一的接口。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><pre><code>import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.TreeSet;

public class UseSet {
LinkedList&lt;Student&gt;list;
Hashtable&lt;String, Student&gt;table;
TreeSet&lt;Student&gt;tree;
UseSet(){
    list=new LinkedList&lt;Student&gt;();
    tree=new TreeSet&lt;Student&gt;();
    table=new Hashtable&lt;String,Student&gt;();
}
public void addStudent(Student stu){
    list.add(stu);
    update();

}
public  void lookStudent(String n) {
        Student stu=table.get(n);
        String number=stu.getNumber();
        String name=stu.getName();
        double score=stu.getSorce();
        System.out.println(&quot;学号：&quot;+number+&quot;姓名:&quot;+name+&quot;分数：&quot;+score);

}
public void printStudentByScore(){
    Iterator&lt;Student&gt;iterator=tree.iterator();
    while(iterator.hasNext()){
        Student stu=iterator.next();
        String number=stu.getNumber();
        String name=stu.getName();
        double sorce=stu.getSorce();
        System.out.println(&quot;学号：&quot;+number+&quot;姓名：&quot;+name+&quot;分数：&quot;+sorce);
    }
}
private void update() {
        tree.clear();
        Iterator&lt;Student&gt;iterator=list.iterator();
        while(iterator.hasNext()){
            Student stu=iterator.next();
            String number=stu.getNumber();
            table.put(number, stu);
            tree.add(stu);
        }
}
</code></pre><p>   }</p>
<p>   public class Student implements Comparable{<br>    String number,name;<br>    double sorce=0;<br>    private int x=10;</p>
<pre><code>public Student() {
    super();
    // TODO Auto-generated constructor stub
}

public Student(String number, String name, double sorce) {
    super();
    this.number = number;
    this.name = name;
    this.sorce = sorce;
}

@Override
public int compareTo(Object o) {
    Student st=(Student)o;
    if(Math.abs(this.sorce-st.sorce)&lt;=1/10000)
         return 1;
    return (int)(1000*(this.sorce-st.sorce));
}

public String getNumber() {
    return number;
}

public String getName() {
    return name;
}

public double getSorce() {
    return sorce;
}
</code></pre><p>   }</p>
<pre><code>public class Application {
public static void main(String[] args) {
UseSet useSet=new UseSet();
useSet.addStudent(new Student(&quot;001&quot;, &quot;cc&quot;, 76.9));
String n=&quot;001&quot;;
System.out.println(&quot;查找学号为：&quot;+n+&quot;的学生：&quot;);
useSet.lookStudent(n);
System.out.println(&quot;将学生按成绩排列:&quot;);
useSet.printStudentByScore();
}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;迭代器模式详解&quot;&gt;&lt;a href=&quot;#迭代器模式详解&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式详解&quot;&gt;&lt;/a&gt;迭代器模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/中介者模式详解/</id>
    <published>2017-01-22T13:38:12.000Z</published>
    <updated>2017-01-22T13:51:24.415Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中介者模式详解"><a href="#中介者模式详解" class="headerlink" title="中介者模式详解"></a>中介者模式详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h3 id="定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。"><a href="#定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。" class="headerlink" title="定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。"></a>定义：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，而使其耦合松散，而且可以独立地改变他们之间的交互。</h3><hr>
<h3 id="模式的结构和使用"><a href="#模式的结构和使用" class="headerlink" title="模式的结构和使用"></a>模式的结构和使用</h3><p>中介者模式的结构中包含四种角色：</p>
<ul>
<li>中介者：中介者是一个接口，该接口定义了用于同时对象之间进行通信的方法。</li>
<li>具体中介者：具体中介者是实现中介者接口的类。具体中介者需要包含所有具体同事的引用，并通过实现中介者接口中的方法来满足具体同事之间的通信请求。</li>
<li>同事：一个接口，规定了具体同事需要实现的方法。</li>
<li>具体同事：实现同事接口的类，具体同事需要包含具体中介者的引用，一个具体同事需要和其他同事交互时，只需要将自己的请求通知给它所包含的具体中介者即可</li>
</ul>
<hr>
<h3 id="中介者模式的优点"><a href="#中介者模式的优点" class="headerlink" title="中介者模式的优点"></a>中介者模式的优点</h3><ul>
<li>可以避免许多的对象为了之间的通信而相互先是引用，否则，不仅系统难于维护，而且也使其他系统难以复用这些对象。</li>
<li>可以通过中介者将原本分布于多个对象之间的交互行为集中在一起。当这些对象之间需要改变之间的通信行为时，只需使用一个具体中介者即可，不必修改各个具体同事的代码，既这些同事可被重用。</li>
<li>具体中介者使得各个具体同事之间是如何交互的细节，是系统比较清楚地知道整个系统中的同事是如何交互的。</li>
<li>当一些对象想相互通信，但又无法相互包含对方的引用，那么使用中介者模式就可以使这些对象相互通信。</li>
</ul>
<hr>
<h3 id="中介者模式的适用场景"><a href="#中介者模式的适用场景" class="headerlink" title="中介者模式的适用场景"></a>中介者模式的适用场景</h3><ul>
<li>许多对象以复杂的方式交互，所导致的依赖关系时系统难以理解和维护。</li>
<li>一个对象引用其他很多对象，导致难以复用的情况。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h4 id="同事："><a href="#同事：" class="headerlink" title="同事："></a>同事：</h4><pre><code>public interface Colleage {
public void giveMess(String[] mess);
public void receiverMess(String mess);
public void setName(String name);
public String getName();
}
</code></pre><h4 id="具体中介者："><a href="#具体中介者：" class="headerlink" title="具体中介者："></a>具体中介者：</h4><pre><code>public class ConcreteMediator {
ColleagueA colleageA;
ColleageB colleageB;
ColleageC colleageC;
public void registerColleagueA(ColleagueA colleagueA)
{
    this.colleageA=colleagueA;
}
public void registerColleagueB(ColleageB colleagueB)
{
    this.colleageB=colleagueB;
}
public void registerColleagueC(ColleageC colleagueC)
{
    this.colleageC=colleagueC;
}

public void deliverMess(Colleage colleage,String []mess){
    if(colleage==colleageA){
        if(mess.length&gt;=2){
            colleageB.receiverMess(colleage.getName()+mess[0]);
            colleageC.receiverMess(colleage.getName()+mess[1]);
        }else if(colleage==colleageB){
            if(mess.length&gt;=2){
                colleageA.receiverMess(colleage.getName()+mess[0]);
                colleageC.receiverMess(colleage.getName()+mess[1]);
            }

        }else if(colleage==colleageC){
            if(mess.length&gt;=2){
                colleageA.receiverMess(colleage.getName()+mess[0]);
                colleageB.receiverMess(colleage.getName()+mess[1]);
            }
        }
    }
}


}
</code></pre><h4 id="具体同事："><a href="#具体同事：" class="headerlink" title="具体同事："></a>具体同事：</h4><pre><code>public class ColleagueA implements Colleage{

ConcreteMediator mediator;//中介者
String name;

public ColleagueA(ConcreteMediator mediator) {
    this.mediator = mediator;
    mediator.registerColleagueA(this);
}

@Override
public void giveMess(String[] mess) {
    mediator.deliverMess(this, mess);
}

@Override
public void receiverMess(String mess) {
        System.out.println(name+&quot;收到信息&quot;);
        System.out.println(&quot;\t&quot;+mess);
}

@Override
public void setName(String name) {
    this.name=name;
}

@Override
public String getName() {
    return name;
}

}


public class ColleageB implements Colleage{

    ConcreteMediator mediator;
    String name;


public ColleageB(ConcreteMediator mediator) {
     this.mediator = mediator;
     mediator.registerColleagueB(this);
}


public void receiverMess(String mess) {
        System.out.println(name+&quot;收到信息&quot;);
        System.out.println(&quot;\t&quot;+mess);
}


@Override
public void giveMess(String[] mess) {
    mediator.deliverMess(this, mess);
}


@Override
public void setName(String name) {
    this.name=name;

}


@Override
public String getName() {
    return name;
}

}

public class ColleageC implements Colleage{
ConcreteMediator mediator;
String name;


public ColleageC(ConcreteMediator mediator) {
    this.mediator = mediator;
    mediator.registerColleagueC(this);
}

public void receiverMess(String mess) {
        System.out.println(name+&quot;收到的信息&quot;);
        System.out.println(&quot;\t&quot;+mess);
}

@Override
public void giveMess(String[] mess) {
    mediator.deliverMess(this, mess);
}

@Override
public void setName(String name) {
    this.name=name;
}

@Override
public String getName() {
    // TODO Auto-generated method stub
    return null;
}

}
</code></pre><h4 id="模式的使用："><a href="#模式的使用：" class="headerlink" title="模式的使用："></a>模式的使用：</h4><pre><code>public class Application {


public static void main(String[] args) {

    ConcreteMediator mediator=new ConcreteMediator();

    ColleagueA colleagA=new ColleagueA(mediator);
    ColleageB colleageB=new ColleageB(mediator);
    ColleageC colleageC=new ColleageC(mediator);
    colleagA.setName(&quot;aA&quot;);

    colleageB.setName(&quot;aB&quot;);
    colleageC.setName(&quot;ac&quot;);
    String [] messA={&quot;aa100，aa200&quot;};
    colleagA.giveMess(messA);

    String [] messB={&quot;aa10&quot;,&quot;aa20&quot;};
    colleageB.giveMess(messB);
    String [] messC={&quot;aa1&quot;,&quot;aa2&quot;};
    colleageC.giveMess(messC);
}

}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;中介者模式详解&quot;&gt;&lt;a href=&quot;#中介者模式详解&quot; class=&quot;headerlink&quot; title=&quot;中介者模式详解&quot;&gt;&lt;/a&gt;中介者模式详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂方法模式详解</title>
    <link href="http://www.craymc.com/2017/01/22/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.craymc.com/2017/01/22/工厂方法模式详解/</id>
    <published>2017-01-22T13:37:37.000Z</published>
    <updated>2017-01-22T14:11:16.054Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工厂方法详解"><a href="#工厂方法详解" class="headerlink" title="工厂方法详解"></a>工厂方法详解</h3><h5 id="author：craymc"><a href="#author：craymc" class="headerlink" title="author：craymc"></a><strong>author：craymc</strong></h5><hr>
<h4 id="定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。"><a href="#定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。" class="headerlink" title="定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。"></a>定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</h4><hr>
<h4 id="模式的接口和使用"><a href="#模式的接口和使用" class="headerlink" title="模式的接口和使用"></a>模式的接口和使用</h4><p>工厂方法模式的结构中包括四种角色：</p>
<ul>
<li>抽象产品：抽象类或者接口，负责定义具体产品必须实现的方法。</li>
<li>具体产品：具体产品是一个类，如果product是一个抽象类，那么具体产品是product的子类；如果product是一个接口，那么具体产品是实现product接口的类。</li>
<li>构造者：一个接口或抽象类。构造者负责定义一个称作工厂方法的抽象方法，该方法返回具体产品类的实例。</li>
<li>具体构造者：如果构造者是抽象类，具体构造者是构造者的子类如果构造者是接口，具体构造者是实现构造者的类。具体构造者重写工厂方法使该方法返回<br>具体产品的实例。 </li>
</ul>
<hr>
<h4 id="工厂方法模式的优点"><a href="#工厂方法模式的优点" class="headerlink" title="工厂方法模式的优点"></a>工厂方法模式的优点</h4><ul>
<li>使用工厂方法可让用户的代码和某个特定的子类的代码解耦。</li>
<li>工厂方法使用户不必知道它所使用的对象是怎样被创建的，只需知道该对象有哪些方法即可。</li>
</ul>
<h4 id="适合使用工厂方法模式的情景"><a href="#适合使用工厂方法模式的情景" class="headerlink" title="适合使用工厂方法模式的情景"></a>适合使用工厂方法模式的情景</h4><ul>
<li>用户需要一个类的子类的实例，但不希望与该类的子类形成耦合。</li>
<li>用户需要一个类的子类的实例，但用户不知道该类有哪些子类可用。</li>
</ul>
<hr>
<h4 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h4><h5 id="抽象代码"><a href="#抽象代码" class="headerlink" title="抽象代码"></a>抽象代码</h5><pre><code>public abstract class PenCore {
String color;
public abstract void wirteWord(String s);
}
</code></pre><h5 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h5><pre><code>public class RedPencore extends PenCore {
RedPencore(){
    color=&quot;红色&quot;;
}


@Override
public void wirteWord(String s) {
        System.out.println(&quot;写出&quot;+color+&quot;的字:&quot;+s);
}


}

public class BluePenCore extends PenCore {
public BluePenCore() {
    color=&quot;蓝色&quot;;
}

@Override
public void wirteWord(String s) {
    System.out.println(&quot;写出&quot;+color+&quot;的字:&quot;+s);
}

}

public class BlackPenCore  extends PenCore{

public BlackPenCore() {
    color=&quot;黑色&quot;;
}

@Override
public void wirteWord(String s) {
    System.out.println(&quot;写出&quot;+color+&quot;的字：&quot;+s);
}

}
</code></pre><h5 id="构造者"><a href="#构造者" class="headerlink" title="构造者"></a>构造者</h5><pre><code>public abstract class BallPen {
public BallPen() {
    System.out.println(&quot;生产了一只装有&quot;+getPenCore().color+&quot;笔芯的圆珠笔&quot;);
}
public abstract PenCore getPenCore();

}
</code></pre><h5 id="具体构造者"><a href="#具体构造者" class="headerlink" title="具体构造者"></a>具体构造者</h5><pre><code>public class RedBallPen extends BallPen{


@Override
public PenCore getPenCore() {

    return new RedPencore();
}


}

public class BlueBalPen extends BallPen{

@Override
public PenCore getPenCore() {

    return new BluePenCore();
}

}

public class BlackBallPen extends BallPen{

@Override
public PenCore getPenCore() {
    return new BlackPenCore();
}

}
</code></pre><h5 id="模式使用"><a href="#模式使用" class="headerlink" title="模式使用"></a>模式使用</h5><pre><code>public class Application {
    public static void main(String[] args) {
        PenCore penCore;
        BallPen ballPen=new BlueBalPen();
        penCore=ballPen.getPenCore();
        penCore.wirteWord(&quot;hello  world&quot;);
        ballPen=new RedBallPen();
        penCore=ballPen.getPenCore();
        penCore.wirteWord(&quot;HOW  ARE  YOU&quot;);
        ballPen=new BlackBallPen();
        penCore=ballPen.getPenCore();
        penCore.wirteWord(&quot;OK&quot;);
    }
 }
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;工厂方法详解&quot;&gt;&lt;a href=&quot;#工厂方法详解&quot; class=&quot;headerlink&quot; title=&quot;工厂方法详解&quot;&gt;&lt;/a&gt;工厂方法详解&lt;/h3&gt;&lt;h5 id=&quot;author：craymc&quot;&gt;&lt;a href=&quot;#author：craymc&quot; class=&quot;he
    
    </summary>
    
    
      <category term="Java设计模式" scheme="http://www.craymc.com/tags/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
